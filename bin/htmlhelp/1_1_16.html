<h1>原型</h1>
<div class="dc">TInteger strtoargvs(TString str, TInteger beginArgv)<br>
TString[] TString::split(TString dataBegin='', TString dataEnd='')</div><h1>说明</h1>
<div class="dc">strtoargvs分解字符串，结果放在argv*中，空格或者制表符作为分界，没有引号斜杠等转意。TString::split用同样的规则分解字符串，结果返回一个TString类型的数组</div><h1>参数</h1>
<div class="dc"><h4>str</h4>
<div class="dc">被分解的字符串</div>
<h4>beginArgvi</h4>
<div class="dc">表示从argv几开始，例如beginArgv为3，则从argv3开始</div>
<h4>dataBegin</h4>
<div class="dc">表示数据开始的分界符</div>
<h4>dataEnd</h4>
<div class="dc">表示数据结束的分界符，在dataBegin和dataEnd之间的内容将被原样转换为一个参数不分析其中的空格。着两个参数的缺省值为空串，这时候分界符缺省为xml标准中的分界符</div>
</div><h1>返回</h1><div class="dc">
strtoargv返回成功分解的参数个数。静态CCB argv*变量会发生改变。beginArgv开始之前的的argv*, 不变；beginArgv开始之后的argv*将被改变；如果s不够分解至argv29，那么剩余的argv*将被清空；如果s分解超过了argv29, 那么剩余的s将被忽略。TString::split返回一个TString类型的数组</div><h1>示例</h1><div class="dc">
s = 'a b cc 00123';<br>
i = strtoargvs(s,3);<br>
assert(i == 4);<br>
assert(argv3 == 'a');<br>
assert(argv4 == 'b');<br>
assert(argv5 == 'cc');<br>
assert(argv6 == '00123');<br>
assert(argv7 == '');<br>
<br>
var TString s3 = 'aaa bbb&nbsp;&nbsp;&nbsp;&nbsp;ccc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ddd\neee &lt;!CDATA[[a a a a a]]&gt;fff gg';<br>
var TString s4[] = s3.split();<br>
assert(s4.length()==8, itoa(s4.length()));<br>
assert(s4[0]=='aaa', s4[0]);<br>
assert(s4[1]=='bbb', s4[1]);<br>
assert(s4[2]=='ccc', s4[2]);<br>
assert(s4[3]=='ddd', s4[3]);<br>
assert(s4[4]=='eee', s4[4]);<br>
assert(s4[5]=='a a a a a', s4[5]);<br>
assert(s4[6]=='fff', s4[6]);<br>
assert(s4[7]=='gg', s4[7]);<br>
<br>
assert('111 222 222'.split()[1]=='222');<br>
assert('111 &quot;222 222&quot;'.split('&quot;')[1]=='222 222');<br>
assert('111 &lt;222 222&gt;'.split('&lt;', '&gt;')[1]=='222 222');<br>
</div>