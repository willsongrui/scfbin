
NAME

    TString::init


SYNOPSIS

    TInteger TString::init(TInteger size, TInteger initialValue)


DESCRIPTION

    字符串初始化，初始化之后字符串本身被改变


ARGUMENTS

    size: 要初始化的长度

    initalValue: 每个字符的值


RETURN

    0


EXAMPLES

    var TString s = 'aaa';
    s.init(10,`b`);
    assert(s == 'bbbbbbbbbb');

NAME

    strlen, binlen, TString::length


SYNOPSIS

    TInteger strlen(TString s)
    TInteger binlen(TString s)
    TInteger TString::length()


DESCRIPTION

    求字符串长度。strlen考虑字符串结束符0，遇到认为结束；而binlen或者TString:
    :length则返回二进制字符串的实际长度


ARGUMENTS

    s: 要求的长度的字符串


RETURN

    字符串长度


EXAMPLES

    assert(strlen('12345') == 5);
    assert(binlen('ABC\00ABC\00') == 8);
    assert(strlen('ABC\00ABC\00') == 3); // the first \00 as the string 
    end

NAME

    strcat


SYNOPSIS

    TString strcat(TString arg1 ,TString arg2)
    result = arg1 + arg2


DESCRIPTION

    字符串连接，可以使用函数，也可以直接使用加法操作符进行


ARGUMENTS

    arg1: 第一个字符串

    arg2: 第二个字符串


RETURN

    连接后的新字符串


EXAMPLES

    var TString s = strcat('a', 'b');
    assert(s == 'ab');
    s = s + s;
    assert(s == 'abab');

NAME

    str0cat


SYNOPSIS

    TString  str0cat(TString arg1, TString arg2)


DESCRIPTION

    字符串拼接，中间用0分割


ARGUMENTS

    arg1: 第一个字符串

    arg2: 第二个字符串


RETURN

    连接后的新字符串 


EXAMPLES

    var TString s = str0cat('aaa', 'bbb');
    assert(s == 'aaa\00bbb');

NAME

    strstr, strcasestr


SYNOPSIS

    TString strstr(TString arg1 ,TString arg2)
    TString strcasestr (TString arg1 ,TString arg2)


DESCRIPTION

    字符串中查找子串，strstr区分大小写，strcasestr不区分大小写


ARGUMENTS

    arg1: 源字符串

    arg2: 匹配字符串


RETURN

    匹配位置之后的子串，如果没有查到，返回空串


EXAMPLES

    assert(strstr('abcd', 'c') == 'cd');
    assert(strcasestr('abCd', 'c') == 'Cd');

NAME

    substr, TString::substr


SYNOPSIS

    TString substr (TString str, TInteger start, TInteger length=-1)
    TString TString::substr (TInteger start, TInteger length=-1)


DESCRIPTION

    在字符串中抽取从 start 下标开始的指定数目的字符


ARGUMENTS

    str: 源字符串

    start: 要抽取的子串的起始下标:
    如果大于或者等于0，那么从字符串开头开始算，0开始
    如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 
    指字符串中最后一个字符，-2指倒数第二个字符，以此类推。

    length: 抽取的子串中的最大字符数。如果省略了该参数，那么返回从开始位
    置到结尾的字串


RETURN

    抽取的字符串


EXAMPLES

    assert(substr('abcde', 2, 3) == 'cde');
    assert(substr('abcde', -2, 3) == 'bcd');
    assert('12345678'.substr(0,3) == '123');
    assert('12345678'.substr(1,10) == '2345678');
    assert('12345678'.substr(1) == '2345678');
    assert('12345678'.substr(10,2) == '');
    assert('12345678'.substr(-1) == '12345678');
    assert('12345678'.substr(-1,3) == '678');
    assert('12345678'.substr(-3,3) == '456');
    assert('12345678'.substr(-3,10) == '123456');
    assert('12345678'.substr(-10,3) == '');
    assert('12345678'.substr(-7,5) == '12');
    assert('12345678'.substr(-5) == '1234');
    assert('12345678'.substr(-1,9) == '12345678');
    assert('12345678'.substr(-1,8) == '12345678');

NAME

    cutgbklen


SYNOPSIS

    TString cutgbklen(TString s, TInteger cutEncodeLen, TInteger type)


DESCRIPTION

    截取字符串，返回截取的字符串，源串同时发生改变。根据gbk编码的方式，保
    证不会截取半个汉字，如果截取长度正好在半个汉字上，那么少截取一个字节

    

ARGUMENTS

    s: 源字符串，函数执行之后，其内容会发生改变

    cutEncodeLen: 要截取的字符串的编码长度。因为截取之后一般要编码，这个
    函数根据这个长度以及编码方式，计算出对源串实际截取多长才能符合这个编码
    长度

    type: 西文字符的编码方式，1为1字节编码，2为2字节编码


RETURN

    截取的字符串


EXAMPLES

    var TString s = '话：057，座国际';
    var TString s1 = cutgbklen(s, 4, 1);
    assert(s1 == '话：');
    assert(s == '057，座国际');
    s1 = cutgbklen(s, 4, 1);
    assert(s1 == '057'); // the 4th char is Chinese GBK code, so only 3 
    bytes cut.
    assert(s == '，座国际');
    s = 'abc';
    s1 = cutgbklen(s, 4, 2);
    assert(s1 == 'ab');  // 2 characters need 4 bytes
    assert(s == 'c');

NAME

    strxchar


SYNOPSIS

    TString  strxchar( TString arg1)


DESCRIPTION

    逐对交换字符串的相邻字符，一般来说，字符串长度应该是偶数，否则会自动
    补0再交换


ARGUMENTS

    arg1: 要转换的字符串


RETURN

    转换后的字符串


EXAMPLES

    assert(strxchar('1234') == '2143')
    assert(strxchar('123')=='2103');
    assert(strxchar('1')=='01');
    assert(strxchar('')=='');

NAME

    ltrim, rtrim, trim


SYNOPSIS

    TString  ltrim (TString s)
    TString  rtrim (TString s)
    TString  trim (TString s)


DESCRIPTION

    字符串格式整理，ltrim消除字符串左空格, rtrim消除字符串右空格，trim不
    但消除字符串左右的空格，并且将字符串中多余的空格和tab,回车也消除，只保
    留一个空格


ARGUMENTS

    s: 要整理的字符串


RETURN

    整理后字符串


EXAMPLES

    assert(ltrim('  abc') == 'abc');
    assert(rtrim(' abc  ') == ' abc');
    assert(trim('  ab  cd  ') == 'ab cd');

NAME

    lower, upper


SYNOPSIS

    TString lower(TString s)
    TString upper(TString s)


DESCRIPTION

    字符串大小写转换，lower将字符串全部转换为小写，upper将字符串全部转换
    为大写


ARGUMENTS

    s: 要转换的字符串


RETURN

    转换后的字符串


EXAMPLES

    assert(lower('Abc') == 'abc');
    assert(upper('abC ') == 'ABC');

NAME

    TString::foreachbyte


SYNOPSIS

    TString::foreachbyte(TString operater, TInteger value)


DESCRIPTION

    用于对一个字符串的每一个字节做一个运算，可以用于简单的字符串加密


ARGUMENTS

    operater: 操作符，支持加，减，乘，除，取余，与，或，异或

    value: 操作值


RETURN

    0


EXAMPLES

    var TString s;
    s.init(10, `A`);
    assert(s == 'AAAAAAAAAA');
    s.foreachbyte('+', 3);
    assert(s == 'DDDDDDDDDD');
    s.foreachbyte('-', 1);
    assert(s == 'CCCCCCCCCC');

NAME

    pickword


SYNOPSIS

    TString  pickword(TString str, TString sepStr, TInteger index)


DESCRIPTION

    从字符串按照分界符提取指定序号的子串，或者随机返回某个子串


ARGUMENTS

    str: 源字符串

    sepStr: 分界符

    index: 整数，分界符在源字符串中的位置。如果这个字符串被分界符分割为n个
    子串，那么一般来说这个index的取值范围应该是0到n-1。
    如果取比n-1还大的值，会返回空串。
    如果取-1，那么会返回第m个子串，m是0到n-1之间的随机数


RETURN

    提取后的指定序号的字符串


EXAMPLES

    assert(pickword('aaa/bbb/ccc/ddd ', '/', 2) == 'ccc');
    var s = pickword('aaa/bbb/ccc/ddd ', '/', -1); // random return
    assert(s == 'aaa' || s == 'bbb' || s == 'ccc' || s == 'ddd');

NAME

    alignstr


SYNOPSIS

    TString alignstr(TString arg1, TString arg2, TInteger i)


DESCRIPTION

    字符串对齐


ARGUMENTS

    arg1: 要处理的字符串

    arg2: 要补的字符

    i: 对齐方式，负数表示左对齐，正数表示右对齐，如果要处理的字符串长度大
    于对齐长度，多余部分被截掉


RETURN

    对齐后的字符串


EXAMPLES

    assert(alignstr('1100', 'F',6) == 'FF1100');
    assert(alignstr('1100', 'F',3) == '100');
    assert(alignstr('1100', 'F',4) == '1100');
    assert(alignstr('1100', 'F',-6) == '1100FF');
    assert(alignstr('1100', 'F',-3) == '110');
    assert(alignstr('1100', 'F',-4) == '1100');

NAME

    sprintf, sprintbin


SYNOPSIS

    TString  sprintf(TString format，...)
    TString  sprintbin(TString binStr)


DESCRIPTION

    sprintf根据格式构造一个字符串，同c语言中sprintf函数。sprintbin则是把
    一个可能含有不可打印字符的字符串构造一个可以打印的字符串返回，sprintbin函
    数一般和print配合使用用于trace输出


ARGUMENTS

    format: 同c语言参数的sprintf函数

    binStr: 可能含有不可打印字符的字符串

    ...: 同c语言参数的sprintf函数，但是参数列表的个数有限制，最多30个


RETURN

    构造的字符串


EXAMPLES

    var TString s1 = 'aaa';
    var TString s2 = 'bbb';
    var TString s = sprintf('%s%s',s1,s2);
    assert(s == 'aaabbb');
    
    var TString binStr = 'abc\00\00\01\01abc';
    print(sprintbin(binStr));
    // may output:
    // 0     61 62 63 00 00 01 01 61  62 63                     abc....abc

NAME

    sscanf


SYNOPSIS

    TInteger sscanf(TString strSrc, TString format, ...)


DESCRIPTION

    sscanf从源字符串中分离出各个字段，并且不会改变原来字符串


ARGUMENTS

    strSrc: 源字符串

    format: 同c语言参数的sscanf函数

    ...: 同c语言参数的sscanf函数，但是参数列表的个数有限制，最多80个


RETURN

    返回分离的字段数


EXAMPLES

    var TString str1;
       var TString str2;
       var TString str3;
       str1=’how are you’;
       sscanf(str1,’%s %s %s’,str2,str3);
       ......
    
       本例返回str2=how, str3=are you

NAME

    strtoargvs, TString::split


SYNOPSIS

    TInteger strtoargvs(TString str, TInteger beginArgv)
    TString[] TString::split(TString dataBegin='', TString dataEnd='')


DESCRIPTION

    strtoargvs分解字符串，结果放在argv*中，空格或者制表符作为分界，没有引
    号斜杠等转意。TString::split用同样的规则分解字符串，结果返回一个TString类
    型的数组


ARGUMENTS

    str: 被分解的字符串

    beginArgvi: 表示从argv几开始，例如beginArgv为3，则从argv3开始

    dataBegin: 表示数据开始的分界符

    dataEnd: 表示数据结束的分界符，在dataBegin和dataEnd之间的内容将被原样
    转换为一个参数不分析其中的空格。着两个参数的缺省值为空串，这时候分界符
    缺省为xml标准中的分界符


RETURN

    strtoargv返回成功分解的参数个数。静态CCB argv*变量会发生改变。beginArgv开
    始之前的的argv*, 不变；beginArgv开始之后的argv*将被改变；如果s不够分解
    至argv29，那么剩余的argv*将被清空；如果s分解超过了argv29, 那么剩余的s将
    被忽略。TString::split返回一个TString类型的数组


EXAMPLES

    s = 'a b cc 00123';
    i = strtoargvs(s,3);
    assert(i == 4);
    assert(argv3 == 'a');
    assert(argv4 == 'b');
    assert(argv5 == 'cc');
    assert(argv6 == '00123');
    assert(argv7 == '');
    
    var TString s3 = 'aaa bbb    ccc     ddd\neee <!CDATA[[a a a a a]]>fff 
    gg';
    var TString s4[] = s3.split();
    assert(s4.length()==8, itoa(s4.length()));
    assert(s4[0]=='aaa', s4[0]);
    assert(s4[1]=='bbb', s4[1]);
    assert(s4[2]=='ccc', s4[2]);
    assert(s4[3]=='ddd', s4[3]);
    assert(s4[4]=='eee', s4[4]);
    assert(s4[5]=='a a a a a', s4[5]);
    assert(s4[6]=='fff', s4[6]);
    assert(s4[7]=='gg', s4[7]);
    
    assert('111 222 222'.split()[1]=='222');
    assert('111 "222 222"'.split('"')[1]=='222 222');
    assert('111 <222 222>'.split('<', '>')[1]=='222 222');

NAME

    trimfloatstr


SYNOPSIS

    TString  trimfloatstr (TString arg1,TInteger i)


DESCRIPTION

    将字符串补零


ARGUMENTS

    arg1: 要补零的字符串

    i: 补零个数，如果i为正数，在字符串后面补i个0；如果i为负数，在字符串后
    面补小数点和i个0


RETURN

    改变后的字符串


EXAMPLES

    assert(trimfloatstr ('126', 2) == '12600');
    assert(trimfloatstr ('126', -2) == '126.00');

NAME

    strreplace, TString::replace


SYNOPSIS

    TString strreplace(TString source, TString from, TString to)
    TInteger TString::replace(TString from, TString to)


DESCRIPTION

    替换字符串，将source中的所有的from全部替换成to，返回替换后的结果(区分
    大小写)。strreplace并不改变源串，返回替换后的字符串。而TString::replace直
    接在源串上替换，并且可以支持含有普通字符串结束符0的字符串


ARGUMENTS

    source: 源字符串

    from: 源字符串中被替换的字符

    to: 替换后的字符


RETURN

    strreplace返回替换之后的字符串，TString::replace返回0


EXAMPLES

    assert(strreplace('abcdABcd','ab','cc') == 'cccdABcd');
    s='111111';
    s.replace('1', '2');
    assert(s == '222222');
    s.replace('2', '\00\01');
    assert(s == '\00\01\00\01\00\01\00\01\00\01\00\01');
    s.replace('\01', '\02\03');
    assert(s == '\00\02\03\00\02\03\00\02\03\00\02\03\00\02\03\00\02\03'
    );

NAME

    strhtmlwrap, htmltextencode


SYNOPSIS

    TString strhtmlwrap(TString s)
    TString htmltextencode(TString s, TInteger type=7)


DESCRIPTION

    strhtmlwrap只将字符串中的回车符转换为<br>。这个函数针对含有回车的文本
    嵌入到html中让浏览器正确显示。如果文本中除了含有回车之外，还有一些html特
    殊字符，则需要使用htmltextencode转换，将相关的特殊字符转换为html实体

    

ARGUMENTS

    s: 要被转换的字符串

    type: 如果type为7则有连接符，大于号，小于号，单引号，双引号，空白，回
    车这7种字符被处理。如果type为5，则空白和回车不处理，只有其余5个字符处
    理。缺省为7


RETURN

    转换之后的字符串。注意htmltextencode除了将回车转换为<br>之外，回车仍
    然保留，并不删掉


EXAMPLES

    var TString s = 'lkjsaf\nasdlkfsdf\naslkdjfh\n asdlkfjhsadf\nasdlfk\
    n';
    s = strhtmlwrap(s);
    assert(s == 'lkjsaf<br>asdlkfsdf<br>aslkdjfh<br> asdlkfjhsadf<br>asdlfk<
    br>');
    s = 'ab\nc&def<g>\n';
    assert(htmltextencode(s) == 'ab<br>\nc&amp;def&lt;g&gt;<br>\n');
    assert(htmltextencode(s,5) == 'ab\nc&amp;def&lt;g&gt;\n');

NAME

    convertlabel


SYNOPSIS

    TString convertlabel(TString source, TString fromdigits, TString todigits,
     TInteger colindex, TString defaultdigits)


DESCRIPTION

    转化显示字符串，返回转化后的结果


ARGUMENTS

    source: 转化前的字符串

    fromdigits: 被转化的字符

    todigits: 转化后的字符

    colindex: 转化的列的索引,注意第一列从0开始

    defaultdigits: 如果转化的列，找不到与fromdigits匹配的，那么转化成defaultdigits

    

RETURN

    转化后的字符串


EXAMPLES

    var TString sourData = '11111111|1|20040404
    22222222|2|20040504
    33333333|3|20050404';
    // 其中的第二列的1,2,3,分别代表A类卡,B类卡,C类卡
    
    var TString result;
    result = convertlabel(sourData,"1|2","A类卡|B类卡",1,"C类卡");
    // or
    result = convertlabel(sourData,"1|2|3","A类卡|B类卡|C类卡",1,"")
    
    // 转化后的结果:
    assert(result = '11111111|A类卡|20040404
    22222222|B类卡|20040504
    33333333|C类卡|20050404');

NAME

    TString::getbyte, TString::setbyte


SYNOPSIS

    TInteger TString::getbyte(TInteger index)
    TInteger TString::setbyte(TInteger index, TInteger value)


DESCRIPTION

    对字符串的某个字节进行操作，getbyte是取得某个字节，setbyte是设置某个
    字节


ARGUMENTS

    index: 整数，必须是在字符串的长度允许范围之内，0开始

    value: 整数，要设置的字符串某个byte的值


RETURN

    整数，返回负数表示失败。getbyte成功将返回某个byte的整数值，0-255返回
    。setbyte成功将返回0


EXAMPLES

    var TString s='12345';
    assert(s.getbyte(2) == 51);
    s.setbyte(1,51);
    assert(s == '13345');

NAME

    TString::cuthead


SYNOPSIS

    TString TString::cuthead(TString sepFlag)


DESCRIPTION

    对字符串根据分割字符串查找第一个部分，返回，并把源串的第一个部分以及
    这个分割字符串都裁掉。如果这个分割串找不到，源串会被全部裁掉，并返回整
    个原串


ARGUMENTS

    sepFlag: 字符串，分割字符串


RETURN

    字符串，分割的第一部分


EXAMPLES

    var TString s='123 456';
    s1 = s.cuthead(' ');
    assert(s == '456');
    assert(s1 == '123');
    s1 = s.cuthead('A');
    assert(s == '');
    assert(s1 == '456');

NAME

    TString::collectnumber


SYNOPSIS

    TInteger TString::collectnumber(TString addNumber, TString ruleTag)

    

DESCRIPTION

    收集可变长的号码，根据规则决定收集的长度，根据返回值判断是否收齐


ARGUMENTS

    addNumber: 本次收集的部分号码

    ruleTag: 判断号码长度的规则在numbertab文件中配置的字冠


RETURN

    整数，返回0表示号码收集已经完整，返回大于0表示目前根据规则判断尚缺的
    位数


EXAMPLES

    # the numbertab file configuration:
    A010                     11
    A01011                   6
    A02[0-9]11               6
    A01012[0-2]              6
    A02[0-9]12[0-2]          6
    A010123                  8
    A02[0-9]123              8
    A01095                   8
    A02[0-9]95               8
    A013                     12
    A0[3-9][0-9][0-9]11      7
    A0[3-9][0-9][0-9]12[0-2] 7
    A0[3-9][0-9][0-9]123     9
    A0[3-9][0-9][0-9]95      9
    A0451                    12
    配置的第一列是字冠匹配规则，第二列是匹配上这个字冠规则的号码需要收集
    的位数。
    例如上面的意思是，010开头的号码需要手记11位，01011开头的号码需要收集
    6位等等。
    然后程序中可以定义一个TString类型的变量存储收集的号码，例如：
    var TString number;
    然后可以根据情况循环调用TString::collectnumber函数，例如：
    number.collectnumber(s,'A');
    'A'是上面配置的规则字冠，s是每次收到的一部分号码。

NAME

    TString::hashcode


SYNOPSIS

    TInteger TString::hashcode()


DESCRIPTION

    对字符串运算求得一个HASH结果


ARGUMENTS

    无

RETURN

    整数的HASH结果


EXAMPLES

    var TString str1;
    var TInteger itmp;
    ......
    str1='233a';
    itmp = str1.hashcode();

NAME

    atoi, atoi2, atoi16


SYNOPSIS

    TInteger atoi(TString intstr)
    TInteger atoi2(TString intstr)
    TInteger atoi16(TString intstr)


DESCRIPTION

    转换字符串为整数，atoi针对10进制字符串，atoi2针对2进制字符串，atoi16针
    对16进制字符串


ARGUMENTS

    intstr: 要转换的字符串


RETURN

    转换后的整数


EXAMPLES

    assert(atoi('100') == 100);
    assert(atoi2('11111111') == 255);
    assert(atoi16('FF') == 255);

NAME

    itoa, itoa2


SYNOPSIS

    TString itoa(TInteger i)
    TString itoa2(TInteger i)


DESCRIPTION

    将整数转换为字符串，itoa返回10进制整数字符串。itoa2返回2进制整数字符
    串


ARGUMENTS

    i: 要转换的整数。对itoa2，这个整数只能是0-255之间


RETURN

    转换后的字符串。对itoa2，固定返回8位


EXAMPLES

    assert(itoa(255) == '255');
    assert(itoa2(255) == '11111111');
    assert(itoa2(1) == '00000001');

NAME

    acrdurationtoint1, acrdurationtoint2


SYNOPSIS

    TInteger  acrdurationtoint1 (TString durationStr)
    TInteger  acrdurationtoint2 (TString durationStr)


DESCRIPTION

    将ACR返回的duration转换为秒数。因为INAP协议定义的不确定性，导致不同的
    交换机返回的duration参数格式有所不同，所以定义了着两个函数


ARGUMENTS

    durationStr: 8个字符：
    对于acrdurationtoint1，次序为H2 H1 H0 M1 M0 S1 S0 T
    对于acrdurationtoint2，次序为H1 H2 M1 H0 S1 M0 T S0
    （H表示小时，M表示分，S表示秒，T表示厘秒；2表示百位，1表示十位，0表示
    个位）


RETURN

    整数类型的以秒单位duration，如果厘秒不为0则算一秒。


EXAMPLES

    assert(acrdurationtoint1('00123456') == 5026) // 1:23:45.6
    assert(acrdurationtoint2('00123456') == 8077) // 2:14:36.5

NAME

    strd2h, strh2d, strh2u


SYNOPSIS

    TString strd2h(TString s)
    TString strh2d(TString s)
    TString strh2u(TString s)


DESCRIPTION

    strd2h将表示10进制整数的字符串转换为表示16进制整数的串，可以支持的整
    数范围是：-9223372036854775808 到 9223372036854775807
    strh2d将表示16进制整数的字符串按照有符号数转换为表示10进制整数的串，
    可以支持的长度为2-16位
    strh2u将表示16进制整数的字符串按照无符号数转换为表示10进制整数的串，
    可以支持的长度为2-16位，这个函数与strh2d函数的区别是，后者是按照有符号
    整数处理的。例如，对于'FF'，strh2d('FF')将得到'-1'，而strh2u('FF')将得
    到'255'
    strd2h的返回结果是最短表示。strh2d输入可以是最短表示，也可以允许前面
    有冗余的FF或者00


ARGUMENTS

    s: 被转换的字符串


RETURN

    转换后的返回结果


EXAMPLES

    assert(strd2h('-9223372036854775808') == '8000000000000000');
    assert(strd2h('-1') == 'FF');
    assert(strd2h('0') == '00');
    assert(strd2h('9223372036854775807') == '7FFFFFFFFFFFFFFF');
    assert(strd2h('-9223372036854775808') == '8000000000000000');
    
    assert(strh2d('8000000000000000') == '-9223372036854775808');
    assert(strh2d('FF') == '-1');
    assert(strh2d('FFFFFFFFFFFFFFFF') == '-1');
    assert(strh2d('00') == '0');
    assert(strh2d('0000000000000000') == '0');
    assert(strh2d('7FFFFFFFFFFFFFFF') == '9223372036854775807');
    assert(strh2d('8000000000000000') == '-9223372036854775808');
    
    assert(strh2u('00') == '0');
    assert(strh2u('ff') == '255');
    assert(strh2u('ffff') == '65535');
    assert(strh2u('ffffffffffffffff') == '18446744073709551615');
    assert(strh2u('8000000000000000') == '9223372036854775808');
    assert(strh2u('7fffffffffffffff') == '9223372036854775807');

NAME

    ipaddressd2h, ipaddressh2d


SYNOPSIS

    TString ipaddressd2h(TString sd)
    TString ipaddressh2d(TString sh)


DESCRIPTION

    ipaddressd2h将表示10进制IP地址字符串转换为16进制格式
    ipaddressh2dh将16进制格式的IP地址字符串转换为表示10进制IP地址字符串

    

ARGUMENTS

    sd: 十进制格式的IP地址字符串，例如'192.168.2.217'

    sh: 16制格式的IP地址字符串，固定6个字节，前两个字节是00,01，后面4个字
    节是IP地址的4个字节


RETURN

    转换后的返回结果


EXAMPLES

    assert(ipaddressd2h('192.168.2.217') == '\00\01\C0\A8\02\D9');
    assert(ipaddressh2d('\00\01\C0\A8\02\D9') == '192.168.2.217');

NAME

    asctobcd, bcdtoasc


SYNOPSIS

    TString asctobcd(TString s)
    TString bcdtoasc(TString s, TInteger mode=1)


DESCRIPTION

    asc格式和bcd格式的字符串的相互转换


ARGUMENTS

    s: 要转换的字符串，asc字符串必须是0-9A-Fa-f或者星号井号的组合，其中星
    号代表B，井号代表C

    mode: 转换后的asc字符串的格式，如果为1那么BC用星号井号代替，如果为0，
    则直接返回BC，缺省为1


RETURN

    转换后的字符串。如果asc字符串长度为奇数，那么转换后的BCD字符串最后的
    填充位为0


EXAMPLES

    assert(asctobcd('126') == '\21\06');
    assert(bcdtoasc('\02\50\90\51\71\23\52') == '20050915173225');

NAME

    gsmtoasc, asctogsm


SYNOPSIS

    TString gsmtoasc(TString s)
    TString  asctogsm(TString s)


DESCRIPTION

    在短消息编解码的时候用到这两个函数。gsmtoasc是一个8位变7位的过程，而
    asctogsm是一个7位变8位的过程。所谓7变8是针对早期的英文短信，每个字符只
    有7位有效，为了避免最高位的浪费产生的一种编码方式，7变8是对其的解码过
    程。这两个函数由于实现的问题，并不是对称的。例子中有一个较为详细的解释
    


ARGUMENTS

    s: 要转换的字符串。


RETURN

    转换之后的字符串


EXAMPLES

    例如要发送短消息'1234abcd'，8个字节，那么：
    首先调用asctogsm('1234abcd')得到'139DC86161F89C'；
    然后调用asctobcd('139DC86161F89C')得到7个字节:31 D9 8C 16 16 8F C9发
    送；
    这就是7位变8位的效果，使得8个字节的消息只要7个字节的传输，节省了一个
    字节。
    
    如果收到了7个字节的消息：31 D9 8C 16 16 8F C9，那么：
    首先调用bcdtoasc('\31\D9\8C\16\8F\C9',0)转换为'139DC86161F89C'
    再调用strxchar('139DC86161F89C')转换为'31D98C16168FC9'
    再调用gsmtoasc('31D98C16168FC9')就可以恢复为'1234abcd'了。
    
    之所以说着两个函数不对称，就是因为gsmtoasc之前多了一个strxchar

NAME

    gbktounicode, unicodetogbk


SYNOPSIS

    TString gbktounicode(TString source)
    TString unicodetogbk(TString source, TInteger length)


DESCRIPTION

    将gbk编码格式的字符串与unicode编码的字符串的相互转换


ARGUMENTS

    source: 被转化的字符串

    length: 被转化的字符串的长度


RETURN

    转换之后的字符串


NAME

    htmlentity2gbk, htmlentity2utf8


SYNOPSIS

    TString htmlentity2gbk(TString source)
    TString htmlentity2utf8(TString source)


DESCRIPTION

    这两个函数会将参数字符串中的html entity替换为对应的gbk或者utf8编码的
    字符并返回新串。如果entity格式不正确，那么不替换原样返回。对于htmlentity2gbk如
    果对应的unicode没有相应的gbk码对应，那么也不替换原样返回。支持的entity名
    称是html 4.0所定义的253个。


ARGUMENTS

    source: 被转化的字符串


RETURN

    转换之后的字符串


EXAMPLES

    s = htmlentity2gbk('&amp;&gt;&&&&#x61&#x61;&#x54C8;');
    assert(s == '&>&&&&#x61a\B9\FE', s);
    s = htmlentity2gbk('&amp;&gt;&&&&#x61&#x61;&#x54C8;');
    assert(s == '&>&&&&#x61a\E5\93\88', s);

NAME

    bit7tounicode


SYNOPSIS

    TString bit7tounicode(TString source)


DESCRIPTION

    将短消息中7-bit编码格式的字符串转换为unicode编码的字符串


ARGUMENTS

    source: 被转化的字符串


RETURN

    转换之后的字符串


NAME

    utf8toucs2, ucs2toutf8


SYNOPSIS

    TString utf8toucs2(TString s, TInteger i=0)
    TString ucs2toutf8(TString s, TInteger i=0 )


DESCRIPTION

    UTF8和UCS2编码的相互转换


ARGUMENTS

    s: 要转换的字符串

    i: 指示UCS2的字节序（高字节在前还是低字节在前）。对utf8toucs2()来说，
    3为高字节在前，2为低字节在前。对ucs2toutf8()来说，1为高字节在前，0为低
    字节在前。缺省为0。


RETURN

    转换后的字符串，如果源串的格式不正确， 返回空串


EXAMPLES

    assert(utf8toucs2('\EF\BB\BF\E6\B1\89\E5\A5\8E\61\62', 2)
       == '\FF\FE\49\6C\4E\59\61\00\62\00');
    assert(utf8toucs2('\EF\BB\BF\E6\B1\89\E5\A5\8E\61\62', 3)
       == '\FE\FF\6C\49\59\4E\00\61\00\62');

NAME

    gbk2py


SYNOPSIS

    TString gbk2py(TString s)


DESCRIPTION

    gbk编码的汉字到拼音的转换，目前只支持最常用的3755个汉字（所谓的一级字
    库），不在这个范围之内的字符将原样返回不转换。


ARGUMENTS

    s: 要转换的GBK编码的字符串


RETURN

    返回转换之后的拼音字符串，全拼加数字表示的声调，字与字之间没有空格，
    声调1表示阴平，2表示阳平，3表示上声，4表示去声，5表示轻声


EXAMPLES

    assert(gbk2py('汉字到拼音的转换') == 'han4zi4dao4pin1yin1de5zhuan3huan4'
    );

NAME

    base64decode, base64decode


SYNOPSIS

    TString base64encode(TString s)
    TString base64decode(TString s)


DESCRIPTION

    BASE64编解码函数


ARGUMENTS

    s: 编码/解码前字符串


RETURN

    返回编码/解码后字符串


EXAMPLES

    assert(base64encode('abcde') == 'YWJjZGU=');
    assert(base64decode('YWJjZGU=') == 'abcde');

NAME

    encrypt


SYNOPSIS

    TString encrypt(TString src, TString key)


DESCRIPTION

    加密，如果key的长度为2，则调用unix的crypt标准函数加密。否则使用一个欣
    方与冠日公司制定的一个加密算法，只针对6位数字串加密，用于智能公话业务
    


ARGUMENTS

    src: 要加密的字符串

    key: 密钥


RETURN

    加密结果


EXAMPLES

    assert(encrypt('abcd', '12') == '12UhNQxwwKQ7c');
    assert(encrypt('123456', '123456') == '635204');

NAME

    md5


SYNOPSIS

    TString md5(TString s, TInteger length=0)


DESCRIPTION

    加密算法函数，md5加密算法是单向的，所以没有对应的md5解码函数


ARGUMENTS

    s: 要加密的字符串

    length: 如果s中含有字符串结束符，应填写该参数，表示s的长度。这个参数
    缺省为0，只取s中字符串结束符之前的部分


RETURN

    返回结果固定为 16个字节


EXAMPLES

    assert(md5('abcd') == '\E2\FC\71\4C\47\27\EE\93\95\F3\24\CD\2E\7F\33\
    1F');
    assert(md5('abcd\00abcd') == '\E2\FC\71\4C\47\27\EE\93\95\F3\24\CD\2E\
    7F\33\1F');
    assert(md5('abcd\00abcd',9) == '\13\DA\E0\38\04\FD\7F\DA\C5\B0\8E\5B\
    41\02\82\72');

NAME

    descrypt, descbccrypt


SYNOPSIS

    TString descrypt(TString arg1, TString arg2, TInteger arg3, TInteger 
    arg4=0)
    TString descbccrypt(TString arg1, TString arg2, TInteger arg3, TInteger 
    arg4=0)


DESCRIPTION

    descrypt实现des加解密，descbccrypt与descrypt类似，但这个函数使用的是
    基于CBC的des加解密算法。


ARGUMENTS

    arg1: 源字符串（8字节）

    arg2: key字符串（8字节），

    arg3: 源字符串长度，

    arg4: 模式（默认0表示加密， 否则为解密）


RETURN

    返回加/解密后的结果字符串（8字节）


NAME

    desmac


SYNOPSIS

    TString desmac(TString arg1, TString arg2, TInteger arg3)


DESCRIPTION

    根据明文和key生成一个摘要， 用以确保数据传输正确。


ARGUMENTS

    arg1: 明文字符串

    arg2: key字符串（8字节）

    arg3: 明文长度。


RETURN

    8字节的摘要密文


NAME

    rc4crypt


SYNOPSIS

    TString rc4crypt(TString src, TString key, TInteger srcLen=0, TInteger 
    keyLen=0)


DESCRIPTION

    使用RC4加密算法加密


ARGUMENTS

    src: 源字符串

    key: key字符串

    srcLen: 源字符串长度，如果为0，则是src的实际长度，缺省为0

    keyLen: key字符串长度，如果为0，则是key的实际长度，缺省为0


RETURN

    返回加密后的结果字符串


NAME

    idea


SYNOPSIS

    TString idea(TString s, TInteger length, TInteger mode, TString key,
     TString& ivec)


DESCRIPTION

    IDEA加解密函数，采用较为通用的cfb模式


ARGUMENTS

    s: 要加密的字符串

    length: s的长度

    mode: 1:加密 0:解密

    key: 密钥，必须为16字节128比特，通常可以通过一字符串的md5值得到

    ivec: 初始向量，该值无需秘密保存，必须为8字节，变参，后续加密连续使用
    该ivec参数


RETURN

    返回结果为16进制格式，长度为length


EXAMPLES

    #progma c
    void main()
    {
       var TString plain,cipher,cipher1,plain1,cipher2,plain2,plain3;
       var TString key,ivec;
       var TInteger mode,length;
    
       plain='This is the plain i want to encrypt by idea algorithm.';
       key=md5('222222');
       printbin(key);
       ivec='12345678';
    
       length=strlen(plain);
       print('length='+itoa(length));
    
       mode=1;//encrypt
       // first, encrypt the precious 44 bytes
       cipher=idea(plain, length-10, mode, key, ivec);
       print('ivec='+ivec); // ivec is changed
       printbin(cipher);
    
       // then encrypt the last 10 bytes
       cipher1=idea(substr(plain,length-10,10), 10, mode, key, ivec);
       print('cipher1:');
       printbin(cipher1);
    
       cipher2=cipher+cipher1; // the total cipher text
       print('cipher2:');
       printbin(cipher2);
    
       mode=0; // decryption
       ivec='12345678'; // The value is same as encryption
    
       // decrypt the priviois 44 bytes, and the ivec is changed
       plain2=idea(cipher2, length-10, mode, key, ivec);
    
       // decrypt the last 10 bytes
       plain3=idea(substr(cipher2,length-10,10),10,mode,key,ivec);
       plain1=plain2+plain3; // the total plain text
       printbin(plain1);
       printbin(plain);
    
       if(strcmp(plain, plain1)==0)
          print('ok.');
       else
          print('error!');
    }

NAME

    ideaecb


SYNOPSIS

    TString ideaecb(TString s,TString c,TInteger& length,TInteger mode,TString 
    key)


DESCRIPTION

    IDEA加解密函数，ecb模式。该函数与idea函数的区别在于：如果s的长度不满
    8的倍数，则自动用c填充。
    另外ecb模式不使用初始向量，即对于相同的8字节内容和key，加密出来的密文
    是相同的


ARGUMENTS

    s: 要加密的字符串

    c: s长度不满8的倍数时用字符c填充，注意c必须是单字节的字符串

    length: 变参，初值可以设置为0，返回值为填充后的长度，也就是密文的长度
    

    mode: 1:加密 0:解密

    key: 密钥，必须为16字节128比特，通常可以通过一字符串的md5值得到


RETURN

    返回结果为16进制格式，长度为length


EXAMPLES

    #progma c
    void main()
    {
       var TString plain,cipher,cipher1,plain1,cipher2,plain2,plain3;
       var TString key,ivec;
       var TInteger mode,length,newlen;
    
      plain='This is the plain i want to encrypt by ideaecb algorithm.';
    
       key=md5('222222');
       printbin(key);
    
       length=strlen(plain);
       print('length='+itoa(length));
    
       mode=1;//encrypt
       cipher=ideaecb(plain,' ',newlen,mode,key);
       print('newlen='+itoa(newlen));
       printbin(cipher);
    
       mode=0; // decryption
       plain1=ideaecb(cipher,' ',newlen,mode,key);
       print('newlen='+itoa(newlen));
       printbin(plain1);
    
       plain=plain+' '+' ';
       printbin(plain);
       if(strcmp(plain, plain1)==0)
          print('ok.');
       else
          print('error!');
    
       plain2='1234567812345678';
       cipher2=ideaecb(plain2,' ',newlen,1,key);
       print('newlen='+itoa(newlen));
       printbin(cipher2);//fisrt 8 bytes and last 8 bytes are equal
       ivec='11111111';
       cipher1=idea(plain2,16,1,key,ivec);
       printbin(cipher1);//fisrt 8 bytes and last 8 bytes are different
    }

NAME

    httpauthenticate, httpgetauthorization


SYNOPSIS

    TString httpauthenticate(TString nonce, TString realm)
    TString httpgetauthorization(TString a, TString method, TString uri,
     TString username, TString password)


DESCRIPTION

    httpauthenticate用于Server发送消息之前构造WWW-Authenticate字段的内容
    
    httpgetauthorization用于Client端发送消息之前构造Authenticate字段的内
    容


ARGUMENTS

    nonce: nonce字符串

    realm: realm字符串

    a: Client此前收到的消息中的WWW-Authenticate头字段的内容

    method: 发送当前http请求所用的方法，'GET'或'POST'

    uri: 所用请求访问的uri地址，如'/QuickSetup.htm'等

    username: 用户名

    password: 密码


RETURN

    构造好的WWW-Authenticate或Authenticate字段内容


NAME

    httpauthuri, httpauthusername, httpauthnonce


SYNOPSIS

    TString httpauthuri(TString a)
    TString httpauthusername(TString a)
    TString httpauthnonce(TString a)


DESCRIPTION

    Server端收到消息之后获得Authenticate字段内容中的的uri, username, nonce

    

ARGUMENTS

    a: Server收到消息中的Authenticate字段的内容


RETURN

    得到的值


NAME

    httpauthorization


SYNOPSIS

    TInteger httpauthorization(TString a, TString nonce, TString method,
     TString password)


DESCRIPTION

    Server端进行鉴权


ARGUMENTS

    a: Server端收到消息中的Authorization字段的内容

    nonce: nonce字符串

    method: 发送当前http请求所用的方法，'GET'或'POST'

    password: 密码


RETURN

    1成功, 0失败


NAME

    tosec, tosec2, sectoasctime


SYNOPSIS

    TInteger tosec(TString ascTime)
    TString tosec2(TString ascTime)
    TString sectoasctime(TInteger t)


DESCRIPTION

    tosec是求参数时间与1970年1月1日零点的时间差的秒数。这个功能主要用来求
    得两个时间的时间差值。而tosec2是求得参数时间与1900年1月1日零时之间的秒
    数，由于这个数超过了4字节整数的表示范围，所以返回字符串。二者相差70年
    ，也就是2208988800秒
    sectoasctime是tosec的逆过程，根据与1970年1月1日零点的时间差的秒数求ASC格
    式的时间字符串


ARGUMENTS

    ascTime: 表示时间的字符串，格式为YYYYMMDDHHmmSS

    t: 与1970年1月1日零点的时间差的秒数


RETURN

    对tosec是一个整数；对tosec2是一个字符串，十进制表示
    sectoasctime返回表示时间的字符串，格式为YYYYMMDDHHmmSS


EXAMPLES

    var TInteger i = tosec('20040401102030');
    var TInteger j = tosec('20040401112030');
    assert(j - i == 3600);
    
    assert(tosec('20070723093100') == 1185154260);
    assert(tosec2('20070723093100') == '3394143060');
    
    var TString time,time1;
    var TInteger sec;
    var TString time = currentdate8andtime();
    var TInteger sec = tosec(time);
    var TString time1 = sectoasctime(sec);
    assert(time == time1);

NAME

    ntptimestamp


SYNOPSIS

    TString ntptimestamp(TInteger t)


DESCRIPTION

    根据1970年1月1日0时到某时间的秒数，返回某时间的NTP时间戳，NTP时间戳是
    1900年1月1日0时到某时间的秒数的2进制表示形式


ARGUMENTS

    t: 一个秒数，一般是tosec函数的返回结果


RETURN

    固定4个字节，不一定是可打印串


EXAMPLES

    assert(tosec('20070723093100') == 1185154260);
    assert(tosec2('20070723093100') == '3394143060');
    assert(ntptimestamp(1185154260) == '\CA\4E\83\54');
    assert(strh2u('CA4E8354') == '3394143060'); // 3394143060 = 1185154260 
    + 2208988800

NAME

    validasctime


SYNOPSIS

    TInteger validasctime(TString s)


DESCRIPTION

    判断一个字符串是否是一个有效时间


ARGUMENTS

    s: 要判断的字符串


RETURN

    如果有效返回1, 否则返回0


EXAMPLES

    var TInteger iresult;
    iresult = validasctime('20101020141620');
    print('result is:'+itoa(iresult));

NAME

    asctimeadd


SYNOPSIS

    TString asctimeadd(TString t1, TInteger s)


DESCRIPTION

    根据一个时间和一个间隔秒数计算另一个时间


ARGUMENTS

    t1: 表示时间的字符串，格式为YYYYMMDDHHmmSS

    s: 一个秒数差值，整数，可以为负数


RETURN

    一个新的时间字符串，格式为YYYYMMDDHHmmSS


EXAMPLES

    s = asctimeadd(currentdate8andtime(),-3600*24*30)
    // to get the time string before 30 days

NAME

    addmonth


SYNOPSIS

    TString addmonth(TString t1, TInteger s)


DESCRIPTION

    在指定时间后加几个月，如果字符串是有效的日期则返回新的日期，否则抛出
    异常。这里要说明两个规则：
    规则一：如果初始日期是月的最后一天，结果日期也是月的最后一天。
    规则二：因为新的月可能比初始月天数少，保持月的天数不变可能会使结果日
    期是一个无效日期，这时会减少月的天数以保证结果日期有效。


ARGUMENTS

    t1: 表示时间的字符串，格式为YYYYMMDDHHmmSS

    s: 要增加的月数，整数，可以为负数


RETURN

    一个新的时间字符串，格式为YYYYMMDDHHmmSS


EXAMPLES

    assert(addmonth('20100101000000', 1) == '20100201000000');
    assert(addmonth('20100131000000', 1) == '20100228000000');
    assert(addmonth('20100227000000', 1) == '20100327000000');
    assert(addmonth('20100228000000', 1) == '20100331000000');

NAME

    nextweekday


SYNOPSIS

    TString nextweekday(TString t1, TInteger s)


DESCRIPTION

    得到指定日期后的指定周索引的日期， 字符串是有效日期，且周索引有效(0-
    6，周日对应0，是一周的第一天)，则返回响应的日期；否则抛出异常。注意：
    nextweekday总是向前查找，如果传入日期就是要查找的周索引，返回的日期为
    传人日期＋7天。


ARGUMENTS

    t1: 表示时间的字符串，格式为YYYYMMDDHHmmSS

    s: 周索引，整数，0-6之间，表示周日到周六


RETURN

    一个新的时间字符串，格式为YYYYMMDDHHmmSS


EXAMPLES

    // for example, 2002-5-20 is Monday
    assert(nextweekday('20020520000000', 6) == '20020525000000'); // get 
    next Saturday
    assert(nextweekday('20020520000000', 5) == '20020524000000'); // get 
    next Friday

NAME

    monthlastday


SYNOPSIS

    TString monthlastday(TString t1)


DESCRIPTION

    得到指定日期的月末日期，要求字符串是有效日期，否则抛出异常


ARGUMENTS

    t1: 表示时间的字符串，格式为YYYYMMDDHHmmSS


RETURN

    一个新的时间字符串，格式为YYYYMMDDHHmmSS


EXAMPLES

    var TString stmp;
    stmp =monthlastday('20101020');
    print(stmp);
    本例返回时间：20101031142135
    142135为系统本天当前时间
    参数具体到秒时，返回的结果为查找月最后一天的相应时间。否则返回最后一
    天的与当前时间一样的时间

NAME

    strftime, strptime


SYNOPSIS

    TString strftime(TString s1, TString format)
    TString strptime(TString s2, TString format)


DESCRIPTION

    strftime根据格式获取ISO 8601规定格式的日期、时间字符串。
    strptime根据ISO 8601规定格式的日期、时间字符串和格式获取原始时间字符
    串。这个函数在Windows下不支持


ARGUMENTS

    s1: 一般为14位的字符串，YYYYMMDDHHmmSS格式的时间；如果为''，表示当前
    时间（timediff有效）；如果只有6位，则只表示时间

    format: 与unix的strftime的格式参数一致（man strftime）

    s2: 需要被转换的字符串


RETURN

    strftime返回格式化的时间
    strptime返回YYYYMMDDHHmmSS格式的时间, 如果参数不合法，SIB将抛出异常。
    
    如果被转换的不是完整的时间信息，返回的14位字符只有相关字符有效，其它
    部分可能是当前时间的对应，也可能是未知的随机值


EXAMPLES

    assert(strftime('20040723012243', '%T') == '01:22:43');
    assert(strftime('20040723012243', '%c') == 'Fri Jul 23 01:22:43 2004'
    );
    assert(strftime('20040723012243', '%D') == '07/23/04');
    assert(strftime('20000101123456', '%T') == '12:34:56')
    assert(strftime('123456', '%T') == '12:34:56')
    
    assert(strptime('2000-01-01 12:34:56','%Y-%m-%d %T') == '20000101123456'
    );
    assert(strptime('Fri Jul 23 16:00:21 2004','%c') == '20040723160021'
    )

NAME

    currentdate8andtime


SYNOPSIS

    TString  currentdate8andtime(TInteger alignSec=-1, TInteger timeZone=
    0)


DESCRIPTION

    取得系统当前时间，或者通过给定参数校准的当前时间


ARGUMENTS

    alignSec: 格林威治时间0点到现在的秒数（0-86399合法），缺省-1表示直接
    返回系统当前时间，否则返回的时间是通过这个参数校准的

    timeZone: 当地和格林威治时间的时差（分钟为单位）（-720-780合法）


RETURN

    14位ASC码类型的时间，格式为YYYYMMDDHHmmSS。如果是校准时间，则根据校准
    时间求出一个和当前系统时间最接近的时间


EXAMPLES

    例如，在中国东8区运行：
    print(currentdate8andtime());
    // 假设输出20080728201605，28号20点16分，这是scf的当前时间
    
    print(currentdate8andtime(10*3600,480));
    // 校准时间为18点，那么应该返回20080728180000
    
    print(currentdate8andtime(12*3600,480));
    // 校准时间为20点，那么应该返回20080728200000
    
    print(currentdate8andtime(14*3600,480));
    // 校准时间为22点，那么应该返回20080728220000
    
    print(currentdate8andtime(16*3600,480));
    // 校准时间为0点，那么应该返回20080729000000，注意这里已经变为29号，
    因为
    29号0点和当前scf时间比28号0点更接近
    
    print(currentdate8andtime(18*3600,480));
    // 校准时间为2点，那么应该返回20080729020000
    
    print(currentdate8andtime(20*3600,480));
    // 校准时间为4点，那么应该返回20080729040000
    
    print(currentdate8andtime(22*3600,480));
    // 校准时间为6点，那么应该返回20080729060000
    
    print(currentdate8andtime(0,480));
    // 校准时间为8点，那么应该返回20080729080000
    
    print(currentdate8andtime(2*3600,480));
    // 校准时间为10点，那么应该返回20080728100000，注意这里又变回了28号10
    点，因为28号10点和当前scf时间更接近
    
    print(currentdate8andtime(4*3600,480));
    // 校准时间为12点，那么应该返回20080728120000
    
    print(currentdate8andtime(6*3600,480));
    // 校准时间为14点，那么应该返回20080728140000
    
    print(currentdate8andtime(8*3600,480));
    // 校准时间为16点，那么应该返回20080728160000

NAME

    callstartdate8andtime


SYNOPSIS

    TString  callstartdate8andtime ()


DESCRIPTION

    取得呼叫开始日期和时间，同静态CCB变量callStartDate8Andtime等价，只不
    过是ASC格式，而静态CCB变量callStartDate8Andtime是BCD格式


ARGUMENTS

    无

RETURN

    ASC码类型的呼叫开始日期和时间


NAME

    answerdate8andtime


SYNOPSIS

    TString answerdate8andtime()


DESCRIPTION

    取得被叫应答日期和时间，同静态CCB变量AnswerDate8Andtime等价，只不过是
    ASC格式，而静态CCB变量AnswerDate8Andtime是BCD格式


ARGUMENTS

    无

RETURN

    ASC码类型的应答日期和时间


EXAMPLES

    s= answerdate8andtime ()
    可能的结果: '20040405162830'

NAME

    sysuptime


SYNOPSIS

    TString sysuptime()


DESCRIPTION

    取得本scf进程的运行时长


ARGUMENTS

    无

RETURN

    整数，秒为单位，本scf进程启动到现在的秒数


EXAMPLES

    iresult = sysuptime();
    print(itoa(iresult));

NAME

    gettimeofday


SYNOPSIS

    TString gettimeofday()


DESCRIPTION

    返回当前时间的秒数.微秒数


ARGUMENTS

    无

RETURN

    当前时间的秒数.微秒数


EXAMPLES

    var TString s = gettimeofday();

NAME

    telecommonth


SYNOPSIS

    TString  telecommonth ()


DESCRIPTION

    获得电信月，scfenv的一个参数TelecomMonthLastDay来确定电信月的最后一天
    ，取值在-27和27之间（0： 表示电信月最后一天就是实际月底。如果大于0：表
    示电信月最后一天提前到几号，例如19，表示5月19号电信月5月结束，5月20号
    开始为下一个电信月，6月。如果小于0：表示电信月最后一天顺延到下个月的几
    号，例如9，表示6月9号5月电信月才结束，6月10号开始才是电信月6月）


ARGUMENTS

    无

RETURN

     电信月格式的记录，格式:YYYYMM


EXAMPLES

    stmp = telecommonth();
    print(stmp);

NAME

    crstartdate8andtime, crstopdate8andtime, crtimestamp


SYNOPSIS

    
    TString  crstartdate8andtime()
    TString  crstopdate8andtime()
    TString  crtimestamp()


DESCRIPTION

    这几个函数只有当旧的解码方式InitialDP触发的业务逻辑中使用，当收到ACR事
    件的时候可以得到ACR参数中的几个时间变量的值。同对应的静态CCB变量等价，
    只不过返回的是ASC格式，而静态CCB变量是BCD格式


ARGUMENTS

    无

RETURN

    ASC码，YYYYMMDDHHmmSS格式的时间


EXAMPLES

    s1 = crstartdate8andtime();
    s2 = crstopdate8andtime();
    s3 = crtimestamp();
    执行结果可能是：s1: '20040405163207'; s2: '20040405164031'; s3: '20040405164030'
    

NAME

    crduration


SYNOPSIS

    TString  crduration()


DESCRIPTION

    这个函数只有当旧的解码方式InitialDP触发的业务逻辑中使用，当收到ACR事
    件的时候可以得到ACR参数中的duration变量的值。同对应的静态CCB变量等价，
    只不过返回的是ASC格式，而静态CCB变量是BCD格式


ARGUMENTS

    无

RETURN

    ASC码，HHHMMSST格式的通话时长（也有可能相邻两位的位置倒换HHMHSMTS）

    

EXAMPLES

    s= crduration ()
    执行结果可能是：s为'00000113'

NAME

    crspecificnumber


SYNOPSIS

    TString  crspecificnumber()


DESCRIPTION

    这个函数只有当旧的解码方式InitialDP触发的业务逻辑中使用，当收到ACR事
    件的时候可以得到ACR参数中的specificchargepartynumber变量的值。同对应的
    静态CCB变量等价，只不过返回的是ASC格式，而静态CCB变量是BCD格式


ARGUMENTS

    无

RETURN

    ASC码类型的ACR上报的specificchargepartynumber参数。固定22个字符，各个
    字符的含义根据业务逻辑的不同有不同的定义


EXAMPLES

    s= crspecificnumber ()
    执行结果，s可能是'0303131303036363738393'

NAME

    sqlxml


SYNOPSIS

    TString  sqlxml (TString arg1)


DESCRIPTION

    将简单的insert SQL语句输出为xml格式


ARGUMENTS

    arg1: 要输出的sql字符串


RETURN

    xml格式字符串，<nf>表示是否没有字段名，0表示有字段名


EXAMPLES

    assert(sqlxml('insert into acr_record(skey,callcost) values(1,100)')
     ==
    '<insert><table>acr_record</table><nf>0</nf><values><skey>1</skey><callcost>
    100</callcost>
    </values></insert>');

NAME

    sqltable, sqlclass


SYNOPSIS

    TString sqltable(TString sql)
    TString sqlclass(TString sql)


DESCRIPTION

    sqltable取出sql语句操作的表名。sqlclass取出sql语句操作的类型


ARGUMENTS

    sql: sql语句字符串


RETURN

    字符串，sql表名或者操作类型


EXAMPLES

    assert(sqltable('select * from acr_record') == 'ACR_RECORD');
    assert(sqlclass('select * from acr_record') == 'SELECT');

NAME

    sqlchname


SYNOPSIS

    TString  sqlchname (TString arg1)


DESCRIPTION

    根据当前时间，将sql语句中的acr_recode转换为acr_record_电信月格式


ARGUMENTS

    arg1:  sql字符串


RETURN

    acr_record_电信月格式


EXAMPLES

    s = sqlchname ('select * from acr_record')
    如果当前电信月为2004年4月，那么执行结果也许s为'select * from ACR_RECORD_
    200404'

NAME

    sqlgetstrprefix


SYNOPSIS

    TString  sqlgetstrprefix (TString arg1)


DESCRIPTION

    返回一个字符串的前缀组合，其结果一般用来构造SQL语句，用在in()中


ARGUMENTS

    arg1: 源字符串


RETURN

    字符串的前缀组合，每个都带有单引号，用逗号分开


EXAMPLES

    assert(sqlgetstrprefix('12345') ==
    '\2712345\27,\271234\27,\27123\27,\2712\27,\271\27'
    // \27 is ', eg, '12345','1234','123','12','1'

NAME

    getsqlerror


SYNOPSIS

    TString getsqlerror()


DESCRIPTION

    提供sql语句执行错误后的错误说明


ARGUMENTS

    无

RETURN

     sql语句执行错误后的错误说明.


NAME

    clearsqlbuffer


SYNOPSIS

    TInteger clearsqlbuffer()


DESCRIPTION

    清除execsql sib查询返回多条记录的结果集


ARGUMENTS

    无

RETURN

    清除execsql sib查询返回多条记录的结果集


NAME

    sqlstrencode, sqlstrdecode


SYNOPSIS

    TString sqlstrencode( TString s)
    TString sqlstrdecode( TString s)


DESCRIPTION

    对sql语句需要的字符串进行编解码，避免语句中的非法字符导致sql语句执行
    成功。一般来说构造sql语句之前要进行编码，对于SQL语句返回的结果要进行解
    码。主要是对回车竖线引号等字符的转换


ARGUMENTS

    s: 需要编码或者解码的字符串


RETURN

    编码或者解码之后的字符串


EXAMPLES

    assert(sqlstrencode('abc\ndef|123') == 'abc\\0Adef\\7C123');
    assert(sqlstrdecode('abc\\0Adef\\7C123') == 'abc\ndef|123');

NAME

    sqlfetch, sqlrun


SYNOPSIS

    TInteger sqlfetch(TSCPTable t, TString sql, TInteger maxRows=500, beginRow=
    0)
    TInteger sqlrun(TString sql, TInteger notSync=0)


DESCRIPTION

    执行一个SQL语句。一般来说select语句用sqlfetch，其它语句用sqlrun


ARGUMENTS

    t: 返回结果存放的TSCPTable句柄，之前必须new得

    sql: 要执行的sql语句

    maxRows: 最多返回的记录数量，通常可以是1-500之间的数值，缺省为500。如
    果这个数是0，那么将使用游标方式，第一次执行打开游标并返回第一条记录，
    后续执行取下一条，如果游标已经到尽头则关闭游标。如果这个参数是-1则强行
    关闭游标

    beginRow: 从第几条记录开始取。这个不是所有的数据库都支持。如果maxRows为
    0的游标方式，这个参数无效

    notSync: 是否要同步到SMP，0同步，1不同步，缺省为同步


RETURN

    如果返回大于等于0，表示执行成功，返回获得或者影响记录数。如果返回小于
    0，说明执行不成功。如果select, update, delete等语句没有符合条件的纪录
    ，会返回-39


EXAMPLES

    #progma c
    void main()
    {
       var TString sql;
       var TInteger i,j,k;
       var TSCPTable t;
    
       sql='drop table sqlfunctest';
       i=sqlrun(sql);
       if(i<0)
          print('drop failure');
    
       sql='create table sqlfunctest (a int, b char(10))';
       i=sqlrun(sql);
       if(i<0)
          print('create failure');
    
       sql='insert into sqlfunctest(a,b) values (100, \'12345\')';
       i=sqlrun(sql);
       if(i<0)
          print('insert failure');
       else
          print(sprintf('insert %d records',i));
    
       sql='insert into sqlfunctest(a,b) values (200, \'abcd3\')';
       i=sqlrun(sql);
       if(i<0)
          print('insert failure');
       else
          print(sprintf('insert %d records',i));
    
       t=new TSCPTable;
       sql='select * from sqlfunctest';
       i=sqlfetch(t, sql, 10);
       if(i<0)
          print('select failure');
       else
       {
          k=t.rowcount();
          print(sprintf('return %d, rowcount %d',i,k));
          for(j=1;j<=k;j=j+1)
          {
             print(sprintf('row %d: %s',j,t.rowtostr(j)));
          }
       }
       //SCF6.5(08.12)以上版本支持informix数据库对sqlfetch操作存储过程的
    调用及返回
       sqlrun('create procedure slpltest(i integer, j integer)
          returning integer, integer;
          return i+j, i-j;
          end procedure');
       sqlfetch(t, 'execute procedure slpltest(10, 20)', 10);
       assert(t.tostr()=='30|-10', t.tostr());
    
    }

NAME

    fgets


SYNOPSIS

    TString fgets(TString fileName, TInteger mode=0, TInteger flag=0)


DESCRIPTION

    从文件中一行一行的读，如果文件名和上一个fgets指示的文件一样，那么接着
    处理下一行，如果不一样，那么重新打开另一个文件。


ARGUMENTS

    fileName: 指示文件名

    mode: 打开文件模式，0只读，大于0读写，默认为0

    flag: 文件末尾返回指示，0导致抛出异常,大于0返回NULL，默认为0


RETURN

    读出的一行字符串，字符串包括行末的回车


EXAMPLES

    var TString fileName,line;
    fileName=...;
    line=fgets(fileName,0,1);
    while(line!='')
    line=fgets(fileName,0,1);
    print('file is end');

NAME

    fputs


SYNOPSIS

    TInteger fputs(TString fileName, TString line)


DESCRIPTION

    在文件结尾自动追加一行，自动加回车


ARGUMENTS

    fileName: 文件名

    line: 要写的字符串


RETURN

    返回整数0


EXAMPLES

    var TString sfile;
    sfile=sprintf('%s/log/test.txt',getenv('CINDIR'));
    assert(fputs(sfile,'hello world') == 0);

NAME

    fwrite


SYNOPSIS

    TInteger fwrite(TString fileName, TInteger pos, TString str, TInteger 
    length)


DESCRIPTION

    向文件中写入指定长度的字符串


ARGUMENTS

    fileName: 要写入的文件名

    pos: 写入文件的位置（-1表示从文件尾开始写）

    str: 要写入的字符串

    length: 是要写入的长度（如果长度小于等于0或者大于实际长度，则写实际长
    度）


RETURN

    返回实际写入的字节数


EXAMPLES

    assert(fwrite('file',0,'good',-2) == 4);

NAME

    fread


SYNOPSIS

    TString fread(TString fileName, TInteger pos, TInteger length)


DESCRIPTION

    从文件中读指定长度的字符串


ARGUMENTS

    fileName: 指定文件名

    pos: 指定位置

    length: 指定长度（如果length小于等于0，那么读出文件中所有字符串）


RETURN

    从文件中读出的字符串，注意fread最多只能读取512K大小，如果要读取的内容
    超过512K禁止使用该函数


EXAMPLES

    s = fread('file', 0, 2)

NAME

    fileexisted


SYNOPSIS

    TInteger fileexisted(TString path)


DESCRIPTION

    根据指定的路径判断文件是否存在


ARGUMENTS

    path: 文件的路径


RETURN

    如果path所表达的文件存在则返回1，否则返回0


NAME

    filetype


SYNOPSIS

    TInteger filetype(TString path)


DESCRIPTION

    根据指定的路径返回文件的类型


ARGUMENTS

    path: 文件的路径


RETURN

    如果文件不存在返回-1，否则返回
    1: 管道
    4: 目录
    8: 普通文件
    10: 符号连接


EXAMPLES

    var TString sfile;
    sfile=sprintf('%s/log/test.txt',getenv('CINDIR'));
    iresult = filetype(sfile);
    print('file type ' + itoa(iresult));

NAME

    filemode


SYNOPSIS

    TInteger filemode(TString path)


DESCRIPTION

    根据指定的路径返回文件的读写权限


ARGUMENTS

    path: 文件的路径


RETURN

    如果文件不存在返回-1，否则返回一个整数，这个整数只有后9位有意义，分别
    对应自身，同组以及其它用户的读、写、执行权限


NAME

    filesize


SYNOPSIS

    TInteger filesize(TString path)


DESCRIPTION

    根据指定的路径返回文件的大小


ARGUMENTS

    path: 文件的路径


RETURN

    如果文件不存在返回-1，否则返回字节为单位的整数


NAME

    filemtime


SYNOPSIS

    TString filemtime(TString path)


DESCRIPTION

    根据指定的路径返回文件的最后修改时间


ARGUMENTS

    path: 文件的路径


RETURN

    如果文件不存在返回空串，否则返回14字节的字符串形式的最后修改时间，格
    式为YYYYMMDDHHmmSS


NAME

    createdirectory


SYNOPSIS

    TInteger createdirectory(TString path)


DESCRIPTION

    根据指定的路径创建目录，如果这个路径已经完全存在，直接返回成功。如果
    这个路径上的某个节点不存在，那么自动创建


ARGUMENTS

    path: 文件的路径


RETURN

    根据路径创建一个目录，成功返回1，失败返回0


NAME

    listdirectory


SYNOPSIS

    TString[] listdirectory(TString path, TInteger start=0, TInteger max=
    500)


DESCRIPTION

    根据指定的路径的目录，返回这个目录下的所有文件名


ARGUMENTS

    path: 文件的路径

    start: 整数，开始位置，返回的时候将跳过这么多文件

    max: 整数，最大文件数目，从开始位置开始最多返回这么多文件名，其余不返
    回


RETURN

    字符串数组，如果目录不存在，返回length为0的数组


EXAMPLES

    // For example, there are 'aa' file and 'bb' file in the directory
    assert(listdirectory(path).tostr() == '.|..|aa|bb');
    assert(listdirectory(path,0,1).tostr() == '.');
    assert(listdirectory(path,0,3).tostr() == '.|..|aa');
    assert(listdirectory(path,2,2).tostr() == 'aa|bb');

NAME

    switchtranslate


SYNOPSIS

    TString switchtranslate(TString s, TString  defaultValue, ... )


DESCRIPTION

    多条件分支函数，完成匹配功能


ARGUMENTS

    s: 条件变量

    defaultValue: 缺省值，如果匹配不成功，返回缺省值

    ...: 此后的参数都成对出现，前者是匹配值，后者是匹配成功后返回的值


RETURN

    字符串


EXAMPLES

    s1 = 'ACR_RECORD';
    s = switchtranslate(s1,'null','ACR_RECORD','AA','ACR_RECORD_01','BB'
    );
    assert(s == 'AA');

NAME

    dosmatchpattern 


SYNOPSIS

    TInteger dosmatchpattern(TString source, TString pattern)


DESCRIPTION

    检查源字符串是否匹配dos模式，如果匹配返回1，不匹配返回0。是否匹配可以
    参照dos命令


ARGUMENTS

    arg1: 被检查的字符串,如果source中确实用到?,*,那么靠右斜杠转义，用到右
    斜杠也靠右斜杠转义

    arg2: 匹配的模式


RETURN

    


EXAMPLES

    dosmatchpattern("abcdefghijklmn","*gh*")  	返回1
    dosmatchpattern("abcdefghijklmn","gh*")    	返回0
    dosmatchpattern("abcdefghijklmn","???de*") 	返回1
    dosmatchpattern("abcdefghijklmn","??de*") 	返回0

NAME

    rematch


SYNOPSIS

    TInteger rematch(TString regexp, TString s)


DESCRIPTION

    正则表达式匹配，实现的是完全匹配，并不是子串匹配。


ARGUMENTS

    regexp: 正则表达式

    s: 要匹配的字符串


RETURN

    匹配的结果，返回1表示匹配成功，否则返回一个负数，其绝对值是匹配失败的
    位置。如果正则表达式不符合规范，抛出异常


EXAMPLES

    var TString str='abcdefghijklmnop';
    var TString regexp = '[a-z]{4,16}';
    var TInteger ret=rematch(regexp, str);
    assert(ret==1);

NAME

    xmlparse, hxmlparse, TXMLTree::TXMLTree


SYNOPSIS

    TInteger xmlparse(TString xmlStr)
    TXMLTree hxmlparse(TString xmlStr)
    TXMLTree::TXMLTree(TString xmlStr, TInteger parseType=0, TString wbxmlCfg=
    '')


DESCRIPTION

    解析参数中的xml串，形成xml树，固定返回handle为0，如果handle 0中已经存
    在XML树，则删除，用新树替换。


ARGUMENTS

    xmlStr: 需要解析的xml串，或者wbxml串（仅对TXMLTree::TXMLTree函数parseType为
    2的时候）

    parseType: 解析的几种类型：
    0: 仅用于元素的内容没有被子元素分割的情况。否则，这个分割的片断会被合
    并为一个字符串
    1: 当元素的内容有被子元素分割的时候，使用这种解析类型，tostr的时候可
    以保证还原
    2: 被解析的字符串为wbxml（Wireless Binary XML）编码格式
    3: 被解析的字符串为JSON字符串

    wbxmlCfg: 当被解析的字符串是wbxml格式的时候，这个参数指示一个配置名称
    ，这个配置在xmlwoods中


RETURN

    xmlparse固定返回0，如果handle0中已经存在xml树，则删除用新树替换。hxmlparse和
    TXMLTree构造函数则返回新的handle，失败返回-1


EXAMPLES

    var TXMLTree x;
    x = hxmlparse('<a><b>AABBCC</b><b>22222</b><c>33333</c></a>');
    x = new TXMLTree('<a><b>AABBCC</b><b>22222</b><c>33333</c></a>');
    
    x = new TXMLTree('<a>aaa<b>bbb</b>AAA</a>');
    assert(x.tostr()=='<a>aaaAAA<b>bbb</b></a>'); // 'aaa',  'AAA' -> 'aaaAAA'
    
    x = new TXMLTree('<a>aaa<b>bbb</b>AAA</a>', 1);
    assert(x.tostr()=='<a>aaa<b>bbb</b>AAA</a>');
    
    /* For example the following is the WBXML tag configuration file
       <token>
          <tag>
             <item name="aaa" id="5"/>
             <item name="bbb" id="6"/>
             <item name="ccc" id="7"/>
          </tag>
       </token>
       The file name is wbxmltest
     */
    var TString s =
    '\01\01\03\00\45\03\31\31\31\00\46\03\32\32\32\00\01\47\03\33\33\33\
    00\01\01';
    x = new TXMLTree(s, 2, 'wbxmltest');
    assert(x.tostr() == '<aaa>111<bbb>222</bbb><ccc>333</ccc></aaa>');

NAME

    xml, hxml, TXMLTree::getvalue


SYNOPSIS

    TString xml(TString path, TString default)
    TString hxml(TXMLTree handle, TString path, TString default)
    TString TXMLtree::getvalue(TString path, TString default)


DESCRIPTION

    xml取得handle为0的XML树指定路径对应的xml元素的内容，hxml和TXMLTree::
    getvalue则取得指定TXMLTree对象的指定xml元素内容


ARGUMENTS

    handle: TXMLTree对象的handle

    path: 路径

    default: 没取到值时返回的默认值


RETURN

    取到的xml元素的内容，否则返回default


EXAMPLES

    var TXMLTree i = hxmlparse('<x cvd:attr1="hello">xxx<y>yyy</y></x>')
    ;
    s1 = hxml(i,'x/y','null');
    s2 = hxml(i,'x/z','null');
    s3 = hxml(i,'x/cvd:attr1','null');
    assert(s1 == 'yyy');
    assert(s2 == 'null');
    assert(s3 == 'hello');
    
    s1 = i.getvalue('x/y','null');
    s2 = i.getvalue('x/z','null');
    s3 = i.getvalue('x/cvd:attr1','null');
    assert(s1 == 'yyy');
    assert(s2 == 'null');
    assert(s3 == 'hello');

NAME

    xmlcc, hxmlcc, TXMLTree::childcount


SYNOPSIS

    TInteger xmlcc(TString path)
    TInteger hxmlcc(TXMLTree handle, TString path)
    TInteger TXMLtree::childcount(TString path)


DESCRIPTION

    xmlcc获取handle为0的XML树的指定路经的xml节点的直接子元素个数，hxmlcc和
    TXMLTree::childcount则可以指定TXMLTree对象


ARGUMENTS

    handle: TXMLTree对象的handle

    path: 路径


RETURN

    xml节点的直接孩子个数


EXAMPLES

    var TXMLTree i = hxmlparse('<x>xxx<y>yyy</y></x>');
    var TInteger j = hxmlcc (i, 'x');
    assert(j == 1);
    j = i.childcount('x');
    assert(j == 1);

NAME

    hxmlstr, TXMLTree::tostr, TXMLTree::wbxmlencode


SYNOPSIS

    TString hxmlstr(TXMLtree handle)
    TString TXMLTree::tostr(TInteger indent=-1)
    TString TXMLTree::wbxmlencode(TString wbxmlCfg)


DESCRIPTION

    将指定XML树转换为xml串返回，wbxmlencode是按照WBXML规范编码


ARGUMENTS

    handle: 要转换的XML树的handle

    indent: 是否重新排版，这个参数缺省为-1表示不排版，如果为0，则按照一定
    的规则将tag进行回车对齐缩进

    wbxmlCfg: wbxmlencode需要这个参数指明使用xmlwoods中配置的哪个配置文件
    


RETURN

    xml串


EXAMPLES

    var TXMLTree i = hxmlparse('<x>xxx<y>yyy</y></x>');
    s = hxmlstr(i);
    assert(s == '<x>xxx<y>yyy</y></x>');
    i = new TXMLTree('<x>xxx<y>yyy</y></x>');
    s = i.tostr();
    assert(s == '<x>xxx<y>yyy</y></x>');
    s = i.tostr(0)
    assert(s == '<x>xxx
      <y>yyy</y>
    </x>
    ');
    
    /* For example a WBXML tag configuration that the name is wbxmltest
       <token>
          <tag>
             <item name="aaa" id="5"/>
             <item name="bbb" id="6"/>
             <item name="ccc" id="7"/>
          </tag>
       </token>
     */
    x = new TXMLTree('<aaa>111<bbb>222</bbb><ccc>333</ccc></aaa>');
    assert(x.wbxmlencode('wbxmltest')
       == '\01\01\03\00\45\03111\00\46\03222\00\01\47\03333\00\01\01');

NAME

    hxmldup, TXMLTree::dup


SYNOPSIS

    TXMLtree hxmldup(TXMLTree i)
    TXMLTree TXMLtree::dup()


DESCRIPTION

    复制一个XML树 


ARGUMENTS

    i: 要复制的XML树的handle


RETURN

    成功返回新的XML树的handle，不成功返回-1


EXAMPLES

    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    j = hxmldup(i);

NAME

    hxmldupelement, TXMLTree::dupelement


SYNOPSIS

    TXMLTree hxmldupelement(TXMLTree handle, TString path)
    TXMLTree TXMLTree::dupelement(TString path)


DESCRIPTION

    将一个XML树的子树复制，形成一个新的XML树。


ARGUMENTS

    handle: 要复制的XML树

    path: 子树的路径


RETURN

    成功返回新XML树的handle，失败返回-1


EXAMPLES

    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    j = hxmldupelement (i,'x/y');
    s = hxmlstr(j);
    assert(s == '<y>yyy</y>');

NAME

    hxmldeleteelement


SYNOPSIS

    TInteger  hxmldeleteelement( TInteger i, TString arg1)


DESCRIPTION

    删除指定的XML树的子树。


ARGUMENTS

    i: 要删除子树的XML树的handle

    arg1: 子树的路径


RETURN

    成功返回0，失败返回-1


EXAMPLES

    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    hxmldeleteelement (i,'x/y');
    s = hxmlstr(i);
    assert(s == '<x>xxx</x>');

NAME

    hxmladdhead, TXMLTree::addhead, hxmladdtail, TXMLTree::addtail


SYNOPSIS

    TInteger hxmladdhead(TXMLTree i, TString path, TXMLTree j)
    TInteger TXMLTree::addhead(TString path, TXMLTree j)
    TInteger hxmladdtail(TXMLTree i, TString path, TXMLTree j)
    TInteger TXMLTree::addtail(TString path, TXMLTree j)


DESCRIPTION

    将一个XML树复制，并且作为一个子节点，加入到另一个XML树的指定子树。addhead加
    在所有子节点之前，addtail加在所有子节点之后


ARGUMENTS

    i: 目标XML树的handle

    path: 目标XML树的子树的路径

    j: 要复制的XML树的handle


RETURN

    成功返回0，失败返回-1


EXAMPLES

    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    j = hxmlparse('<a>aaa<b>bbb</b></a>');
    hxmladdhead (i,'x',j);
    s = hxmlstr(i);
    assert(s == '<x>xxx<a>aaa<b>bbb</b></a><y>yyy</y></x>');
    
    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    j = hxmlparse('<a>aaa<b>bbb</b></a>');
    hxmladdtail (i,'x',j);
    s = hxmlstr(i);
    assert(s == '<x>xxx<y>yyy</y><a>aaa<b>bbb</b></a></x>');

NAME

    hxmladdleft, TXMLTree::addleft, hxmladdright, TXMLTree::addright


SYNOPSIS

    TInteger hxmladdleft(TXMLTree i, TString path, TXMLTree j)
    TInteger TXMLTree::addleft(TString path, TXMLTree j)
    TInteger hxmladdright(TXMLTree i, TString path, TXMLTree j)
    TInteger TXMLTree::addright(TString path, TXMLtree j)


DESCRIPTION

    将一个XML树复制，并且作为一个兄弟节点，加入到另一个XML树的指定子树。
    addleft作为第一个兄节点加入，addright作为最后一个弟节点加入


ARGUMENTS

    i: 目标XML树的handle

    path: 目标XML树的子树的路径

    j: 要复制的XML树的handle


RETURN

    返回0，失败返回-1


EXAMPLES

    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    j = hxmlparse('<a>aaa<b>bbb</b></a>');
    hxmladdleft(i,'x/y',j);
    s = hxmlstr(i);
    assert(s == '<x>xxx<a>aaa<b>bbb</b></a><y>yyy</y></x>');
    
    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    j = hxmlparse('<a>aaa<b>bbb</b></a>');
    hxmladdright(i,'x/y',j);
    s = hxmlstr(i);
    assert(s == '<x>xxx<y>yyy</y><a>aaa<b>bbb</b></a></x>');

NAME

    hxmlchangeelement


SYNOPSIS

    TInteger hxmlchangeelement(TXMLTree i, TString path, TXMLTree j)


DESCRIPTION

    将一个XML树复制，并且作为新节点，替换掉另一个XML树的指定子树。


ARGUMENTS

    i: 目标XML树的handle

    path: 要替换的子树的路径

    j: 要复制的XML树的handle


RETURN

    返回0，失败返回-1


EXAMPLES

    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    j = hxmlparse('<a>aaa<b>bbb</b></a>');
    hxmlchangeelement(i, 'x/y', j);
    s = hxmlstr(i);
    assert(s == '<x>xxx<a>aaa<b>bbb</b></a></x>');

NAME

    hxmlelemname, TXMLTree::getelemname


SYNOPSIS

    TString hxmlelemname(TInteger handle, TString path, TInteger n)
    TString TXMLTree::getelemname(TString path, TInteger n)


DESCRIPTION

    获取XML树的指定子树的 第i个子元素的名字


ARGUMENTS

    handle: XML树的handle。

    path: 子树的路径

    n: 第几个子元素，从0开始


RETURN

    返回元素的名字，失败返回''


EXAMPLES

    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    s = hxmlelemname(i, 'x', 0);
    assert(s == 'y');

NAME

    hxmlccbytag, TXMLTree::childcountbytag


SYNOPSIS

    TInteger hxmlccbytag(TXMLTree handle, TString path)
    TInteger TXMLtree::childcountbytag(TString path)


DESCRIPTION

    求得指定XML树的某个子树的根tag的在同一级别的相同tag的数量


ARGUMENTS

    handle: XML树handle。

    path: tag所在子树的路径


RETURN

    


EXAMPLES

    i = hxmlparse('<a><b>b1</b><c>c1</c><d>d1</d><b>b2<c>cc1</c></b><c>c2<
    /c></a>') ;
    j = hxmlccbytag(i, 'a/b');
    assert(j == 2);

NAME

    hxmlchangecontent, TXMLTree::changecontent


SYNOPSIS

    TInteger hxmlchangecontent(TXMLtree handle, TString path, TString value)
    
    TInteger TXMLTree::changecontent(TString path, TString value)


DESCRIPTION

    改变XML树的指定子元素的内容。


ARGUMENTS

    handle: XML树的handle

    path: XML树的子树的路径

    value: 替换的新的内容


RETURN

    成功返回0，失败返回-1


EXAMPLES

    i = hxmlparse('<x>xxx<y>yyy</y></x>');
    hxmlchangecontent(i,'x/y','test');
    s = hxmlstr(i);
    assert(s == '<x>xxx<y>test</y></x>');

NAME

    hxmlsetattr


SYNOPSIS

    TInteger hxmlsetattr(TInteger i, TString path, TString attrName, TString 
    attrValue)


DESCRIPTION

    设置一个XML树的某个元素的某个属性


ARGUMENTS

    i: XML树的handle

    path: 要设置的元素的路径

    attrName: 要设置的属性名字

    attrValue: 要设置的属性值


RETURN

    成功返回0，失败返回-1


EXAMPLES

    i = hxmlparse('<x a="1">123</x>');
    hxmlsetattr(i, 'x', 'a', '2');
    s = hxmlstr(i);
    assert(s == '<x a="2">123</x>');

NAME

    hxmlgetattr, TXMLTree::getattrvalue


SYNOPSIS

    TString hxmlgetattr(TMXLTree handle, TString path, TString default)
    
    TString TXMLTree::getattrvalue(TString path, TString default)


DESCRIPTION

    取得xml树中的某个路径下属性的值


ARGUMENTS

    handle: TXMLTree对象的handle

    path: xml的路径

    default: 缺省值


RETURN

    这棵树对应路径下的属性值


EXAMPLES

    i = hxmlparse('<x>xxx<y cvd:z="aaa">yyy</y></x>');
    s = hxmlgetattr(i, 'x/y/z', '');
    s1 = i.getattrvalue('x/y/cvd:z','null');
    s2 = i.getattrvalue('x/y/z','null');
    assert(s == 'aaa');
    assert(s1 == 'aaa');
    assert(s2 == 'aaa');

NAME

    hxmlelement


SYNOPSIS

    TInteger hxmlelement(TString tag, TString content)


DESCRIPTION

    简单构造一个单元素的XML树，形成一个XML树，返回handle。


ARGUMENTS

    tag: 表示元素的tag的字符串

    content: 表示元素内容的字符串


RETURN

    新的XML树的handle


EXAMPLES

    i = hxmlelement('aaa', 'bbb');
    s = hxmlstr(i);
    assert(s == '<aaa>bbb</aaa>');

NAME

    hxmlelem, hxmlattr


SYNOPSIS

    TInteger hxmlelem(TString tagname , ... )
    TInteger hxmlattr(TString attrname, TString attrvalue)


DESCRIPTION

    这两个函数用来构造XML树，不能单独使用，需要配合使用


ARGUMENTS

    tagname: 构造xml元素的tag

    attrname: 构造属性的名称

    attrvalue: 构造属性的值

    ...: 构造xml元素的内容字符串，或者子元素的handle，或者属性的handle


RETURN

    xml元素或者属性的handle


EXAMPLES

    i = hxmlelem('authorize',
           hxmlelem('accountnumber',
              '11111111111',
              hxmlattr('password', '123')
           ),
           hxmlelem('pin', '1111')
        );
    s = hxmlstr(i);
    assert(s == '<authorize><accountnumber password="123">11111111111</accountnumber>
    
    <pin>1111</pin></authorize>', s);
    delete(i);

NAME

    hxmldupwoods


SYNOPSIS

    TXMLTree hxmldupwoods(TString path)


DESCRIPTION

    按照参数所指的路径，从xmlwoods中选择一棵树，原样复制一个新的XML树


ARGUMENTS

    path: xmlwoods的路径


RETURN

    成功返回新的XML树的handle，失败返回-1


EXAMPLES

    var TXMLTree x = hxmldupwoods('smp');

NAME

    xmlwoods, xmlwoodsassign, TXMLTree::query


SYNOPSIS

    TString xmlwoods(TString path, TString defaultValue, TInteger useCache=
    1)
    TString xmlwoodsaggign(TString path, TString var1, TString subPath1,
     ...)
    TString TXMLtree::query(TString path, TString var1, TString subPath1,
     ...)


DESCRIPTION

    获取xmlwoods配置中的值。可以直接根据xml路径得到某个元素的值，也可以在
    路径中附带查询条件。xmlwoods函数直接返回得到的值，而xmlwoodsassign可以
    在取到一个节点之后，根据子路径再次操作这个节点将返回值填写到具体变量中
    。TXMLTree::query则直接从TXMLTree对象中取值，参数及返回值方式同xmlwoodsassign

    

ARGUMENTS

    path: 路径，其中可以带查询条件，查询条件在路径中用[]给出。查询条件基
    本上是这样的产生式：
    查询条件表达式: 条件项   '||' 条件项 
    条件项: 条件因子  '&&' 条件因子
    条件因子:  '@'属性名 OP 条件值 | '(' 表达式  ')'
    OP: '=' | '>' | '<' | '>=' | '<=' | '!='
    带查询条件的路径举例：
    PPC:service/config[0]/menu[@level=1 && @key=2]
    PPC:service/config[0]/menu[@level=1 ]/submenu[(@level=1 || @level=2) 
    && @key=3]

    defaultValue: 缺省值，如果路径不存在，返回缺省值

    useCache: 是否启用cache，默认为启用。参数值为0表示本次查询不启用cache，
    通常用于查询条件和用户号码相关的场景

    var1,var2...: 被赋值的字符串变量

    subPath1,subPath2...: 要赋值的子元素的子路经


RETURN

    对于xmlwoods，返回path对应的元素的值。对于xmlwoodsassign或者TXMLTree:
    :query，返回根据查询到的元素的子路经成功赋值的变量的个数


EXAMPLES

    /*
    For example the xml file: $CINDIR/xmlwoods/PPC
    <service>
    <config>
      <menu level="1"  key="1">
        <submenu level="1" key="1" desc="PROMPT_CCARD1" msgid="1111" func=
    "PCCARD1"/>
      </menu>
      <menu level="1"  key="2">
        <submenu level="1" key="2" desc="PROMPT_CCARD2" msgid="1212" func=
    "PCCARD2"/>
      </menu>
      <menu level="1"  key="1">
        <submenu level="1" key="4" desc="PROMPT_CCARD1" msgid="1114" func=
    "PCCARD1"/>
      </menu>
      <menu level="1"  key="2">
        <submenu level="1" key="3" desc="PROMPT_CCARD2" msgid="1213" func=
    "PCCARD2"/>
      </menu>
      <menu level="2"  key="1">
        <submenu level="2" key="1" desc="PROMPT_CCARD5" msgid="2121" func=
    "PCCARD5"/>
      </menu>
      <menu level="2"  key="2">
        <submenu level="2" key="2" desc="PROMPT_CCARD6" msgid="2222" func=
    "PCCARD6"/>
      </menu>
    </config>
    </service>
    */
    var TString query, msgid, func, desc;
    query = 'PPC:service/config[0]/menu[@level=1&&@key=2]/submenu[@level=
    1&&@key=3]';
    var TInteger n = xmlwoodsassign(query
       , msgid, 'msgid' // submenu/msgid -> var msgid
       , func, 'func'  // submenu/func -> var func
       , desc,'desc' // submenu/desc -> var desc
       );
    assert(n == 3);
    assert(msgid == '1213');
    assert(func == 'PCCARD2');
    assert(desc == 'PROMPT_CCARD2');
    
    var TXMLTree x = new TXMLTree('<a>
    <b a="1" b="a"/>
    <b a="2" b="b"/>
    <b a="3" b="c"/>
    <b a="4" b="d"/>
    </a>');
    var TString s1, s2;
    x.query('a/b[@a=1]', s1, 'b', s2, 'a');
    assert(s1 == 'a');
    assert(s2 == '1');

NAME

    xmlwoodscc


SYNOPSIS

    TString  xmlwoodscc(TString path, TString tag='')


DESCRIPTION

    获取xmlwoods配置中某个子元素下某个tag的孩子的个数


ARGUMENTS

    path: 路径

    tag: 某个tag的名字，如果为空，则获取所有孩子的个数


RETURN

    整数，孩子的个数


EXAMPLES

    var TInteger irule = xmlwoodscc('diameterconfig:config/rule2');
    assert(irule == 5);
    
    var TInteger ichargenum = xmlwoodscc('diameterconfig:config/rule2','
    chargenum');
    assert(ichargenum == 3);
    

NAME

    xmltextencode, xmltextdecode, vxmltextencode, vxmltextdecode


SYNOPSIS

    TString xmltextencode(TString arg1)
    TString xmltextdecode(TString arg1)
    TString vxmltextencode(TString arg1)
    TString vxmltextdecode(TString arg1)


DESCRIPTION

    encode是将一个字符串中的一些XML内容认为非法字符转换，例如小于号转换为
    '&lt;', 符号大于号转换为'&gt;'，而decode则反之。vxml某些场合要求比xml更
    加严格一些，所以针对vmxl的内容除了xml的要求之外对空格回车换行等字符也
    做了替换


ARGUMENTS

    arg1: 要转换的字符串


RETURN

    转换后的字符串


EXAMPLES

    s = xmltextencode('<a/b[0]>');
    assert(s == '&lt;a/b[0]&gt;');

NAME

    tcpsend


SYNOPSIS

    TInteger tcpsend(TString logicName, TInteger linkID, TString s, TInteger 
    length)


DESCRIPTION

    向指定的逻辑名和linkID发送TCP消息。这个函数用于长连接，Client/Server都
    可以用


ARGUMENTS

    logicName: logicName，在config.server.* 或config.client.*中配置

    linkID: linkID

    s: 发送字符串

    length: 发送的长度，如果为0，则最后加0发送，如果超过s的长度，那么按照
    s的实际长度发送


RETURN

    0表示成功，负数表示失败


NAME

    udpsend, udpsendbyname


SYNOPSIS

    TInteger udpsend(TString host, TInteger port, TString s)
    TInteger  udpsendbyname(TString host, TInteger port, TString s, TString 
    logicName)


DESCRIPTION

    udpsend发送UDP消息，发送端的端口不能指定，需要配置config.udp.*。udpsendbyname可
    以指定端口


ARGUMENTS

    host: 主机名

    port: 端口号

    s: 要发送的字符串

    logicName: 配置udp端口的logicName，在config.server.*配置，协议名配置
    为udp


RETURN

    0表示成功，负数表示失败


NAME

    tcpconnectsend


SYNOPSIS

    TInteger tcpconnectsend(TString logicName, TString host, TInteger port,
     TString s, TInteger length)


DESCRIPTION

    通过logicName指定的socket，向指定的主机发送信息。发送消息前socket会连
    接到指定主机


ARGUMENTS

    logicName: logicName，在config.client.*中配置

    host: 新的主机名或者ip地址，空串表示ip地址和端口号不变

    port: 新的端口号

    s: 发送字符串

    length: 发送的长度，如果为0，则最后加0发送，如果超过s的长度，那么按照
    s的实际长度发送


RETURN

    返回值大于等于0表示成功，是新建的link id，返回负数表示失败


NAME

    tcpdeletelink


SYNOPSIS

    TInteger tcpdeletelink(TString logicName, TInteger linkID, TString key)
    


DESCRIPTION

    删除socket连接


ARGUMENTS

    logicName: logicName，在config.server.*或cofnig.client.*中配置

    linkID: linkID

    key: link关联的key, 如果s为空串，那么不关心关联的key


RETURN

     返回0表示成功


NAME

    tcpalivename


SYNOPSIS

    TInteger tcpalivename(TString logicName1, TString logicName2)


DESCRIPTION

    从两个logicName中选择一个有好用的连接的logicName返回


ARGUMENTS

    logicName1: logicName

    logicName2: logicName


RETURN

    连接好的logicName


NAME

    tcpaliveinesclient


SYNOPSIS

    TString tcpaliveinesclient(TString name)


DESCRIPTION

    针对text0ines协议，根据给出的server获得一个可用的client的名字，如果多
    个可用，那么轮流返回


ARGUMENTS

    name: server的logicName


RETURN

    可用的client的注册名


NAME

    tcpalivelink


SYNOPSIS

    TInteger tcpalivelink(TString logicName)


DESCRIPTION

    根据参数指定的连接名选择一个已经连接的link


ARGUMENTS

    logicName: logicName


RETURN

    连接好的link的linkID


NAME

    tcpconnect


SYNOPSIS

    TInteger tcpconnect(TString logicName, TString host, TInteger port)

    

DESCRIPTION

    连接到主机


ARGUMENTS

    logicName: logicName,在config.client.*配置

    host: 目的主机名

    port: 目的端口号


RETURN

    大于等于0表示linkID，小于0表示失败


NAME

    tcpprotocoltype


SYNOPSIS

    TString tcpprotocoltype(TString logicName)


DESCRIPTION

    得到连接的协议类型


ARGUMENTS

    logicName: logicName


RETURN

    使用的协议类型


NAME

    tcpsetlinkstate


SYNOPSIS

    TString tcpsetlinkstate(TString name, TInteger link, TInteger state)
    


DESCRIPTION

    设置某个socket连接的状态


ARGUMENTS

    name: logicName

    link: link的ID

    state: 要设置的状态:
    0: CLOSE
    1: OPEN
    2: CONNECTING
    3: PREPARING
    4: SHUTDOWN


RETURN

    


NAME

    getserviceid


SYNOPSIS

    TInteger getserviceid()


DESCRIPTION

    得到这个业务逻辑加载的内部ID


ARGUMENTS

    无

RETURN

    整数


EXAMPLES

    var TInteger isvcid;
    isvcid = getserviceid();
    assert(isvcid == 1001);
    //1001为执行业务的ID

NAME

    getscfid, getglobalscfid


SYNOPSIS

    TInteger getscfid()
    TInteger getglobalscfid()


DESCRIPTION

    得到这个SCF进程的内部ID以及全局ID，getscfid返回的是一个机器内部配置scf的
    ID，这个ID不同机器有可能是重复的，config.globalscfid可以根据整个系统多
    个机器环境为每个scf配置一个全局的ID，getglobalscfid就可以得到这个全局
    ID


ARGUMENTS

    无

RETURN

    整数


NAME

    getetccorrelationid, getetcscfid


SYNOPSIS

    TString getetccorrelationid()
    TString getetcscfid()


DESCRIPTION

    等同于旧语法中的静态变量EtcCorrelationID和EtcSCFID


ARGUMENTS

    无

RETURN

    字符串


NAME

    getfsmid, getparentfsmid


SYNOPSIS

    TInteger getfsmid()
    TInteger getparentfsmid()


DESCRIPTION

    一个SLPL程序的一次执行就会导致一个自动机，这两个函数得到的就是自动机
    的ID，getfsmid得到的是自身所在的自动机的ID，getparentfsmid得到的是调用
    这个自动机的自动机的ID


ARGUMENTS

    无

RETURN

    整数


NAME

    getfsmidstr


SYNOPSIS

    TString getfsmidstr()


DESCRIPTION

    新语法中禁用myInstanceID,getfsmidstr()函数返回与老语法中myInstanceID相
    同的内容.


ARGUMENTS

    无

RETURN

    字符串包含进程号和自动机号


EXAMPLES

    var TInteger fsmid;
    var TString fsmidstr;
    fsmid = getfsmid(); // may be 1, fsmid
    fsmidstr = getfsmidstr(); // may be '001', '00' is scf ID

NAME

    nice


SYNOPSIS

    TInteger nice(TInteger priority)


DESCRIPTION

    设置业务运行的优先级。当多个业务逻辑实例同时运行的时候，这个函数会通
    过优先级的设置使得某个业务分得更多的执行机会，这个函数一般用于一些要求
    快速执行的涉及大量数据处理的业务逻辑，例如话单转换，扣月租费等。


ARGUMENTS

    priority: 优先数，这个数越大，业务逻辑执行的优先级越高，可以设置为1-
    1000之间的数


RETURN

    0


NAME

    setmaxobjects


SYNOPSIS

    TInteger setmaxobjects(TInteger maxobjects)


DESCRIPTION

    设置本自动机内部对象池的大小，如果不调用这个函数，缺省设置是200个，也
    就是说自动机最多同时有200个对象存在。如果某些应用有大于200个对象的要求
    ，可以在程序的开始调用这个函数扩大


ARGUMENTS

    maxobjects: 200-10000之间的整数有效


RETURN

    0


NAME

    exit


SYNOPSIS

    TInteger exit()


DESCRIPTION

    强制退出整个业务逻辑。不管在哪一层函数调用或者是事件处理程序中，只要
    调用exit()，那么就会强制结束整个业务逻辑的执行，删除自动机


ARGUMENTS

    无

RETURN

    0


NAME

    setgmpstart


SYNOPSIS

    TInteger setgmpstart()


DESCRIPTION

    将本自动机设置为模版方式消息解析机制


ARGUMENTS

    无

RETURN

    0


NAME

    setprimitivestart


SYNOPSIS

    TInteger setprimitivestart()


DESCRIPTION

    将本业务逻辑设置为原子操作执行。整个业务逻辑从开始到结束独占scf进程资
    源


ARGUMENTS

    无

RETURN

    0


NAME

    sleep


SYNOPSIS

    TInteger sleep(TInteger n)


DESCRIPTION

    相当于delay sib, 业务逻辑睡眠n秒


ARGUMENTS

    n: 整数，秒数


RETURN

    0


NAME

    repeat


SYNOPSIS

    TInteger repeat(initialAction, TInteger conditialExp, actions ...)


DESCRIPTION

    重复执行一些动作，对于业务逻辑中一些简单的循环，用这个语句代替可以简
    化逻辑以及提高效率。为了防止死循环，程序中作了限制，最多执行10000次循
    环就会抛出异常


ARGUMENTS

    initialAction: 可以是任意类型的一个表达式，一般来说应该是一个赋值语句
    ，只被调用一次

    conditionExp: 整数类型的表达式，每次循环判断一次，当这个表达式为0的时
    候循环结束

    actions: 可以是任意类型的表达式或者赋值语句，一般含有一个能够改变循环
    条件因子的语句，可以有任意多个


RETURN

    0


EXAMPLES

    // To print: 0 0 2 2000 4 4000...
    var TInteger i;
    repeat(i=0, i<100, print(itoa(i)), print(itoa(i*1000)), i=i+2);
    
    // To calculate the sum of the second column of the table
    var TSCPTable t;
    var TInteger i, sum=0, rowCount;
    ...
    rowCount = t.rowcount();
    repeat(i=1, i<=rowCount, sum+=atoi(t[i++][2]));

NAME

    limit


SYNOPSIS

    TInteger limit(TString key, TInteger number, TInteger rateLimit)


DESCRIPTION

    对业务逻辑的执行进行限制，分为数量限制和速率限制两种，结果可能是通过
    或者不通过，针对不同的情况可以做不同的后续操作


ARGUMENTS

    key: 字符串，同一个限制必须使用同样的key，对于使用相同的key调用的limit总
    体上控制数量或者速率

    number: 如果是数量限制，那么这个参数是同时存在的业务逻辑执行示例的个
    数。如果是速率限制，那么是每秒钟允许执行的次数

    rateLimit: 0表示数量限制，1表示速率限制，缺省为0


RETURN

    返回大于或者等于0表示通过，返回小于0表示不通过


EXAMPLES

    #progma c
    void main()
    {
       var TInteger i;
       i=limit('123',10);
       print(itoa(i));
       if(i>=0)
       {
          print('limit passed');
          sleep(10);
       }
       else
       {
          print('limit not pass');
       }
    }

NAME

    queue


SYNOPSIS

    TInteger queue(TString key, TInteger maxServer, TInteger maxQueue, TInteger 
    waitTime)


DESCRIPTION

    对业务逻辑的执行进行排队


ARGUMENTS

    key: 字符串，同一个排队必须使用同样的key

    maxServer: 最大的服务者个数，之后这么多可以接受服务，其它的必须首先排
    队。该值在0-100之间的数。

    maxQueue: 能够排入队列的最大个数，该值在0-100之间的数。

    waitTime: 在队列中的最大等待时间


RETURN

    0: 得到服务，1: 排入队列，2: 队列满


EXAMPLES

    #progma c
    void work()
    {
       print('begin work');
       sleep(20);
       print('end work');
    }
    
    void main()
    {
       var TInteger i;
       i=queue('123',2,5,50);
       if(i==0)  // got the resource
       {
          print('queue pass, to work');
          work();
          return;
       }
       if(i==2) // queue is full
       {
          print('queue full, exit');
          return;
       }
       print('in queue');
       sleep(200);  // wait in queue
    
       on(queueResourceFree)  // some resource is free
       {
          print('resource free');
          work();
          return;
       }
       on(queueTimerExpire) // timeout
       {
          print('time out, exit');
          return;
       }
    }

NAME

    queuefree


SYNOPSIS

    TInteger queuefree(TString key)


DESCRIPTION

    释放指定的queue资源


ARGUMENTS

    key: 资源名称


RETURN

    


NAME

    promptwarning


SYNOPSIS

    TInteger promptwarning(TString s)


DESCRIPTION

    业务逻辑要求控制台确认流程是否继续


ARGUMENTS

    s: 给控制台的提示信息，字符串类型


RETURN

    如果用户输入yes，则这个函数返回1，否则抛出异常，如果没有异常处理，那
    么业务逻辑会被终止


NAME

    traceon


SYNOPSIS

    TInteger traceon()


DESCRIPTION

    将本自动机置为被trace状态，此后的业务执行会显示trace信息


ARGUMENTS

    无

RETURN

    0


NAME

    istraced


SYNOPSIS

    TInteger istraced()


DESCRIPTION

    得知本自动机是否被trace


ARGUMENTS

    无

RETURN

    1：已经被trace，0：没有被trace


NAME

    st, stset


SYNOPSIS

    TInteger st(TString name, TInteger value)
    TInteger stset(TString name, TInteger value)


DESCRIPTION

    统计函数，用来生成针对某个名称的统计信息，st用来累加统计值，stset用来
    设置统计值


ARGUMENTS

    name: 统计的名称

    value: 对st来说，这是统计的增长值。对stset来说，这是统计修改值


RETURN

    0


EXAMPLES

    st('O_Abandon',1)

NAME

    print, printbin


SYNOPSIS

    TString print(TString s)
    TString printbin(TString s)


DESCRIPTION

    输出信息到屏幕辅助业务调试，如果字符串都是可打印字符可以使用print输出
    ，如果是不可打印的字符则可以使用pringbin输出。这两个输出都受display -
    all开关的控制。注意：如果在print及printbin函数的参数中使用函数，比如print(
    func(aa))，当display -all没有打开，那么这个func就不会执行到。


ARGUMENTS

    s: 要输出的内容


RETURN

    空字符串


NAME

    tracetext, tracebin


SYNOPSIS

    TInteger tracetext(TString s)
    TInteger tracebin(TString s)


DESCRIPTION

    使用UDP协议输出信息到监控终端，如果字符串都是可打印字符可以使用tracetext输
    出，如果是不可打印的字符则可以使用tracebin输出。这两个输出都受display 
    -all开关的控制


ARGUMENTS

    s: 要输出的内容


RETURN

    0


NAME

    alarm, alarminfo, log


SYNOPSIS

    TInteger alarm(TString s)
    TInteger alarminfo(TInteger id, TInteger level, TString s)
    TInteger log(TString s)


DESCRIPTION

    将告警信息输出到终端屏幕以及SCF.INFO.*文件。对alarm来说，错误号为11000。
    而alarminfo可以自己定义错误号以及级别。log函数则固定错误号10708，并且
    附加了一些自动机的信息，并且使用display -servicelog|-noservicelog可以
    控制


ARGUMENTS

    id: 自定义的errorid, errorid 为 90000 到 99999

    level: 自定义的errorLevel，errorLevel为0到6

    s: 要输出的信息


RETURN

    0


EXAMPLES

    alarminfo(90000, 1, 'connect fail');

NAME

    debuginfo


SYNOPSIS

    TInteger debuginfo(TString s)


DESCRIPTION

    将调试信息输出到$CINDIR/etc/xxx.debuginfo，xxx是业务逻辑的文件名。只
    有pro 加上-w选项编译的时候，这个函数才起作用


ARGUMENTS

    s: 要输出的信息，当这个字符串是message:xxx xxx xxx这样的格式的时候，
    会有一个特殊的效果，除了在.debuginfo记录这个信息之外，还可以在自动机结
    束的时候，在标准输出输出一个msc图


RETURN

    0


EXAMPLES

    如果业务逻辑执行过程中执行了如下的语句：
       debuginfo('message: SSP SCP IDP');
       debuginfo('message: SCP INES invokeservice');
       debuginfo('message: INES SCP result');
       debuginfo('message: SCP SSP ETC');
    那么，自动机结束的时候，除了在.debuginfo文件中记录：
    message: SSP SCP IDP
    message: SCP INES invokeservice
    message: INES SCP result
    message: SCP SSP ETC
    之外，还会在标准输出显示这样的一个MSC图:
       SSP                       SCP                      INES
        |                         |                         |
        |           IDP           |                         |
        |------------------------>|                         |
        |                         |      invokeservice      |
        |                         |------------------------>|
        |                         |         result          |
        |                         |<------------------------|
        |           ETC           |                         |
        |<------------------------|                         |

NAME

    logserver


SYNOPSIS

    TInteger logserver(TString s)


DESCRIPTION

    将log信息追加到自动机内部一个字符串中，每次追加中加会以ESC分割，自动
    机结束之后，会将这个总的信息发送到log server


ARGUMENTS

    s: 要追加的log信息


RETURN

    0


NAME

    term


SYNOPSIS

    TInteger term(TString s)


DESCRIPTION

    信息输出到inaccess终端


ARGUMENTS

    s: 要输出的信息


RETURN

    


NAME

    assert


SYNOPSIS

    TInteger assert(TInteger boolExpression, TString userInfo='')


DESCRIPTION

    断言一个布尔表达式为真。如果布尔表达式为真，此函数没有什么动作，否则
    报告10949错误，并显示userInfo所提供的字符串


ARGUMENTS

    boolExpression: 要断言的布尔表达式

    userInfo: 断言不成功的时候显示的信息


RETURN

    0


NAME

    getlastsibname


SYNOPSIS

    TString getlastsibname()


DESCRIPTION

    获得上一次执行的sib名称，通常用于记录错误日志


ARGUMENTS

    无

RETURN

    


NAME

    shareinfo, getsharedinfo


SYNOPSIS

    TInteger shareinfo(TString info)
    TString getsharedinfo(TString fsmKey, TString keyName='')


DESCRIPTION

    shareinfo可以共享一些信息给别的自动机。getsharedinfo则获取别的自动机
    共享的信息


ARGUMENTS

    info: 要共享的信息，一个字符串，可以根据需要任意构造

    fsmKey: 自动机的Key，共享信息的自动机通过setkey函数设置，如果这个key表
    达的自动机不存在，getsharedinfo会抛出异常

    keyName: Key的名字，即setkey函数的设置Key的时候所使用的名字，缺省为空
    


RETURN

    shareinfo返回整数0，getsharedinfo返回共享的信息


EXAMPLES

    // one slpl program
    void main()
    {
       setkey('AAA', '12345');
       shareinfo('abcde');
       sleep(100);
    }
    // the other slpl program
    void main()
    {
       assert(getsharedinfo('12345', 'AAA')=='abcde');
    }

NAME

    setkey, deletekey, searchkey


SYNOPSIS

    TInteger setkey(TString keyName,TString keyValue)
    TInteger deletekey(TString keyName,TString keyValue)
    TString searchkey(TString keyName,TString keyValue)


DESCRIPTION

    setkey、clearkey 和 searchekey是为了解决自动机通过correlationKey方式
    关联，多种业务混合可能出现冲突情况。
    key的设置和清除规则：
    1. key是一个key-pair,由keyName、keyValue组成，一个key-pair是全局(SCF单
    个进程)唯一。keyValue不能为空，调用setkey成功返回1，失败返回0，失败情
    况可能是keyName、keyValue格式问题或key-pair重复导致，没有区分返回码，
    统一返回0。
    2. 一个自动机可以设置多个key-pair, keyName相同允许设置多个keyValue。
    
    3. 删除key的方法，指定keyName和keyValue确定删除一个key-pair。只指定keyName,
     keyValue为''，删除该自动机所有keyName相同的key.
    4. key-pair只能由设置的自动机删除。
    5. searchKey 输入keyPair ，返回设置该key的自动机号字符串,key没有设置
    返回''.字符串格式同myinstanceID(scfID+fsmInstanceID)
    6. 所有自动机设置的key，当自动机退出时自动清除。


ARGUMENTS

    keyName: key的名字，可以为空，表示设置缺省key

    keyValue: key的值


RETURN

    对于setkey和deletekey，成功返回1，失败返回0。对于searchkey，返回字符
    串格式的自动机号


EXAMPLES

    #progma c
    void main()
    {
       var TString key1, key2, key3;
       var TString value1, value2, value3, value4;
       var TInteger re;
       var TString s;
    
       print(sprintf('myinstanceid :%s',myinstanceid));
       key1='AAA';
       key2='BBB';
       key3='CCC';
       value1='a';
       value2='b';
       value3='c';
       value4='d';
       re=setkey(key1,value1);
       print(sprintf('set value1 re:%d',re));
       re=setkey(key1,value1);
       print(sprintf('set value1 re:%d',re));
       re=setkey(key2,value2);
       re=setkey(key3,value3);
       re=setkey(key1,value4);
       s=searchkey(key1,value1);
       print(sprintf('search value1 re:%s',s));
       s=searchkey(key1,value4);
       print(sprintf('search value1 re:%s',s));
       re=deletekey(key1,value4);
       s=searchkey(key1,value4);
       print(sprintf('search value4 re:%s',s));
       sleep(30);
    }

NAME

    isfsmusing


SYNOPSIS

    TInteger isfsmusing(TString fsmid)


DESCRIPTION

    判断一个自动机ID是不是正在使用


ARGUMENTS

    fsmid: 自动机ID，3-6个字节，前两个字节是scf进程id，后1-4个字节是自动
    机号


RETURN

    如果在用返回1，否则返回0


EXAMPLES

    var TInteger fsmid = getfsmid();
    var TInteger fsmpid = getparentfsmid();
    var TString  fsmnum = getfsmidstr();  //本例返回'007'
    var TInteger useId = isfsmusing(fsmnum);
    assert(useId == 1);
    print(fsmnum);

NAME

    usebakdb


SYNOPSIS

    TInteger usebakdb(TInteger flag)


DESCRIPTION

    业务逻辑中可以强制设置使用主数据库还是备数据库操作


ARGUMENTS

    flag: 1设置使用备库，0设置使用主库


RETURN

    0


EXAMPLES

    var TString  fsmnum = getfsmidstr();
    var TInteger useId = isfsmusing(fsmnum);
    assert(useId == 1);

NAME

    bigintoper


SYNOPSIS

    TString bigintoper(TString i1,TString i2 ,TString op, TInteger type=
    10 )


DESCRIPTION

    提供简单的大整数运算功能。


ARGUMENTS

    i1: 整数操作数1

    i2: 整数操作数2

    op: 操作符，可以是 '+' '-' '*' '/' '%'

    type: 进制，缺省为10


RETURN

    计算结果


EXAMPLES

    var TString s;
    s = bigintoper('666666666666666666666666666','37483473847384748347384'
    ,'+',10);
    assert(s == '666704150140514051415014050');
    s = bigintoper('666666666666666666666666666','37483473847384748347384'
    ,'-',10);
    assert(s == '666629183192819281918319282');
    s = bigintoper('666666666666666666666666666','37483473847384748347384'
    ,'*',10);
    assert(s == '24988982564923165564922666641677684101743501101744');
    s = bigintoper('666666666666666666666666666','37483473847384748347384'
    ,'/',10);
    assert(s == '17785');
    s = bigintoper('666666666666666666666666666','37483473847384748347384'
    ,'%',10);
    assert(s == '23084290928917308442226');

NAME

    floatoper


SYNOPSIS

    TString floatoper(TString f1,TString f2 ,TInteger op,TInteger e=4 )

    

DESCRIPTION

    提供简单的字符串形式的浮点运算功能。


ARGUMENTS

    f1: operator1

    f2: operator2

    op: operation（1:add 2:sub 3:mul 4:div）

    e: 返回值的精度。


RETURN

    


NAME

    trimfloatstr2, floattosciense


SYNOPSIS

    TString trimfloatstr2(TString f, TInteger e)
    TString floattosciense(TString f)


DESCRIPTION

    trimfloatstr2将一个科学计数法的浮点数转换为带小数点的浮点数字符串。而
    floattosciense则将一个浮点字符串转换为科学计数法表示。这两个函数都不丧
    失任何有效数字


ARGUMENTS

    f: 输入的浮点字符串

    e: 10的多少次方


RETURN

    对trimfloatstr2，返回一个带小数点的浮点字符串。对floattosciense返回一
    个不带小数点的串加一个竖线和一个10的几次方


EXAMPLES

    assert(floattosciense('1.1') == '11|-1');
    assert(floattosciense('1.11111') == '111111|-5');
    assert(floattosciense('11111') == '11111|0');
    assert(floattosciense('100000') == '1|5');
    assert(floattosciense('11100000') == '111|5');
    assert(trimfloatstr2('111',5) == '11100000');
    assert(trimfloatstr2('1',5) == '100000');
    assert(trimfloatstr2('11111',0) == '11111');
    assert(trimfloatstr2('111111',-5) == '1.11111');
    assert(trimfloatstr2('1.11111',-5) == '0.0000111111');

NAME

    globaldis


SYNOPSIS

    TInteger globaldis(TString x1, TString y1 ,TString x2, TString x2, TString 
    r='6370')
    TDouble globaldis(TDouble x1, TDouble y1 ,TDouble x2, TDouble x2, TDouble 
    r=6371.004)


DESCRIPTION

    计算球面上两点之间的距离。（较早的版本只支持以字符串为参数返回整数）
    


ARGUMENTS

    x1: 第一个点的经度

    y1: 第一个点的维度

    x2: 第二个点的经度

    y2: 第二个点的维度

    r: 球的半径，缺省为地球的平均半径，公里为单位


RETURN

    两点之间的距离，公里为单位


EXAMPLES

    例如北京在东经116.4 ，北纬39.9，上海在东经121.4，北纬31.2，求北京到上
    海的球面距离:
    globaldis('116.4', '39.9', '121.4', '31.2', '6370')
    返回1067
    globaldis(116.4, 39.9, 121.4, 31.2, 6370)
    返回1067.273602186433

NAME

    abs, TDouble::abs


SYNOPSIS

    TInteger abs(TInteger x)
    TDouble TDouble::abs()


DESCRIPTION

    求绝对值


ARGUMENTS

    x: 给定的整数


RETURN

    返回整数或者浮点数的绝对值


EXAMPLES

    var TInteger i;
    var TDouble d;
    i = -10;
    assert(abs(i) == 10);
    d = -1.234;
    assert(d.abs() == 1.234);

NAME

    TDouble::sin, TDouble::cos, TDouble::tan, TDouble::asin, TDouble::acos,
     TDouble::atan


SYNOPSIS

    TDouble TDouble::sin()
    TDouble TDouble::cos()
    TDouble TDouble::tan()
    TDouble TDouble::asin()
    TDouble TDouble::acos()
    TDouble TDouble::atan()


DESCRIPTION

    求三角函数


ARGUMENTS

    无

RETURN

    给定浮点数的三角函数值


EXAMPLES

    var TDouble d, d1;
    d1 = d.sin();
    d1 = d.cos();
    d1 = d.tan();
    d1 = d.asin();
    d1 = d.acos();
    d1 = d.atan();

NAME

    TDouble::ceil, TDouble::floor, TDouble::round


SYNOPSIS

    TDouble TDouble::ceil()
    TDouble TDouble::floor()
    TDouble TDouble::round()


DESCRIPTION

    对浮点数取整，ceil向上取整，floor向下取整，round四舍五入


ARGUMENTS

    无

RETURN

    返回取整之后的浮点数


EXAMPLES

    var TDouble d = 1.6;
    assert(d.ceil() == 2);
    assert(d.floor() == 1);
    assert(d.round() == 2);

NAME

    TDouble::log, TDouble::log10


SYNOPSIS

    TDouble TDouble::log()
    TDouble TDouble::log10()


DESCRIPTION

    求对数，log是求以e为底的自然对数，log10是求以10为底的常用对数


ARGUMENTS

    无

RETURN

    返回对数值


NAME

    TDouble::sqrt


SYNOPSIS

    TDouble TDouble::sqrt()


DESCRIPTION

    求平方根


ARGUMENTS

    无

RETURN

    返回平方根


NAME

    TDouble::pow


SYNOPSIS

    TDouble TDouble::pow(TDouble x)


DESCRIPTION

    求幂


ARGUMENTS

    x: 指数，可以是浮点数


RETURN

    求给定指数的幂


EXAMPLES

    var TDouble d = 1.5
    assert(d.pow(2) == 2.25)

NAME

    min, max


SYNOPSIS

    TInteger min(TInteger i, ... )
    TDouble min(TDouble i, ... )
    TInteger max(TInteger i, ... )
    TDouble max(TDouble i, ... )


DESCRIPTION

    求最小值，最大值，参数是整数或者浮点数，至少2个参数，最多30个参数。

    

ARGUMENTS

    i: 参与比较的整数或者浮点数


RETURN

    最小值或者最大值


EXAMPLES

    var TInteger i;
    var TDouble x;
    i = min(10, 5, 8, 12, 4, 6);
    assert(i == 4);
    i = max(10, 5, 8, 12, 4, 6);
    assert(i == 12);
    x = min(10, 5.1, 8, 12, 4.2, 6);
    assert(x == 4.2);
    x = max(10, 5.1, 8, 12.2, 4, 6);
    assert(x == 12.2);

NAME

    numbertrans, keymatch


SYNOPSIS

    TString numbertrans(TString src, TInteger type)
    TString keymatch(TString src, TInteger type)


DESCRIPTION

    匹配$CINDIR/etc/numbertab表的第一列，返回第二列。numbertrans一般用于
    电话号码取得计费前缀，例如区号或者局号。keymatch一般用于关键词过滤等应
    用。二者的匹配方式有所区别，对keymatch来说可以从任何位置开始匹配，而numbertrans必
    须是从开头进行匹配。为了避免冲突，为keymatch而设置的numbertab中的匹配
    关键词须F开头


ARGUMENTS

    src: 被匹配的字符串

    type: 匹配规则2和12表示最长匹配，1和11表示最短匹配，1和2查不到抛出异
    常，11和12如果查不到返回空串


RETURN

    如果匹配成功，返回numbertab表中匹配行的第二列


EXAMPLES

    /*
    # the numbertab file
    030 309999
    0306223 21890
    F030 a
    */
    assert(numbertrans('0306223', 11) == '309999');
    assert(numbertrans('0306223', 22) == '21890');
    assert(numbertrans('003000', 12) == '');
    assert(keymatch('003000', 2) == 'a');

NAME

    random


SYNOPSIS

    TInteger random(TInteger i)


DESCRIPTION

    获得指定范围的随机数


ARGUMENTS

    i: 随机数的产生范围0到i-1


RETURN

    整数，随机产生 


EXAMPLES

    i = random(100);
    assert(i>=0 && i<=99);

NAME

    streamnumber


SYNOPSIS

    TInteger streamnumber(TString key, TInteger i)


DESCRIPTION

    获得一个自定义的流水号，每次调用该函数,流水号+1。主要用于SMP需求


ARGUMENTS

    key: 字符串，序列号生成器的名字

    i: 整数，序列号最大值+1，当i=0 时，清空该序列号


RETURN

    整数流水号，最大值为－1


EXAMPLES

    i = streamnumber('accountid', 100000000);

NAME

    checksum, checksum2, checksum3


SYNOPSIS

    TString checksum(TString s)
    TString checksum2(TString s)
    TString checksum3(TString s)


DESCRIPTION

    求检查和（例如将字符串的各个字符相加得到的和取模）可以用来检验字符串
    的正确性。其中：
    - checksum用的是各字符相加用256取模
    - checksum2用的是个字符异或得到的字符
    - checksum3有特殊用处，主要是处理FSK字符串，是FSK字符串中除去同步引导
    串之外的字节相加用256取模


ARGUMENTS

    s: 需要求检查和的字符串


RETURN

    单个检查和字符的字符串


EXAMPLES

    str = checksum('12341');
    assert(str == '1');

NAME

    bytesum


SYNOPSIS

    TInteger bytesum(TString s)


DESCRIPTION

    按位求和，参数可以是16进制字符串（5.2.9以上版本支持）


ARGUMENTS

    s: 要求和的字符串


RETURN

    


EXAMPLES

    i = bytesum('12345');  // i=1+2+3+4+5=15
    j = bytesum('12345Abc');  // i=1+2+3+4+5+10+11+12=48

NAME

    hcode


SYNOPSIS

    TString hcode(TString number)


DESCRIPTION

    使用config.hcode配置，获取国内手机号码所对应的区号


ARGUMENTS

    number: 国内手机号码


RETURN

    国内区号


EXAMPLES

    void main()
    {
       var TString areaCode,msisdn;
       msisdn = '13910590001';
       areaCode = hcode(msisdn);
       ...
    }

NAME

    mscidtoloc


SYNOPSIS

    TString mscidtoloc(TString mscid)


DESCRIPTION

    使用config.mscid配置，获取CDMA网络MSCID所对应的区号


ARGUMENTS

    mscid: CDMA网络MSCID号码


RETURN

    区号


EXAMPLES

    void main()
    {
       var TString areaCode,mscid;
       mscid = '360001';
       areaCode = mscidtoloc(mscid);
       ...
    }

NAME

    tldntomscid


SYNOPSIS

    TString tldntomscid(TString tldn)


DESCRIPTION

    使用config.mscid配置，根据TLDN获取CDMA网络所对应的MSCID


ARGUMENTS

    tldn: CDMA网络TLDN号，10进制字符串


RETURN

    MSCID号码，16进制字符串


EXAMPLES

    void main()
    {
       var TString tldn,mscid;
       tldn = '13334710';
       mscid = tldntomscid(tldn);
       assert(mscid == '37288A');
       tldn = '8613334710'
       mscid = tldntomscid(tldn);
       assert(mscid == '37288A');
       tldn = '013334710';
       mscid = tldntomscid(tldn);
       assert(mscid == '37288A');
       tldn = '13334710999';
       mscid = tldntomscid(tldn);
       assert(mscid == '37288A');
    }

NAME

    getabortid


SYNOPSIS

    TInteger  getabortid( )


DESCRIPTION

    当业务收到tc-p-abort 或tc-u-abort后，通过该函数取abortid (abortreson)
    


ARGUMENTS

    无

RETURN

    


NAME

    getproblemtype


SYNOPSIS

    TInteger  getproblemtype( )


DESCRIPTION

    获取problem的类型


ARGUMENTS

    无

RETURN

    


NAME

    getproblemid


SYNOPSIS

    TInteger  getproblemid( )


DESCRIPTION

    获取problem 的值


ARGUMENTS

    无

RETURN

    


NAME

    gettermination


SYNOPSIS

    TInteger  gettermination( )


DESCRIPTION

    获取tc-end 的终止类型


ARGUMENTS

    无

RETURN

    


NAME

    getcurrentinvokeid


SYNOPSIS

    TInteger  getcurrentinvokeid( )


DESCRIPTION

    获取当前发送的操作的Invokeid，比如发送PA后想获取invokeid ，然后用Cancel 
    操作取消该操作。(5.3以上版本支持)


ARGUMENTS

    无

RETURN

     当前发送的操作的Invokeid


NAME

    getcurrentlinkedid


SYNOPSIS

    TInteger  getcurrentlinkedid ( )


DESCRIPTION

    获取当前收到的操作的linkedid ，比如异步发送多个PA后收到的SRR操作通过
    linkedid 来区分。(5.3以上版本支持)


ARGUMENTS

    无

RETURN

     当前收到的操作的linkedid


NAME

    userinformation


SYNOPSIS

    TString userinformation( )


DESCRIPTION

    获取TCAP对话原语携带的userinformation信息


ARGUMENTS

    无

RETURN

    userinformation 信息的ASC字符串


NAME

    getacidbydpc


SYNOPSIS

    TString getacidbydpc(TString dpcName)


DESCRIPTION

    STSCFG.DAT文件中配置了7号信令的DPC的信息。针对每个DPC可以配置它的缺省
    的ACID。这个函数就是根据DPC获得这个缺省的ACID


ARGUMENTS

    dpcName: 配置中的dpc名称


RETURN

    该DPC的缺省ACID，这是一个整数，是在config.ac中配置的ac的序号


NAME

    []::length


SYNOPSIS

    TInteger []::length()


DESCRIPTION

    求数组的当前长度


ARGUMENTS

    无

RETURN

    整数，数组当前长度


EXAMPLES

    var TInteger i[] = {1,2,3};
    assert(i.length() == 3);

NAME

    []::tostr


SYNOPSIS

    TString []::tostr(TString sep='|')


DESCRIPTION

    将数组的内容转换为一个字符串


ARGUMENTS

    sep: 分隔符，缺省是竖线


RETURN

    转换后的字符串


EXAMPLES

    var TInteger i[] = {1,2,3};
    assert(i.tostr() == '1|2|3');
    assert(i.tostr(',') == '1,2,3');

NAME

    []::index


SYNOPSIS

    TInteger []::index(TypeOfArrayMember mem)


DESCRIPTION

    求一个成员在数组中的位置


ARGUMENTS

    mem: 成员，其数据类型必须使数组的成员的类型，如果是字符串数组，那么这
    个参数必须是字符串，如果是整数数组，那么这个参数必须是整数


RETURN

    整数，在数组中的位置，从0开始，如果返回-1表示找不到


EXAMPLES

    var TInteger i[] = {1,2,3};
    assert(i.index(1) == 0);
    assert(i.index(2) == 1);
    assert(i.index(5) == -1);
    var TString s[] = {'aa','bb','cc'};
    assert(s.index('aa') == 0);
    assert(s.index('bb') == 1);
    assert(s.index('ddd') == -1);

NAME

    []::dup


SYNOPSIS

    TypeOfArrayMember[] []::dup()


DESCRIPTION

    复制一个数组


ARGUMENTS

    无

RETURN

    复制之后的数组，成员类型必须与被复制的数组的成员类型相同


EXAMPLES

    var TInteger i[] = {1,2,3};
    var TInteger j[] = i.dup();

NAME

    []::pop, []::push, []::unshift, []::shift


SYNOPSIS

    TInteger []::push(TypeOfArrayMember mem)
    TypeOfArrayMember []::pop()
    TInteger []::unshift(TypeOfArrayMember mem)
    TypeOfArrayMember []::shift()


DESCRIPTION

    push在数组尾部增加一个成员，pop从数组尾部取出一个成员，unshift在数组
    头部增加一个成员，shift从数组头部取出一个成员


ARGUMENTS

    mem: push和unshift有这个参数，是增加的成员，其类型必须与数组成员的类
    型一致


RETURN

    pop和unshift返回取出的成员，其类型与数组成员的类型一致


EXAMPLES

    var TInteger i[] = {1,2,3};
    i.push(4);
    assert(i.tostr() == '1|2|3|4');
    i.unshift(0);
    assert(i.tostr() == '0|1|2|3|4');
    assert(i.pop() == 4);
    assert(i.tostr() == '0|1|2|3');
    assert(i.shift() == 0);
    assert(i.tostr() == '1|2|3');

NAME

    []::tojson, []::parsejson


SYNOPSIS

    TString []::tojson()
    TInteger []::parsejson(TString jsonStr)


DESCRIPTION

    tojson将数组的内容转换为JSON格式的字符串返回。parsejson将一个JSON格式
    的字符串解析到数组中，数组中的原有成员将会被清掉


ARGUMENTS

    jsonStr: JSON数组格式的字符串


RETURN

    tojson返回JSON格式的字符串。parsejson如果解析正确返回1，否则返回0


EXAMPLES

    var TInteger a[] = {123, 456, 789};
    assert(a.tojson() == '[123,456,789]');
    a.parsejson('[1,2,3,4]');
    assert(a.length() == 4);
    assert(a[0] == 1);
    assert(a[1] == 2);
    assert(a[2] == 3);
    assert(a[3] == 4);

NAME

    memcacheget, memcachegets


SYNOPSIS

    
    TString  memcacheget(TString tableName, TString key, TString dbName=
    '')
    TString  memcachegets(TString tableName, TString key, TString seq, TString 
    dbName='')
    


DESCRIPTION

    这几个函数用于与memcachedb交互. 
    memcachedb 是一个 key-value 结构的存储系统, 能够提供数据持久化和实时
    异机复制能力. 
    scf通过配置文件config.memcachedb可以操作多个memcachedb, config.memcachedb示
    例如下: 
       groupname memcache1 
       192.168.2.237 21211 
       192.168.2.237 21212 
       groupname memcache2 
       192.168.3.162 32311 
       192.168.3.162 32312 
    其中memcache1，memcache2类似于传统的数据库名，config.memcache中可以配
    置10个group.由于memcachedb可以支持主从复制， 因此一个组内可以出现多个
    主机或端口（最多10个）。
    根据业务开发习惯， 在业务中通过函数操作memcachedb时, 仍保留database,
     table概念。
    memcacheget和memcachegets都是查询函数, memcachegets函数在返回值的同时
    还返回该记录的时间戳值并存放在seq变量中


ARGUMENTS

    tableName: 字符串，必须以大写字母开头, 并且不能包含上箭头和空格字符

    
    key: 字符串，不能包含' '字符, scf使用tableName和key构造查询条件

    seq: 字符串变量, 用于保存memcachedb返回的时间戳

    dbName: 字符串, scf根据dbName查找config.memcachedb配置, 找到对应的memcachedb端
    口. 如果dbName为空则轮选


RETURN

    二进制字符串, 如果记录不存在或其它错误, 抛出异常


NAME

    memcacheset, memcacheadd, memcachereplace, memcachecas


SYNOPSIS

    TInteger memcacheset(TString tableName, TString key, TString value, 
    TInteger expire, TString dbName='')
    TInteger memcacheadd(TString tableName, TString key, TString value, 
    TInteger expire, TString dbName='')
    TInteger memcachereplace(TString tableName, TString key, TString value,
     TInteger expire, TString dbName='')
    TInteger memcachecas(TString tableName, TString key, TString value, 
    TInteger expire, TString seq, TString dbName='') 


DESCRIPTION

    这几个函数用于与memcachedb交互. 
    memcachedb 是一个 key-value 结构的存储系统, 能够提供数据持久化和实时
    异机复制能力. 
    scf通过配置文件config.memcachedb可以操作多个memcachedb, config.memcachedb示
    例如下: 
       groupname memcache1 
       192.168.2.237 21211 
       192.168.2.237 21212 
       groupname memcache2 
       192.168.3.162 32311 
       192.168.3.162 32312 
    其中memcache1，memcache2类似于传统的数据库名，config.memcache中可以配
    置10个group.由于memcachedb可以支持主从复制， 因此一个组内可以出现多个
    主机或端口（最多10个）。
    根据业务开发习惯， 在业务中通过函数操作memcachedb时, 仍保留database,
     table概念。
    memcacheset: 存储value, 无论key是否存在. 
    memcacheadd: 如果key不存在, 则存储value. 
    memcachereplace: 如果key存在, 则使用value替换旧值. 
    memcachecas: 如果seq值与服务器上的时间戳匹配, 则用value替换旧值. 


ARGUMENTS

    tableName: 字符串，必须以大写字母开头, 并且不能包含上箭头和空格字符

    
    key: 字符串，不能包含' '字符, scf使用tableName和key构造查询条件

    value: 二进制字符串，准备存储在memcachedb中的值

    expire: 整数，用于表示数据过期时间, 60表示60秒后数据失效. 0表示无失效
    时间.

    seq: 字符串变量, 用于和memcachedb中该记录的时间戳相比较

    dbName: 字符串, scf根据dbName查找config.memcachedb配置, 找到对应的memcachedb端
    口. 如果dbName为空则轮选


RETURN

    整数, 指明操作结果, 0表示成功, 其它为错误码


NAME

    memcacheremove, memcachepkdel


SYNOPSIS

    
    TInteger memcacheremove(TString tableName, TString key, TString dbName=
    '')
    TInteger memcachepkdel(TString tableName, TString key, TString dbName=
    '') 


DESCRIPTION

    这几个函数用于与memcachedb交互. 
    memcachedb 是一个 key-value 结构的存储系统, 能够提供数据持久化和实时
    异机复制能力. 
    scf通过配置文件config.memcachedb可以操作多个memcachedb, config.memcachedb示
    例如下: 
       groupname memcache1 
       192.168.2.237 21211 
       192.168.2.237 21212 
       groupname memcache2 
       192.168.3.162 32311 
       192.168.3.162 32312 
    其中memcache1，memcache2类似于传统的数据库名，config.memcache中可以配
    置10个group.由于memcachedb可以支持主从复制， 因此一个组内可以出现多个
    主机或端口（最多10个）。
    根据业务开发习惯， 在业务中通过函数操作memcachedb时, 仍保留database,
     table概念。
    memcacheremove: 删除memcachedb中指定记录. 
    memcachepkdel: 按前缀删除memcachedb中的记录, 最多删除500条. 


ARGUMENTS

    tableName: 字符串，必须以大写字母开头, 并且不能包含上箭头和空格字符

    
    key: 字符串，不能包含' '字符, scf使用tableName和key构造查询条件

    dbName: 字符串, scf根据dbName查找config.memcachedb配置, 找到对应的memcachedb端
    口. 如果dbName为空则轮选


RETURN

    整数, 指明操作结果, 对于memcacheremove函数, 返回0表示成功, 其它为错误
    码. 对于memcachepkdel函数, 返回值表示实际删除记录数


NAME

    memcacheremove, memcachepkdel


SYNOPSIS

    TString  memcacheincr(TString tableName, TString key, TInteger offset,
     TString dbName='')
    TString  memcachedecr(TString tableName, TString key, TInteger offset,
     TString dbName='')


DESCRIPTION

    这几个函数用于与memcachedb交互. 
    memcachedb 是一个 key-value 结构的存储系统, 能够提供数据持久化和实时
    异机复制能力. 
    scf通过配置文件config.memcachedb可以操作多个memcachedb, config.memcachedb示
    例如下: 
       groupname memcache1 
       192.168.2.237 21211 
       192.168.2.237 21212 
       groupname memcache2 
       192.168.3.162 32311 
       192.168.3.162 32312 
    其中memcache1，memcache2类似于传统的数据库名，config.memcache中可以配
    置10个group.由于memcachedb可以支持主从复制， 因此一个组内可以出现多个
    主机或端口（最多10个）。
    根据业务开发习惯， 在业务中通过函数操作memcachedb时, 仍保留database,
     table概念。
    memcacheincr: 把memcachedb中指定记录值看作整数, 做加法. 
    memcachedecr: 把memcachedb中指定记录值看作整数, 做减法. 


ARGUMENTS

    tableName: 字符串，必须以大写字母开头, 并且不能包含上箭头和空格字符

    
    key: 字符串，不能包含' '字符, scf使用tableName和key构造查询条件

    offset: 整数，用于对指定记录作算术加法或减法

    dbName: 字符串, scf根据dbName查找config.memcachedb配置, 找到对应的memcachedb端
    口. 如果dbName为空则轮选


RETURN

    字符串, 用于保存算术运算后的新值. 如果没有找到记录或其它错误, 抛出异
    常


NAME

    memcachepkget, memcachegetnext, memcachegetprev


SYNOPSIS

    
    TInteger memcachepkget(TString tableName, TString key, TInteger scptable,
     TInteger limit, TString dbName='')
    TInteger memcachegetnext(TString tableName, TString key, TInteger scptable,
     TInteger limit, TString dbName='')
    TInteger memcachegetprev(TString tableName, TString key, TInteger scptable,
     TInteger limit, TString dbName='') 


DESCRIPTION

    这几个函数用于与memcachedb交互. 
    memcachedb 是一个 key-value 结构的存储系统, 能够提供数据持久化和实时
    异机复制能力. 
    scf通过配置文件config.memcachedb可以操作多个memcachedb, config.memcachedb示
    例如下: 
       groupname memcache1 
       192.168.2.237 21211 
       192.168.2.237 21212 
       groupname memcache2 
       192.168.3.162 32311 
       192.168.3.162 32312 
    其中memcache1，memcache2类似于传统的数据库名，config.memcache中可以配
    置10个group.由于memcachedb可以支持主从复制， 因此一个组内可以出现多个
    主机或端口（最多10个）。
    根据业务开发习惯， 在业务中通过函数操作memcachedb时, 仍保留database,
     table概念。
    memcachepkget: 按前缀查询memcachedb中的记录, 最多一次返回500条. 
    memcachegetnext: 查询memcachedb指定记录之后的记录, 最多一次返回500条
    . 
    memcachegetprev: 查询memcachedb指定记录之后的记录, 最多一次返回500条
    .


ARGUMENTS

    tableName: 字符串，必须以大写字母开头, 并且不能包含上箭头和空格字符

    
    key: 字符串，不能包含' '字符, scf使用tableName和key构造查询条件

    scptable: SCPTable变量, 用于保存查询结果

    limit: 整数, 用于限制最多返回多少条记录

    dbName: 字符串, scf根据dbName查找config.memcachedb配置, 找到对应的memcachedb端
    口. 如果dbName为空则轮选


RETURN

    整数, 成功返回0, 否则抛出异常


NAME

    function


SYNOPSIS

    TString function(TString cmd)


DESCRIPTION

    用于执行INES程序重写specialFunction接口实现的命令


ARGUMENTS

    cmd: 要调用的命令字符串


RETURN

    命令执行的结果


NAME

    command


SYNOPSIS

    TString command(TString cmd)


DESCRIPTION

    作为一个命令执行


ARGUMENTS

    cmd: 调用的命令字符串，该命令应该是可以在inaccess接入的scf提示符下能
    够执行的命令


RETURN

    命令执行的结果


NAME

    systemcall


SYNOPSIS

    TString systemcall (TString cmd)


DESCRIPTION

    执行一个外部命令，将启动一个线程执行


ARGUMENTS

    cmd: 如果要执行外部命令，那么必须这样填写参数'System ...'


RETURN

    命令的执行结果。注意：使用该函数必须保证cin/crash目录存在，否则执行失
    败。


EXAMPLES

    systemcall('System ls');
    将返回当前目录的文件列表。

NAME

    getenv


SYNOPSIS

    TString getenv(TString envName)


DESCRIPTION

    获取环境变量设置


ARGUMENTS

    envName: 环境变量名称 


RETURN

    环境变量值


EXAMPLES

    s = getenv('CINDIR');

NAME

    gethostname, getusername, getprocname


SYNOPSIS

    TString gethostname()
    TString getusername()
    TString getprocname()


DESCRIPTION

    gethostname获得本机的主机名，getusername获得SCF启动的帐号名称，getprocname获
    得执行脚本的scf启动参数


ARGUMENTS

    无

RETURN

    字符串形式的名字


NAME

    getipaddress


SYNOPSIS

    TString  getipaddress( )


DESCRIPTION

    获得本机的ip地址。


ARGUMENTS

    无

RETURN

    


NAME

    getariinfo, setariinfo


SYNOPSIS

     TString getariinfo()
    TInteger setariinfo(TString s)


DESCRIPTION

     getariinfo，得到ui SIB使用etc操作获得的ARI业务的自动机号。setariinfo，
    设置ui SIB所需的ARI业务自动机号。
    这两个函数是为了支持同一个ETC下ui SIB方式和printf+ARI业务方式混用，以
    下几种情况会用到这两个函数：
    如果使用xmlsib发送ETC, 显式等待内部事件得到ARI业务的自动机号，如果此
    后的流程中如果使用ui SIB对老方式驱动IP操作，那么之前必须调用setariinfo将
    得到的这个自动机号告诉老的ui等SIB。
    如果使用ui sib发送ETC, 此后的流程中如果直接使用printf等SIB直接发消息
    给ARI业务，那么必须使用getariinfo得到当前的ARI业务的自动机号。
    上述两种情况下，因为内部知道了ARI业务的自动机号，自动机删除的时候会自
    动给ARI业务发送TCEnd内部消息。主业务中就不必显式发送TCEnd内部消息了。
    否则可能发送两次。setariinfo('')可以清除此前setariinfo('...')的设置，
    清除了之后，自动机删除的时候不会自动给ARI业务发送TCEnd 内部消息。


ARGUMENTS

    无

RETURN

    


NAME

    arifsmid


SYNOPSIS

    TString  arifsmid (TString arg1)


DESCRIPTION

    将ari操作中的correlationID转换为发送etc操作的InstanceID，规则是这样的
    ：如果系统没有配置globalscfid，那么直接去掉前两个字符；如果系统配置了
    globalscfid，那么把前两位globalscfid转换为local的scfid。


ARGUMENTS

    arg1: ari操作中的correlationID


RETURN

    曾经发送ETC操作的那个FSM的InstanceID，两位进程号+自动机号


EXAMPLES

    s = arifsmid('12345')
    结果：s: 345

NAME

    setinesroute


SYNOPSIS

    TInteger setinesroute(TInteger ruleid, TString key)


DESCRIPTION

    当SCF配置为scf_fep  scf_bep方式时，可以在serviceconfig通过配置路由机
    制选择后端应用。
    移动GPRS业务的实现和CDMA业务很类似，也需要配置为前端和后端结构，但是
    实现GPRS业务关联的KEY 是存放在tcap消息的userinfo中，不能直接使用serviceconfig配
    置。所以增加此函数，通过该函数的调用达到选择scf_bep连接的目的。
    返回成功后静态变量BESConName 被设置为bep端的ines名字，业务可以通过该
    名字给bep端发送消息。


ARGUMENTS

    ruleid: 整型，表示serviceconfig配置中rule表的id

    key: 字符串，路由选择key


RETURN

    0 成功
    2 检索路由表失败
    3 key错误
    4 ruleID错误


EXAMPLES

    #progma c
    void main()
    {
       var TInteger key;
       var TString strKey;
    
       strKey=argv4;
       key=setinesroute(1,strKey);
       print(sprintf('Key:%s RuleID:1 return:%d BESConName:%s',strKey,key,
    besconName));
    }
    通过使用不同的参数调用上面的业务逻辑，可以看到如下的输出：
    Key:1 RuleID:1 return:0 BESConName:bep2
    Key:2 RuleID:1 return:0 BESConName:diameterS1
    Key:3 RuleID:1 return:0 BESConName:bep2 // ines3连接不通，所以选择了
    备用bep2
    Key:4 RuleID:1 return:0 BESConName:bep1
    路由表配置：
    service_config_begin
    ACID : 50
    OPID : 123
    SSN  : -1
    SERVICEID : 14
    FSMTYPE : 6
    ROUTETAB
     RULEID         : 1
     ROUTERULE       :4
     ROUTEKEYMAX            : 4
     = 0 BESCONNAME         : 'bep1'
     = 1 BESCONNAME         : 'bep2'
     = 2 BESCONNAME         : 'diameterS1'
     = 3 BESCONNAME         : 'ines3'  'bep2'
    ROUTETABEND
    service_config_end

NAME

    abnfparse


SYNOPSIS

    TInteger abnfparse(TString msg, TString abnfName)


DESCRIPTION

    按照ABNF语法描述解析一个消息，解析结果生成一个xml对象，返回对象的handle

    

ARGUMENTS

    msg: 要解析的消息体，如果不符合语法，则不能生成xml对象，导致抛出异常
    

    abnfName: ABNF语法规则的名字。这个在之前应该配置好，abnf命令可以维护
    这些ABNF配置表。


RETURN

    如果解析成功，则返回xml对象的handle


EXAMPLES

    例如\$CINDIR/abnf/中配置了sip.abnf以及sip.abnf.rulecfg
    并且使用abnf load sip命令成功加载，那么可以调用下面的函数
    abnfparse('INVITE sip:1234@192.168.2.120 SIP/2.0\0D\0A','sip')
    可能生成一个xml树（根据sip.abnf.rulecfg配置不同，xml节点可能不同）：
    
    <SIP-message>INVITE sip:1234@192.168.2.120 SIP/2.0
      <Request>INVITE sip:1234@192.168.2.120 SIP/2.0
        <Request-Line>INVITE sip:1234@192.168.2.120 SIP/2.0
          <Method>INVITE</Method>
          <Request-URI>sip:1234@192.168.2.120
            <SIP-URI>sip:1234@192.168.2.120
    	  <userinfo>1234@
    	    <user>1234</user>
    	  </userinfo>
    	  <hostport>192.168.2.120
    	    <host>192.168.2.120</host>
    	  </hostport>
    	</SIP-URI>
          </Request-URI>
          <SIP-Version>SIP/2.0</SIP-Version>
        </Request-Line>
      </Request>
    </SIP-message>

NAME

    jsivar, jsi, jsitest


SYNOPSIS

    TInteger jsivar(TString varName, TString strValue)
    TInteger jsivar(TString varName, TInteger intValue)
    TString jsi(TString exp)
    TInteger jsitest(TString boolExp)


DESCRIPTION

    这个是一个测试用的函数，实际应用并使用。scf支持vxml解析的同时只吃了简
    单的javascript解释执行。这几个函数就是为了测试这个javascript环境而设。
    可以定义变量，计算普通表达式和bool表达式的返回结果


ARGUMENTS

    varName: 要定义的jsi变量名

    strValue: 要定义的字符串变量的初始值

    intValue: 要定义的整数变量的初始值

    exp: 要计算的js表达式

    intValue: 要计算的js bool表达式


RETURN

    对于jsi函数，返回计算结果，无论是整数还是字符串都返回字符串格式，对于
    jsitest函数，如果bool表达式为真则返回1，如果为假则返回0


EXAMPLES

    jsivar('a','1') // 定义一个字符串变量a，其初始值为'1'
    jsi('a') // 计算js表达式'a'，得到结果'1'
    jsivar('b','2') // 定义一个字符串变量b，其初始值为'2'
    jsi('a+b') // 计算js表达式'a+b'，得到'12'
    jsivar('i',1) // 定义一个整数变量i，其初始值为1
    jsivar('j',2) // 定义一个整数变量j，其初始值为2
    jsi('i+j') // 计算js表达式，得到'3'
    jsitest('a>3') // 计算js bool表达式，得到0
    jsitext('a<3') // 计算js bool表达式，得到1

NAME

    delete


SYNOPSIS

    TInteger delete(handle)


DESCRIPTION

    删掉参数所指的对象，没有删除创建的对象在自动机释放的时候将自动清除
    使用一个未初始化的对象或使用一个已经删除的对象，系统都会抛出异常 。

    

ARGUMENTS

    handle: 要删除的对象的handle。这个参数是一个变参，必须是对象类型，必
    须是变量，删除成功之后会被自动改为TObject::NULL(-1)


RETURN

    


NAME

    vxmlrun


SYNOPSIS

    TString vxmlrun(TString arg)


DESCRIPTION

    其功能等价于printf \{ -VXML ...\}


ARGUMENTS

    arg: VXML指令字符串


RETURN

    返回vxml执行的结果，与printf不同的是，并没有将结果解析到argv中，而是
    全部返回，之后需要程序自己 pickword取出需要的字段。


EXAMPLES

    #progma c
    void main()
    {
       var TInteger i;
       var TString result;
    
       for(i=0;i<10000;i=i+1)
       {
          result=vxmlrun('http://192.168.2.217:31976/conf.vxml');
          while(pickword(result,' ',0)=='pc')
          {
             result=vxmlrun('next pcresult');
          }
          vxmlrun('next release');
       }
    }

NAME

    getsipnodeaddress


SYNOPSIS

    TString getsipnodeaddress(TString nodename)


DESCRIPTION

    根据给定的node名字读取对应的IP地址


ARGUMENTS

    arg: node名字


RETURN

    如果config.as中有该节点的信息，则返回该节点对应的ip值，包括端口


EXAMPLES

    #progma c
    void main()
    {
       var TString addresshost;
       addresshost =getsipnodeaddress('ms1');
       assert(addresshost=='192.168.2.237:50914');
    
    }

NAME

    TObject::type


SYNOPSIS

    TInteger TObject::type()


DESCRIPTION

    TObject对象是所有对象的父对象，它的方法会被所有对象继承。type()是用来
    获得对象的具体类型的，一般用在不知道触发对象类型的业务逻辑的main函数之
    后。这种情况下，main函数写TObject参数，之后使用type()方法判断对象类型
    进一步处理


ARGUMENTS

    无

RETURN

    整数形式的类型，例如TObject::HttpServerType，TObject::CommandLineType，
    TObject::TCAPDialogueType等等


EXAMPLES

    void main(TObject obj)
    {
       var TCommandLine cmd;
       var THttpServer httpServer;
       if(obj.type() == TObject::CommandLineType)
       {
          cmd = (TCommandLine)obj;
          ...
       }
       else if(obj.type() == TObject::HttpServerType)
       {
          httpServer = (THttpServer)obj;
          ...
       }
       ...
    }
    

NAME

    TObject::getid, TObject::setid


SYNOPSIS

    TInteger TObject::setid(TString id)
    TString TObject::getid()


DESCRIPTION

    TObject的这两个方法被其它所有对象继承，起作用为用来标识一个对象的ID以
    便用这个ID来查询一个对象


ARGUMENTS

    id: 要设置的对象ID


RETURN

    setid返回0表示成功。getid返回当前对象的ID


EXAMPLES

    var TXMLTree x, y;
    x = new TXMLTree()
    x.setid('aaa');
    assert(x.getid()=='aaa');
    y = findobject(TXMLTree, 'aaa');

NAME

    THttpServer::getrequesttype


SYNOPSIS

    TString THttpServer::getrequesttype()


DESCRIPTION

    获得请求的方法，一般分为GET,POST方法，GET方法不带有content,POST方法带
    有content。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TString strmethod;
    ......
    strmethod=serverObj.getrequesttype();
    assert(strmethod=='POST');
    

NAME

    THttpServer::gethost


SYNOPSIS

    TString THttpServer::gethost()


DESCRIPTION

    获得请求的hostname ，port消息,如果需要构造超级连接，可以直接用这个结
    果。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    // For example the URL: http://192.168.2.205:8080?a=1&b=c
    // assert(httpServer.gethost() == '192.168.2.205:8080');

NAME

    THttpServer::getpath


SYNOPSIS

    TString THttpServer::getpath()


DESCRIPTION

    获得请求行的路径。 


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TString sPath;
    sPath = serverObj.getpath();
    assert(sPath=='http/test');

NAME

    THttpServer::geturlvalue


SYNOPSIS

    TString THttpServer::geturlvalue(TString name)


DESCRIPTION

    获得url中某个参数的值


ARGUMENTS

    name: 参数的名字


RETURN

    参数的值


EXAMPLES

    // For example, the URL: http://192.168.2.205:8080?a=1&b=c
    assert(httpServer.geturlvalue('a') == '1');
    assert(httpServer.geturlvalue('b') == 'c');

NAME

    THttpServer::getreferer


SYNOPSIS

    TString THttpServer::getreferer()


DESCRIPTION

    获得referer,一般通过浏览器请求消息，通过输入url发送的消息，不会存在referer,
    而通过页面点击post属性，会存在referer。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TString strrefer;
    strrefer=serverObj.getreferer();
    print('strrefer:'+strrefer);

NAME

    THttpServer::getcontent


SYNOPSIS

    THttpContent THttpServer::getcontent()


DESCRIPTION

    如果请求消息带有body,获得content对象，如果返回值为-1,则认为没有body。
    


ARGUMENTS

    无

RETURN

    得到的THttpContent对象的handle，-1无效


EXAMPLES

    var THttpContent contObj;
    contObj = serverObj.getcontent();

NAME

    THttpServer::getprocessingduration


SYNOPSIS

    TInteger THttpServer::getprocessingduration (TInteger unit=1)


DESCRIPTION

    获取请求和响应间的处理时间间隔


ARGUMENTS

    unit: 处理时间间隔的单位,0:秒;1:毫秒;2:微秒


RETURN

    处理时间间隔。


EXAMPLES

    iduration=serverObj.getprocessingduration(0);
    print('duration: '+itoa(iduration));

NAME

    THttpServer::getpeerip


SYNOPSIS

    TString THttpServer::getpeerip()


DESCRIPTION

    获得访问该HttpServer对象的客户端的IP地址。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    speerip = serverObj.getpeerip();
    assert(speerip=='192.168.2.237');

NAME

    THttpServer::sendresponse


SYNOPSIS

    TInteger THttpServer::sendresponse (THttpContent contentid)


DESCRIPTION

    发送响应消息


ARGUMENTS

    contentid: 为要发送的消息的内容handle


RETURN

    如果返回值小于0,代表失败，大等于0代表成功。


EXAMPLES

    var THttpContent cntObj;
    cntObj=serverObj.getcontent();
    serverObj.sendresponse(cntObj);

NAME

    THttpServer::senderror


SYNOPSIS

    TInteger THttpServer::senderror(TString message)


DESCRIPTION

    发送错误消息


ARGUMENTS

    message: 消息的内容字符串


RETURN

    如果返回值小于0代表失败，大等于0代表成功。


NAME

    THttpServer::sendstatusresponse


SYNOPSIS

    TInteger THttpServer::sendstatusresponse(TInteger status,THttpContent 
    contentid)


DESCRIPTION

    发送自己设置status的响应信息。


ARGUMENTS

    status: 可以设置的status，status含义如下：
         100: "Continue"
         101: "Switching Protocols"
         200: "OK"
         201: "Created"
         202: "Accepted"
         203: "Non-Authoritative Information"
         204: "No Content"
         205: "Reset Content"
         206: "Partial Content"
         300: "Multiple Choices"
         301: "Moved Permanently"
         302: "Found"
         303: "See Other"
         304: "Not Modified"
         305: "Use Proxy"
         307: "Temporary Redirect"
         400: "Bad Request"
         401: "Unauthorized"
         402: "Payment Required"
         403: "Forbidden"
         404: "Not Found"
         405: "Method Not Allowed"
         406: "Not Acceptable"
         407: "Proxy Authentication Required"
         408: "Request Timeout"
         409: "Conflict"
         410: "Gone"
         411: "Length Required"
         412: "Precondition Failed"
         413: "Request Entity Too Large"
         414: "Request-URI Too Long"
         415: "Unsupported Media Type"
         416: "Requested Range Not Satisfiable"
         417: "Expectation Failed"
         500: "Internal Server Error"
         501: "Not Implemented"
         502: "Bad Gateway"
         503: "Service Unavailable"
         504: "Gateway Timeout"
         505: "Http Version Not Supported"
    

    contentid: 要发送的消息的内容handle


RETURN

    返回值小于0,代表失败，大等于0代表成功。


EXAMPLES

    ......
    serverObj.sendstatusresponse(401,contObj);

NAME

    THttpServer::setauthenticate


SYNOPSIS

    TInteger THttpServer::setauthenticate(TString s)


DESCRIPTION

    设置httpServer对象的WWW-Authenticate头字段，请求进行鉴权


ARGUMENTS

    s: httpServer的分类访问鉴别方式中realm的内容


RETURN

    


EXAMPLES

    serverObj.setauthenticate('webxml','');

NAME

    THttpServer::authusername


SYNOPSIS

    TString THttpServer::authusername()


DESCRIPTION

    在收到鉴权的第二个请求后，使用该函数获得用户输入的用户名


ARGUMENTS

    无

RETURN

    


EXAMPLES

    usrname=serverObj.authusername();
    assert(usrname=='nym1');

NAME

    THttpServer::authorization


SYNOPSIS

    TInteger THttpServer::authorization(TString s)


DESCRIPTION

    在收到鉴权的第二个请求后，使用该函数验证密码是否正确。


ARGUMENTS

    s: 用户的密码


RETURN

    0鉴权失败，1鉴权成功


EXAMPLES

    serverObj.authorization('nym251', 12, 'addbk');

NAME

    THttpClient::THttpClient


SYNOPSIS

    THttpClient::THttpClient(TString logicName)


DESCRIPTION

    创建给定逻辑名的THttpClient对象


ARGUMENTS

    logicName: 给定的逻辑名，这个名字不需要在config.client文件中配置


RETURN

    


EXAMPLES

    var THttpClient httpclientobj;
    httpclientobj=new THttpClient('qc');
    
    逻辑名'qc'不需要在config.client中配置。

NAME

    THttpClient::sendget, THttpClient::sendpost


SYNOPSIS

    TInteger THttpClient::sendget(TString url, int timeout=60)
    TInteger THttpClient::sendpost(TString url, THttpContent contentid, 
    int timeout=60)


DESCRIPTION

    sendget发送带有get方法的请求消息。sendpost发送带有post方法的请求消息
    


ARGUMENTS

    url: 请求消息的url

    timeout: 参数timeout为请求超时时长,单位秒,缺省60


RETURN

    如果返回值小于0代表失败, 大等于0代表成功


EXAMPLES

    var TString  strURL;
    strURL = 'http://192.168.2.237:51289/httpservertest';
    contentObj.setbuffer('text/xml','<vxml version="1.0"><form id="form3"
    ><block><prompt>
    <audio src="10004.wav"/></prompt></block></form></vxml>');	
    	
    contentObj.setsoapbody(soapObj);
    	
    resultCode=httpclientobj.sendpost(strURL,contentObj);
    
    resultCode=httpclientobj.sendget(strURL);

NAME

    THttpClient::getprocessingduration


SYNOPSIS

    TInteger THttpClient::getprocessingduration (TInteger unit=1)


DESCRIPTION

    获取请求和响应间的处理时间间隔


ARGUMENTS

    unit: 处理时间间隔的单位,0:秒;1:毫秒;2:微秒


RETURN

    处理时间间隔。


EXAMPLES

    var TInteger iduration;
    iduration =httpclientobj.getprocessingduration();
    print(sprintf('duration:%d',iduration));

NAME

    THttpClient::getstatus


SYNOPSIS

    TInteger THttpClient::getstatus()


DESCRIPTION

    得到响应消息的status


ARGUMENTS

    无

RETURN

    200到300之间代表成功，其余代表失败。


EXAMPLES

    var TInteger istatus;
    
    istatus = httpclientobj.getstatus();
    print(sprintf('client statue:%d',istatus));

NAME

    THttpClient::getcontent


SYNOPSIS

    THttpContent getcontent()


DESCRIPTION

    获得相应消息content对象


ARGUMENTS

    无

RETURN

    如果返回值为-1,则认为没有body}。
    begin{fexample

    ......
    contentObj = httpclientobj.getcontent();
    contentObj.writefile('test.log');
    ......

NAME

    THttpClient::usepersistentconnection


SYNOPSIS

    TInteger THttpClient::usepersistentconnection ()


DESCRIPTION

    设置请求使用长连接,可用feam -ines查看链接状态


ARGUMENTS

    无

RETURN

    


EXAMPLES

    httpclientobj.usepersistentconnection();

NAME

    THttpClient::getauthenticate


SYNOPSIS

    TString THttpClient::getauthenticate()


DESCRIPTION

    HttpClient对象在收到401响应时，可以调用该函数获得服务器回送的WWW-Authenticate头
    字段的内容。


ARGUMENTS

    无

RETURN

    WWW-Authenticate头字段的内容


EXAMPLES

    httpclientobj.getauthenticate();

NAME

    THttpClient::setauthorization


SYNOPSIS

    TInteger THttpClient::setauthorization(TString s1, TString s2)


DESCRIPTION

    使用该函数在新的请求中设置Authorization头字段的内容，来请求服务器鉴权
    。


ARGUMENTS

    s1: 用户名

    s2: 密码


RETURN

    


EXAMPLES

    httpclientobj.setauthorization('nym','nym251');

NAME

    THttpContent::getcontenttype


SYNOPSIS

    TString THttpContent::getcontenttype()


DESCRIPTION

    获得Content-Type,在message header里边的Content-Type的内容。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    
    contObj.setbuffer('text/plain','<vxml version="1.0"><form id="form1"
    ><block><prompt><audio src="10006.wav"/></prompt></block></form></vxml>
    ');
    var TString strtmp;
    strtmp=contentObj.getcontenttype();
    assert(strtmp=='text/plain');
    

NAME

    THttpContent::gethtmlvalue


SYNOPSIS

    TString THttpContent::gethtmlvalue(TString name)


DESCRIPTION

    如果Content-type是application/x-www-form-urlencoded类型，即通过浏览器
    发过来的消息，通过这个函数可以获得每个控件的值


ARGUMENTS

    name: 控件的名称


RETURN

    


EXAMPLES

    

NAME

    THttpContent::getbuffer, getxmlbody, getsoapbody


SYNOPSIS

    TString THttpContent::getbuffer(TInteger isInlucdeHedaer=0)
    TXMLTree THttpContent::getxmlbody()
    TSoap THttpContent::getsoapbody()


DESCRIPTION

    getbuffer用于获得整个content的内容
    如果Content-Type是Text/xml, 通过getxmlbody函数可以获得TXMLTree对象实
    例，接下来可以通过调用TXMLTree的方法，进行取值操作。
    如果Content-Type是Text/xml, 且确定是soap消息，通过getsoapbody函数可以
    获得TSoap对象实例，接下来可以通过调用TSoap的方法，进行取值操作。


ARGUMENTS

    isInlucdeHedaer: 0，返回不包含头，非0，返回包含包头，缺省为0


RETURN

    getsoapbody返回TSoap对象的handle


EXAMPLES

    contentObj.getbuffer();
    contentObj.getsoapbody();
    

NAME

    THttpContent::setfile, setbuffer, setxmlbody, setsoapbody


SYNOPSIS

    TInteger THttpContent::setfile(TString contentType,TString  fileName)
    
    TInteger THttpContent::setbuffer(TString contentType,TString buffer)
    
    TInteger THttpContent::setxmlbody(TXMLTree xmlhandle)
    TInteger THttpContent::setsoapbody(TSoap soaphandle)


DESCRIPTION

    setfile()把整个文件设置为发送消息的内容，比如发送一个多媒体文件等等。
    这个文件要在webxml目录下存在。
    setbuffer()设置一个字符串作为要发送的消息的内容
    setxmlbody()设置消息体的内容为text/xml格式，并将一个TXMLTree对象作为
    要发送的消息的内容
    setsoapbody()设置消息体的内容为text/xml格式，并将一个TSoap对象作为要
    发送消息的内容


ARGUMENTS

    contentType: 要发送的消息的Content-Type

    fileName: 发送的文件名称

    buffer: 要发送的内容

    handle: TXMLTree或者TSoap对象的handle


RETURN

    返回值如果小于0代表失败，否则成功。


EXAMPLES

    contentObj.setbuffer('text/xml','<vxml version="1.0"><form id="form3"
    ><block><prompt>
    <audio src="10004.wav"/></prompt></block></form></vxml>');	
    	
    contentObj.setsoapbody(soapObj);
    contentObj.setfile('text/xml','smp');

NAME

    THttpContent::sethtmlbody


SYNOPSIS

    TInteger THttpContent::sethtmlbody(TString buffer, TString title, TString 
    configFile, TString alert)


DESCRIPTION

    设置要发送的html消息的内容


ARGUMENTS

    buffer: 一般是由webxml sib生成的html内容

    title: 为要显示的名称

    configFile: 为界面配置文件，该文件必须两个百分号s,第一个会被title替代
    ，第二个会被buffer替代，第一个一般应在<title></title>之间。第二个应该
    在<body></body>之间。

    Alert: 提示信息，如果alert为NULL,则认为没有提示信息，否则认为有提示信
    息


RETURN

    返回值如果小于0代表失败，否则成功。


EXAMPLES

    var THttpContent contObj;
    contObj=new(THttpContent);
    ......
    var TString dbTableStr = '<Row>ID|父ID|类型|业务|对话|消息|步骤数|当
    前步|状态|计时器|屏蔽|创建时间|对象|关联ID|操作</Row><Row>""<Row>ID|PID|
    TYPE|SVC|DIA|MSG|STEPS|STEP|STATE|TIMERS|DISABLE|START|OBJECTS|CID|OPERATIONS<
    /Row></Row>';
    var TString configfile='test';	
    %{
    	webxml
    	{
    	  <Html>
    		<ToCCB>dbTableStr</ToCCB>
    		<Body>
    			<DBTable>
    				<Value>dbTableStr</Value>
               		<Separator>'|'</Separator>	
    			</DBTable>
    		</Body>
    	</Html>
    	}
    %}
    var TInteger setReturn;
    setReturn=contObj.sethtmlbody(dbTableStr,'testhttp',configfile,'notice'
    );
    
    ......

NAME

    THttpContent::getsubcount, getsubcontent, insertsubbody, removesubbody

    

SYNOPSIS

    TInteger THttpContent::getsubcount()
    THttpContent THttpContent::getsubcontent(TInteger index)
    TInteger THttpContent::insertsubbody(TString conteType, THttpContent 
    contentid)
    TInteger THttpContent::removesubbody(TInteger index)


DESCRIPTION

    如果Content-Type是'multipart/...'类型，可以使用这几个函数。
    getsubcount()用于获得子项的个数
    getsubcontent()用于获得一个子内容，得到一个子THttpContent。
    insertsubbody()用于设置子项的消息
    removesubbody()用于把某个子content从自身移走


ARGUMENTS

    index: 指示是第几个子内容。

    contentType: 要设值的content的Content-Type

    contentid: 插入的content


RETURN

    getsubsount()返回子项的个数，如果不是multipart类型返回0。
    getsubcontent返回子THttpContent对象的handle
    insertsubbody返回值如果小于0代表失败，否则成功
    removesubbody返回值如果小于0代表失败，否则表示移走的子content的句柄

    

EXAMPLES

    contObj.getsubcount();
    contObj.getsubcontent(1);
    contSubObj.setbuffer('text/plain','<vxml version="1.0"><form id="form1"
    ><block><prompt><audio src="10006.wav"/></prompt></block></form></vxml>
    ');
    contObj.insertsubbody('multipart/related',contSubObj);
    contObj.removesubbody(1);

NAME

    THttpContent::setmultiparttype


SYNOPSIS

    TInteger THttpContent::setmultiparttype(TInteger type)


DESCRIPTION

    设置附件为multipart时的格式


ARGUMENTS

    type: multipart's type, 0:mime; 1:dime


RETURN

    成功返回0，失败返回负数


NAME

    THttpContent::getsoapaction, THttpContent::setsoapaction


SYNOPSIS

    TString THttpContent::getsoapaction()
    TInteger THttpContent::setsoapaction(TString value)


DESCRIPTION

    获得/设置消息头SOAPAction的内容


ARGUMENTS

    value: 要设置的值


RETURN

    setsoapaction失败返回-1，成功返回0


NAME

    THttpContent::getcontentdisposition, THttpContent::setcontentdisposition

    

SYNOPSIS

    TString THttpContent::getcontentdisposition()
    TInteger THttpContent::setcontentdisposition(TString content)


DESCRIPTION

    获得/设置Content-Disposition,在message header里边的Content-Disposition的
    内容。


ARGUMENTS

    content: 要设置的内容


RETURN

    setcontentdisposition如果返回值小于0，失败。其余成功。


EXAMPLES

    contObj.getcontentdisposition();

NAME

    THttpContent::getencodestyle, THttpContent::setencodestyle


SYNOPSIS

    TString THttpContent::getencodestyle()
    TInteger THttpContent::setencodestyle(TString s)


DESCRIPTION

    获得/设置消息头Content-Transfer-Encoding的内容


ARGUMENTS

    s: 要设置的值


RETURN

    setencodestyle失败返回-1，成功返回0


EXAMPLES

    

NAME

    THttpContent::getheadervalue, THttpContent::setheadervalue


SYNOPSIS

    TString THttpContent::getheadervalue(TString key)
    TInteger THttpContent::setheadervalue(TString key ,TString value)


DESCRIPTION

    getheadervalue获取扩展消息头的值
    serheadervalue设置扩展消息头的值


ARGUMENTS

    key: 消息头关键字的名字，比如Content-Type, Content-Length等

    value: 消息头关键字的值


RETURN

    getheadervalue返回关键字的值


EXAMPLES

    contSubObj3.setheadervalue('Content-Type','text/xml');
    assert(contSubObj3.getheadervalue('Content-Type')=='text/xml');

NAME

    THttpContent::writefile, THttpContent::readfile


SYNOPSIS

    TInteger THttpContent::writefile(TString filename)
    TInteger THttpContent::readfile(TString filename)


DESCRIPTION

    writefile用来写二进制文件，路径放在cin/webxml下，即把THttpContent的内
    容整个写到二进制文件中
    readfile读二进制文件，路径cin/webxml下的文件，writefile的逆函数，读后
    不做分析，直接得到THttpContent的树，然后可以做getcontenttype,getsubcount等
    操作


ARGUMENTS

    filename: 文件名


RETURN

    成功返回1，失败返回0


EXAMPLES

    contObj=new (THttpContent);
    ......
    contSubObj.setbuffer('text/plain','<vxml version="1.0"><form id="form1"
    ><block><prompt><audio src="10006.wav"/></prompt></block></form></vxml>
    ');
    itmp=contObj.insertsubbody('multipart/related',contSubObj);
    ......
    contObj.writefile('test.bin');
    contObj.readfile('test.bin');
    contObj.getcontenttype();
    

NAME

    THttpContent::parsebuf


SYNOPSIS

    TInteger THttpContent::parsebuf(TString content)


DESCRIPTION

    分析一个字符串，得到THttpContent的树，然后可以做getcontenttype,getsubcount等
    操作


ARGUMENTS

    content: 要分析的字符串


RETURN

    成功返回1，失败返回0


NAME

    TSCPTimer::settimer


SYNOPSIS

    TInteger TSCPTimer::settimer( TInteger t)


DESCRIPTION

    设置timer的时间，并同时启动timer。 settimer 当次有效，类似unix系统的
    alarm()，需要再次调用settimer()启动。


ARGUMENTS

    t: 设置的时间，当参数为0或小于0表示清除该timer，相当于调用timer.clean(
    ) 。


RETURN

    


EXAMPLES

    var TSCPTimer timer;
    timer = new TSCPTimer;
    timer.timeout([timeout]);
    timer.settimer(10);

NAME

    TSCPTimer::timeout


SYNOPSIS

    TInteger TSCPTimer::timeout([eventProcessLabel])


DESCRIPTION

    设置timer到达后要执行的业务逻辑片段的入口。
    要求该业务逻辑片断:
    1. 禁止中断
    2. 结束后使用return 返回


ARGUMENTS

    eventProcessLabel: 业务逻辑片段入口对应的sib的标识


RETURN

    


EXAMPLES

    var TSCPTimer timer;
    timer = new TSCPTimer;
    timer.timeout([timeoutproc]);
    timer.settimer(10);
    ...
    on([timeoutproc], TSCPTimer t)
    {
       // execute this part after 10 seconds
       // ...
    }

NAME

    TSCPTimer::clean


SYNOPSIS

    TInteger TSCPTimer::clean()


DESCRIPTION

    清除timer


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TSCPTimer timer;
    timer = new TSCPTimer;
    timer.timeout([timeout]);
    timer.settimer(10);
    ...
    timer.clean();

NAME

    TSCPChargeServer::addchargeclass


SYNOPSIS

    TInteger TSCPChargeServer::addchargeclass(TInteger c)


DESCRIPTION

    向TSCPChargeServer对象增加一个计费类别，可以反复的调用实现对多个计费
    类别同时计费，一个典型是移动计费时分为本地基本通话费、长途费、漫游费等
    等。目前一个TSCPChargeServer对象最多支持对10个chargeClass同时计费


ARGUMENTS

    c: 增加的chargeclass


RETURN

    


EXAMPLES

    var TSCPChargeServer ch1;
    ch1 = new TSCPChargeServer;
    ch1.addchargeclass(100);
    ch1.addchargeclass(101);
    ch1.addchargeclass(102);
    // 3 charging classes are set

NAME

    TSCPChargeServer::settimesupervision, setbalancesupervision


SYNOPSIS

    TInteger TSCPChargeServer::settimesupervision(TInteger t1, TInteger 
    t2, TInteger stopFlag)
    TInteger TSCPChargeServer::setbalancesupervision(TInteger c1, TInteger 
    t2, TInteger stopFlag)


DESCRIPTION

    设置呼叫监控，settimesupervision监控方式为时间监控，setbalancesupervision监
    控方式为呼叫费用监控


ARGUMENTS

    t1: 监控时间值

    c1: 监控费用值

    t2: 提前告警提示时间值，0表示不提前告警，如果非0，则必须通过onlimitwarning 
    函数设置回调入口。

    stopFlag: 表示当监控时间到达时底层程序是否自动停止计费（默认为自动停
    止计费）


RETURN

    


EXAMPLES

    // time supervision example
    void main()
    {
       var TSCPChargeServer ch1;
       ch1 = new TSCPChargeServer;
       ch1.addchargeclass(100);
       ch1.settimesupervision(300,30,1);
       ch1.onlimitwarning([playWarning]);
       // 表示300秒后底层程序自动停止计费，并在270秒时跳转到playWarning
    
       sleep(1000);
    
       on([playWarning])
       {
          // ...
       }
    }
    
    // balance supervision example
    void main()
    {
       var TSCPChargeServer ch1;
       ch1= new TSCPChargeServer;
       ch1.addchargeclass(100);
    
       // 设置呼叫监控费用为300分，限额到达后底层并不自动停止计费
       ch1. setbalancesupervision (300,30,0);
    
       // 限额到达前30秒跳转到 playWarning
       ch1.onlimitwarning([playWarning]);
    
       // 限额到达后跳转到playReached
       ch1.onlimitreached([playReached]);
    
       // 在这里，因为底层并不自动停止计费，所以必须调用onlimitreached
       // 函数设置限额到达时的业务逻辑入口，不然将只有在挂机处理中才有
       // 机会停止计费。
       // 在playReached开始的业务逻辑片断中，业务逻辑可以做一些处理，
       // 比如说放一条语音等，然后再切断通话，同时，业务逻辑还必须显式
       // 的调用stopcharge函数来停止计费。
    
       sleep(1000);
    
       on([playWarning])
       {
          // ...
       }
       on([playReached])
       {
          // ...
       }
    }

NAME

    TSCPChargeServer::startcharge


SYNOPSIS

    TInteger TSCPChargeServer::startcharge()


DESCRIPTION

    当业务逻辑已经设置好相关参数后，可以用这个函数来立即开始计费。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TSCPChargeServer ch1;
    ch1 = new TSCPChargeServer;
    ch1.addchargeclass(100);
    ch1.onstop([recACR]); //必须设置这个回调入口，这个入口用来处理话单
    ch1.startcharge(); //业务逻辑可以不设置呼叫监控，但必须设置计费类别

NAME

    TSCPChargeServer::stopcharge


SYNOPSIS

    TInteger TSCPChargeServer::stopcharge()


DESCRIPTION

    当呼叫结束后，如果底层没有自动停止计费的话，用这个函数来停止计费。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TSCPChargeServer ch1;
    ch1 = new TSCPChargeServer;
    ch1.addchargeclass(100);
    ch1.setbalancesupervision(300, 0, 0);
    
    // 限额到达后跳转到 stop 业务逻辑片断中
    ch1.onlimitreached([limitReach]);
    
    ch1.onstop([recACR]);
    ch1.startcharge();
    
    // ... 通常是连接通话
    
    //通常应该在 limitReach业务逻辑片断或挂机处理逻辑中
    ch1.stopcharge();

NAME

    TSCPChargeServer::getcrstartdate8andtime, getcrstopdate8andtime, getcrcallcost,
     getcrcallduration, getcrreason, getcrcallinfo


SYNOPSIS

    TString TSCPChargeServer::getcrstartdate8andtime()
    TString TSCPChargeServer::getcrstopdate8andtime()
    TInteger TSCPChargeServer::getcrcallcost()
    TInteger TSCPChargeServer::getcrcallduration()
    TInteger TSCPChargeServer::getcrreason()
    TString TSCPChargeServer::getcrcallinfo(TString infoname)


DESCRIPTION

    当TSCPChargeServer对象停止计费后，这组函数可以用来取得话单信息：
    getcrstartdate8andtime取得呼叫开始时间。
    getcrstopdate8andtime取得呼叫结束时间。
    getcrcallcost取得呼叫费用。
    getcrcallduration取得呼叫时长。
    getcrreason取得计费停止原因。
    getcrcallinfo取得某种呼叫信息


ARGUMENTS

    infoname: 信息的名字可以是：'startdate8andtime', 'stopdate8andtime',
     'cost', 'duration', 'reason'等


RETURN

    getcrstartdate8andtime和getcrstopdate8andtime是得到YYYYMMDDHHmmSS格式
    的字符串
    getcrcallcost得到整数形式的费用
    getcrcallduration得到整数形式的秒为单位的时长
    getcrreason得到计费停止原因，定义如下：
    1: chargeLimitReached
    2: recordClosedNotFinal
    3: recordCloseFinal
    4: timeLimitReached
    5: slpStopCharge


EXAMPLES

    var TString crStart = ch1.getcrstartdate8andtime();
    var TString crStop = ch1.getcrstopdate8andtime();
    var TInteger crcost = ch1.getcrcallcost();
    var TInteger crdur = ch1.getcrcallduration();
    var TInteger crrea = ch1.getcrreason();
    crstart = ch1.getcrcallinfo('startdate8andtime');
    crstop = ch1.getcrcallinfo('stopdate8andtime');
    crcost = ch1.getcrcallinfo('cost');
    crdur = ch1.getcrcallinfo('duration');
    crrea = ch1.getcrcallinfo('reason');

NAME

    TSCPChargeServer::onlimitwarning, onlimitreached, onstop


SYNOPSIS

    TInteger TSCPChargeServer::onlimitwarning([eventProcessLabel])
    TInteger TSCPChargeServer::onlimitreached([eventProcessLabel])
    TInteger TSCPChargeServer::onstop([eventProcessLabel])


DESCRIPTION

    在TSCPChargeServer对象开始计费之前，用这三个函数来设置收到对象自己抛
    出的limitwarning, limitreached和callinformationreport事件后的业务入口
    ，这些回调函数设置的业务逻辑片断必须用return返回


ARGUMENTS

    eventProcessLabel: 业务逻辑入口


RETURN

    


NAME

    TINESObj::init


SYNOPSIS

    TInteger TINESObj::init(TString inesname, TString fsmid='*')


DESCRIPTION

    初始化TINESObj，设置对端INES名字和对端自动机号。


ARGUMENTS

    inesname: 通信方标识，可以是:
    逻辑名，如果本端做客户端，对端INES是服务端
    注册名，如果本端做服务端，对端INES是客户端
    'FSM'，用于和其它自动机通信
    '*'或者'**'用于自环INES方式通信

    fsmid: 对方的自动机号，如果第一次发起会话还不知道对方的自动机号，填'
    *'，缺省为'*'。
    如果是新建TINESObj对象并且知道对方的自动机号，或者使用CorrelationKey方
    式，那么inesname参数不能使用'FSM'，并且fsmid参数需要这样填写：
    对直接自动机号方式，格式为xxyyyy，xx为2字节进程号，yyyy为自动机号
    CorrelationKey，格式为xxAyyyyyy，xx为2字节进程号，然后是字符A，然后是
    多字节CorrelationKey


RETURN

    


EXAMPLES

    var TINESObj inesobj;
    inesobj = new TINESObj;
    inesobj.init('INESC'); //本端做server，对端INES的注册名是INESC
    // ...
    inesobj.init('FSM');  //可以用init方法重新初始化该对象用于与FSM通信
    // ...

NAME

    TINESObj::synctoines, TINESObj::synctoines2


SYNOPSIS

    TString TINESObj::synctoines(TString msg, TInteger timer=10)
    TString TINESObj::synctoines2(TString msg, Integer timer=10)
    TInteger TINESObj::sendtoines(TString msg)


DESCRIPTION

    synctoines和synctoines2发送消息给对端INES，并禁止中断，同步等待对端响
    应。超时对端还未响应则抛出异常。几点说明：
    1. 因为自动机之间的通信协议与INES之间的通信协议不一样，所以不允许初始
    化TINESObj对象用于自动机通信，却实际用于与INES对象通信的情况。
    2. 当第一次发起会话请求时（对端FSMID为"*"），发送的消息必须由invokeservice开
    头，请求对端INES创建一个自动机进行通信。
    3. 调用synctoines后，底层收到了serviceEvent消息或fsmCommand消息后，会
    根据INES名称和自动机号等信息自动判断该消息是否是TINESObj对象所期待的响
    应，如果是则将消息扔给TINESObj处理；如果不是，serviceEvent消息被扔回消
    息队列，而对FSMCommand消息的处理则是SCFERROR后直接删除。
    4. synctoines2()函数与synctoines类似，只是该函数发送ines消息的源地址
    格式为myinstanceid:objectid ，响应消息的目的地址必须和发送的源地址相同
    才能被对象接收。
    
    sendtoined()发送消息给对端INES，不期待对端立刻返回结果。通常这个函数
    用于发送最后一条响应消息，通知对端结束本次会话。


ARGUMENTS

    msg: 需要发送的消息

    timer: 超时时间，缺省为10秒


RETURN

    synctoines和synctoines2返回完整的对端响应，底层未做任何截取


EXAMPLES

    var TINESObj inesobj;
    var TString response;
    inesobj = new TINESObj;
    inesobj.init('INESC');
    response=inesobj.synctoines('invokeservice 201 1', 5);
    ...
    repines=inesobj.synctoines('serviceevent the second msg');
    ...
    inesobj.sendtoines('serviceevent end session');
    ...

NAME

    TINESObj::synctofsm, TINESObj::sendtofsm


SYNOPSIS

    TInteger TINESObj::sendtofsm(TString msg)
    TString TINESObj::synctofsm(TString msg, TInteger timer)


DESCRIPTION

    synctofsm用于TINESObj发消息给其它自动机，并等待响应，与synctoines函数
    类似。第一次发起会话的时候，同样需要使用'invokeservice …'创建一个自动
    机。
    sendtofsm发送消息给其它自动机，不期待对端立刻返回结果。与sendtoines类
    似


ARGUMENTS

    msg: 需要发送的消息

    timer: 超时时间，缺省为10秒


RETURN

    synctofsm返回完整的对端响应，底层未做任何截取


EXAMPLES

    var TINESObj inesobj;
    var TString response;
    inesobj = new TINESObj;
    inesobj.init('FSM');
    response=inesobj.synctofsm('invokeservice 201 1', 5);
    ...
    repines=inesobj.synctofsm('serviceevent the second msg');
    ...
    inesobj.sendtofsm('serviceevent end session');
    ...

NAME

    TINESObj::clean


SYNOPSIS

    TInteger TINESObj::clean()


DESCRIPTION

    用于清空本次会话信息，准备发起新的会话。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TINESObj inesobj;
    var TString response;
    inesobj = new TINESObj;
    inesobj.init('FSM');
    response=inesobj.synctofsm('invokeservice 201 1', 5);
    inesobj.clean()
    response=inesobj.synctofsm('invokeservice 202 1', 5);
    …

NAME

    TFTPClient::init


SYNOPSIS

    TInteger TFTPClient::init(TString host, TInteger port, TString user,
     TString passwd)


DESCRIPTION

    初始化TFTPClient对象，初始化后只是在对象内部保存这些值，并不真正的连
    接到远端FTP服务器


ARGUMENTS

    host: 主机名（或者IP地址）

    port: 端口号

    user: 用户名，匿名用户用'anonymous'

    passwd: 用户口令，匿名用户用'a@b.com'


RETURN

    应该永远返回正确（即返回0）


EXAMPLES

    var TFTPClient ftp;
    ftp = new TFTPClient;
    ftp.init('ahost'，21，'user'，'password');

NAME

    TFTPClient::getfile


SYNOPSIS

    TInteger TFTPClient::getfile(TString rname, TString lname)


DESCRIPTION

    从FTP服务器上获得一个文件


ARGUMENTS

    rname: 远端文件名

    lname: 本地文件名。文件名可以使用绝对或者相对路径。对远端文件名来说，
    相对路径是指相对于FTP用户登录后起始位置的路径；对本地用户来说，相对路
    径是相对于程序启动位置的路径。路径上的每个目录都必须存在并有相应权限，
    否则函数执行失败。以下如不做特殊说明，关于文件或目录名的使用与本函数相
    同


RETURN

    


EXAMPLES

    var  TFTPClient ftp;
    ftp = new TFTPClient;
    ftp.init('ahost'，21，'user'，'password');
    ftp.getfile('sourceFile', 'destFile');

NAME

    TFTPClient::putfile


SYNOPSIS

    TInteger TFTPClient::putfile(TString lname, TString rname)


DESCRIPTION

    上传一个文件到FTP服务器上


ARGUMENTS

    lname: 本地文件名

    rname: 远端文件名


RETURN

    


EXAMPLES

    var TFTPClient ftp;
    ftp = new TFTPClient;
    ftp.init('ahost'，21，'user'，'password');
    ftp.putfile('sourceFile', 'destFile');

NAME

    TFTPClient::remove


SYNOPSIS

    TInteger TFTPClient::remove (TString filename)


DESCRIPTION

    删除FTP服务器上的某个文件


ARGUMENTS

    filename: 参数为待删除文件名


RETURN

    


EXAMPLES

    var TFTPClient ftp;
    ftp = new TFTPClient;
    ftp.init('ahost'，21，'user'，'password');
    ftp.remove('noUseFile');

NAME

    TFTPClient::rename


SYNOPSIS

    TInteger TFTPClient::rename(TString mame1, TString name2)


DESCRIPTION

    重命名FTP服务器上的某个文件


ARGUMENTS

    name1: 源文件名

    name2: 目标文件名


RETURN

    


EXAMPLES

    var TFTPClient ftp;
    ftp = new TFTPClient;
    ftp.init('ahost'，21，'user'，'password');
    ftp.rename('oldname'， 'newname');

NAME

    TFTPClient::getlastinfo


SYNOPSIS

    TString TFTPClient::getlastinfo()


DESCRIPTION

    获得服务器的最后一条返回信息。可以帮助确认以上函数执行失败的原因。


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TFTPClient ftp;
    var TString tmpStr;
    ftp = new TFTPClient;
    ftp.init('ahost'，21，'user'，'password');
    ftp.rename('oldname'， 'newname');
    tmpStr = ftp.getlastinfo();
    print(tmpStr)

NAME

    TFTPClient::listdir


SYNOPSIS

    TInteger TFTPClient::listdir(TString dirname)


DESCRIPTION

    列目录，需要在这个函数后再使用getlastinfo()才能获得文件名列表


ARGUMENTS

    dirname: 远端目录名


RETURN

    


EXAMPLES

    TFTPClient ftp;
    TString fileList;
    ftp = new TFTPClient;
    ftp.init('ahost'，21，'user'，'password');
    ftp.listdir('dirname');
    fileList = ftp.getlastinfo(); // get the file list string
    print(fileList)

NAME

    TTelnetClient::init


SYNOPSIS

    TInteger TTelnetClient::init(TString host, TInteger port, TInteger type)
    


DESCRIPTION

    初始化TTelnetClient对象


ARGUMENTS

    host: 主机名

    port: 端口号

    type: 0不使用二进制方式，1使用二进制方式


RETURN

    


NAME

    TTelnetClient::receive


SYNOPSIS

    TString TTelnetClient::receive()


DESCRIPTION

    从telnet服务器获取信息。因为直到目前为止，仍为发现一个有效的判断服务
    器返回结果结束的办法，因此底层只做了一个简单的判断（select超时就认为对
    端返回结束）。可能需要在业务逻辑层里做一些判断以保证得到了所有的返回结
    果。


ARGUMENTS

    无

RETURN

    接收到的字符串


NAME

    TTelnetClient::send


SYNOPSIS

    TInteger TTelnetClient::send(TString msg)


DESCRIPTION

    向服务器端发送信息。底层会自动在每个发送字符串后面添加0D 0A。如果在今
    后的测试中发现有问题的话，可能会不自动添加，改成由业务逻辑控制。


ARGUMENTS

    msg: 要发送的消息


RETURN

    


EXAMPLES

    #progma c
    void main()
    {
       var TString tmpStr;
       var TInteger tmpInt;
       var TTelnetClient telnetClient;
    
       telnetClient=new TTelnetClient;
       telnetClient.init('192.168.2.205', 23);
       sleep(1);  // wait for server
       tmpStr=telnetClient.receive();
       print(tmpStr);
       tmpInt=telnetClient.send('wenyx');
       tmpStr=telnetClient.receive();
       print(tmpStr);
       telnetClient.send('*****');
       tmpStr=telnetClient.receive();
       print(tmpStr);
       telnetClient.send('vmstat 1');
       tmpStr=telnetClient.receive();
       print(tmpStr);
       tmpStr=sprintf('\03');   // send ctrl-C, can interrupt the vmstat 
    command
       telnetClient.send(tmpStr);
       sleep(3);
       tmpStr=telnetClient.receive();
       print(tmpStr);
    }

NAME

    encodeoid, decodeoid


SYNOPSIS

     TString  decodeoid(TString s)
    TString  encodeoid(TString s)


DESCRIPTION

    用于对object  identifier类型进行编解码，该类型是ASN.1的基本类型之一。
    


ARGUMENTS

    s: 要编码或者解码的字符串


RETURN

    编码或者解码的结果


EXAMPLES

    assert(encodeoid('1.3.12.2.1107.3.3.0.0.4') == 'B2C02088353030000040'
    );
    assert(decodeoid('B2C02088353030000040') == '1.3.12.2.1107.3.3.0.0.4'
    );

NAME

    asnvalue, asnrawvalue


SYNOPSIS

    TString asnvalue( tagpath, TString defaultValue)
    TInteger asnvalue( tagpath, TInteger defaulValue)
    TString asnrawvalue ( tagpath )


DESCRIPTION

    该函数用于根据tagpath所规定的路径取到ASN的值。


ARGUMENTS

    tagpath: ANS.1参数取值路径

    defaultValue: 如果路径不存在，返回缺省值


RETURN

    asnvalue根据数据类型的不同取到的是解码后的值，可以设置缺省值用于tagpath无
    效的情况，asnrawvalue取到的是解码之前的原始值，肯定是字符串形式。


EXAMPLES

    i = asnvalue(<<inap.invoke.promptandcollectuserinformation.collectedinfo.
    
         collecteddigits.interruptableannind>>,-2)
    s = asnrawvalue(<<inap.invoke.promptandcollectuserinformation.collectedinfo.
    
          collecteddigits.interruptableannind>>)

NAME

    set asn handle


SYNOPSIS

    ASNHandle = TagPath


DESCRIPTION

    这个功能的作用是，简化长路径的书写，设置的一个路径可以多次重用。这个
    函数不能直接调用，而是使用赋值语句进行操作


ARGUMENTS

    ASNHandle: 等号左边是一个ASNHandle

    TagPath: 等号右边是一个ASN.1参数取值路径


RETURN

    


EXAMPLES

    var <<inap.invoke.PromptAndCollectUserInformation.informationToSend>
    > itsHandle;
    itsHandle = <<inap.invoke.PlayAnnouncement.informationToSend>>
    i = asnvalue(<<$itsHandle.inbandinfo.numberOfRepetitions>>)

NAME

    TASNObject::TASNObject


SYNOPSIS

    TASNObject::TASNObject(TInteger opID, TString para)


DESCRIPTION

    根据指定的操作ID和操作的参数，创建一个完整的TASNObject对象，这个创建
    的对象的内部结构与使用TTCAPDialogue::getasnobj得到的对象是一致的，可以
    用同样的方法进行操作


ARGUMENTS

    opID: 整数，操作码

    para: 字符串，ASC格式的参数ASN.1编码，例如ASN.1编码为30 03 80 01 01，
    那么这个串是'0330081010'


RETURN

    构造好的TASNObject的handle


EXAMPLES

    var TASNObject a;
    var TString s;
    a = new TASNObject(48,'08500212345670');
    s = a.asnvalue(<<inap.result.receivedinformation.digitsresponse>>,'NULL'
    );
    assert(s == '1234567');

NAME

    TASNObject::getcode


SYNOPSIS

    TString TASNObject::getcode()


DESCRIPTION

    取得一个ASN对象的编码的ASC形式


ARGUMENTS

    无

RETURN

    ASC格式的编码，例如ASN.1编码为30 03 80 01 01，那么这个串是'0330081010'
    


EXAMPLES

    var TASNObject a;
    var TString s;
    a = new TASNObject(48,'08500212345670');
    s = a.getcode();
    assert(s == '08500212345670');

NAME

    TASNObject::asnvalue, TASNObject::asnrawvalue


SYNOPSIS

    TString TASNObject::asnvalue( tagpath, TString default)
    TInteger TASNObject::asnvalue( tagpath, TInteger default)
    TString TASNObject::asnrawvalue ( tagpath )


DESCRIPTION

    该函数用于根据tagpath所规定的路径取到ASN的值。asnvalue根据数据类型的
    不同取到的是解码后的值，可以设置缺省值用于tagpath无效的情况，asnrawvalue取
    到的是解码之前的原始值，肯定是字符串形式。


ARGUMENTS

    tagpath: ANS.1参数取值路径

    default: 如果路径不存在，返回缺省值


RETURN

    取到的结果，整数或者字符串


EXAMPLES

    // For example, this logic is invoked by INAP IDP...
    void main(TTCAPDialogue t)
    {
       var TASNObject a;
       var TString s;
       var TInteger i;
       a = t.getasnobj();
       s = a.asnvalue(<<inap.invoke.initialdp.calledPartyNumber>>,'NULL'
    );
       i = a.asnvalue(<<inap.invoke.initialdp.serviceKey>>,-1);
       s = a.asnrawvalue(<<inap.invoke.initialdp.serviceKey>>);
       ...
    }

NAME

    TASNObject::addvalue, TASNObject::addobject


SYNOPSIS

    TInteger TASNObject::addvalue(TString value, TInteger type, TInteger 
    tag)
    TInteger TASNObject::addobject(TASNObject objectid, TInteger tag)


DESCRIPTION

    这两个函数用来构造一个ASN编码，构造之后的对象和前面提到的对象有区别，
    并没有树形结构，仅仅是编码，不能用tag path取值。addvalue在自身编码之后
    追加一个编码的值，addobject在对象本身编码之后追加另一个对象的编码的值
    


ARGUMENTS

    value: 要追加的参数的值，必须是一个基本类型的值

    type: 要追加的参数的type:
    5: 只编tag和长度0，value不处理，允许为空串
    2: 将value转换为整数编码
    4: 将value按照字符串原样编码
    254: 将value转换为BCD码，如果是奇数位，补F
    255: 将value转换为BCD码，如果是奇数位，补0

    tag: 要追加的参数的tag，这个必须是ASN.1编码之后的实际tag

    objectid: 要追加的对象的handle


RETURN

    返回0代表成功，其余代表失败


EXAMPLES

    var TASNObject a,b,c;
    
    a = new TASNObject;
    a.addvalue('1234',4,0x80);  // a: 80 04 31 32 33 34
    a.addvalue('1234',4,0x81);  // a: 80 04 31 32 33 34 81 04 31 32 33 34
    b = new TASNObject;
    b.addobject(a,0xA0); // b: A0 0C 80 04 31 32 33 34 81 04 31 32 33 34
    b.addobject(a,0xA1);
    // b:
    // A0 0C 80 04 31 32 33 34 81 04 31 32 33 34 A1 0C 80 04 31 32 33 34
       81 04 31 32 33 34
    c = new TASNObject;
    c.addobject(b,0x30);
    // c:
    // 30 1C A0 0C 80 04 31 32 33 34 81 04 31 32 33 34 A1 0C 80 04 31 32
       33 34 81 04 31 32 33 34
    assert(c.getcode() == '03C10AC00840132333431840132333431AC0084013233343184013233343'
    );

NAME

    TSoap::init


SYNOPSIS

    TInteger TSoap::init(TString xmlns,int isIncludeHeader,TString pi=''
    )


DESCRIPTION

    初始化soap消息，一个含有Envelope,Header,Body的简单xml对象，设置了soap的
    命名空间(该变量为env)，设置了方法定义的命名空间（该命名空间为缺省的命
    名空间）。


ARGUMENTS

    xmlns: 指方法的命名空间对应的wsdl的url地址

    isIncludeHeader: 是否包含header,1，包含，0，不包含

    pi: xml的processInstruction,如果为''那么pi为<?xml version="1.0" encoding=
    "UTF-8"?>


RETURN

    返回值小于0，失败，否则成功。


EXAMPLES

    var TSoap s = new TSoap;
    s.init('', 0);
    assert(s.tostr()=='<?xml version="1.0" encoding="UTF-8"?><env:Envelope 
    xmlns:env=
    "http://schemas.xmlsoap.org/soap/envelope/"><env:Body></env:Body></env:
    Envelope>');

NAME

    TSoap::tostr


SYNOPSIS

    TString TSoap::tostr()


DESCRIPTION

    将soap对象转化为字符串，与TXMLTree::tostr()不同的是，转换接过会包含XML的
    process instruction


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TSoap soapObj;
    soapObj = new TSoap;
    soapObj.init('', 1);
    var TString ssoap;
    ssoap = soapObj.tostr();

NAME

    TSoap::getdetail, TSoap::addfault


SYNOPSIS

    TString TSoap::getdetail()
    TInteger TSoap::addfault(TString faultcode, TString faultstring, TString 
    detail)


DESCRIPTION

    如果解析失败，则需要调用addfault()构造fault消息发送到对端
    如果需要设置fault当中的detail，那么该内容通过调用getdetail()数获得。
    即soap的body中的内容。


ARGUMENTS

    faultcode: 根据具体协议具体定义

    faultstring: 根据具体协议具体定义

    detail: 可选参数，如果为空，则fault中不包含detail。Detail一般是从getdetail获
    得


RETURN

    addfault()返回值小于0，失败，否则成功


NAME

    TSoap::setcurrentpath


SYNOPSIS

    TInteger TSoap::setcurrentpath(TString path)


DESCRIPTION

    设置当前的路径


ARGUMENTS

    path: Envelope开始的绝对路径。以后的取值赋值操作，都是从当前的节点开
    始。


RETURN

    返回值小于0，失败，否则成功。


EXAMPLES

    var TSoap s = new TSoap;
    s.init('',0);
    s.addchild('a', '123', 'Body');
    assert(s.tostr()=='<?xml version="1.0" encoding="UTF-8"?><env:Envelope 
    xmlns:env=
    "http://schemas.xmlsoap.org/soap/envelope/"><env:Body><a>123</a></env:
    Body></env:
    Envelope>');
    s.setcurrentpath('Envelope/Body');
    assert(s.getvalue('a') == '123');
    s.setcurrentpath('Envelope');
    assert(s.getvalue('Body/a') == '123');

NAME

    TSoap::getsubcount, TSoap::getsubname


SYNOPSIS

    TInteger TSoap::getsubcount(TString path)
    TString TSoap::getsubname(TInteger index, TString path)


DESCRIPTION

    getsubcount()获得path对应节点子节点的数量
    getsubname获得path对应节点的某个子节点的名称。


ARGUMENTS

    path: 路径应该从setcurrentpath后的路径开始，标签不包含setcurrentpath后
    的标签，应该是从它的下一级开始，如果path为'',则为setcurrentpath得到的
    节点

    index: 指第几个字节点，第一个节点index从0 开始。


RETURN

    返回值小于0，失败，否则返回子节点的数量。


EXAMPLES

    ssubname = soapObj.getsubname(0,'third');
    assert(ssubname == 'third1');
    print('a third subname:'+ssubname);
    ssubname = soapObj.getsubname(1,'third');
    assert(ssubname == 'third2');
    print('a third subname2:'+ssubname);
    
    isubcount = soapObj.getsubcount('third');
    assert(isubcount == 3);

NAME

    TSoap::getvalue, TSoap::getattrvalue


SYNOPSIS

    TString TSoap::getvalue(TString path)
    TString TSoap::getattrvalue(TString attrName, TString path)


DESCRIPTION

    getvalue获得path对应节点的值
    getattrvalue获得path对应节点某个属性的值


ARGUMENTS

    path: 同getsubcount的path


RETURN

    


EXAMPLES

    ssoapattrvalue = soapObj.getattrvalue('attr1 ','');
    assert(ssoapattrvalue == 'get');
    
    ssoapvalue = soapObj.getvalue('first');
    assert(ssoapvalue == '123');

NAME

    TSoap::getxmlns, getattrxmlns, getxmlnsvalue


SYNOPSIS

    TString TSoap::getxmlns(TString path)
    TString TSoap::getattrxmlns(TString attrName, TString path)
    TString TSoap::getxmlnsvalue(TString prefix)


DESCRIPTION

    getxmlns获得path对应节点的命名空间的前缀
    getattrxmlns获得path对应节点某个属性的命名空间的前缀
    getxmlnsvalue获得命名空间前缀对应的值


ARGUMENTS

    path: 同getsubcount的path

    attrName: 属性的名称，如果属性名称中包含命名空间的前缀，则AttrName的
    值不包含该前缀

    prefix: 如果prefix为NULL,则得到缺省的命名空间的前缀。


RETURN

    


EXAMPLES

    var TSoap s = new TSoap;
    s.init('',0);
    s.addattr('env:a', '123', 'Body');
    assert(s.tostr()=='<?xml version="1.0" encoding="UTF-8"?><env:Envelope 
    xmlns:env=
    "http://schemas.xmlsoap.org/soap/envelope/"><env:Body env:a="123"></
    env:Body></en
    v:Envelope>', s.tostr());
    assert(s.getxmlns('Body')=='env', s.getxmlns('Envelope'));
    assert(s.getattrxmlns('a', 'Body')=='env', s.getattrxmlns('a', 'Body'
    ));
    assert(s.getxmlnsvalue('env')=='http://schemas.xmlsoap.org/soap/envelope/
    ');

NAME

    TSoap::addchild, TSoap::addattr


SYNOPSIS

    TInteger TSoap::addchild(TString name,TString value, TString path)
    TInteger TSoap::addattr(TString attrName,TString value, TString path)
    


DESCRIPTION

    addchild为path对应的节点填加一个子节点
    addattr为path对应的节点填加一个属性


ARGUMENTS

    name: 添加的名称，如果有命名空间，包含前缀。

    value: 填加的值，如果没有写成空

    path: 同getsubcount的path。


RETURN

    返回值小于0失败，否则成功


EXAMPLES

    soapObj.addchild('third2','two','Body/third');
    soapObj.addchild('third2','three','Body/third');
    soapObj.addattr('env:attr1','get','Body');

NAME

    TCorbaServer::getoperation


SYNOPSIS

    TString TCorbaServer::getoperation()


DESCRIPTION

    获得请求的方法的名称。


ARGUMENTS

    无

RETURN

    


NAME

    TCorbaServer::getargvalue


SYNOPSIS

    TString TCorbaServer::getargvalue(TString argName)


DESCRIPTION

    获得参数的值


ARGUMENTS

    argName: 参数的名称。如果参数是struct等复杂类型，父项的名称与子项的名
    称用"/"符号隔开，如果是sequence类型的参数，在名称后边加 "[index]"获得
    每项的值,index可以是整数，也可以是整数类型的CCB。


RETURN

    


NAME

    TCorbaServer::getarraysize


SYNOPSIS

    TInteger TCorbaServer::getarraysize(TString argName)


DESCRIPTION

    当遇到sequence类型的参数时，该函数获得sequence的size


ARGUMENTS

    argName: 参数的名称


RETURN

    


NAME

    TCorbaServer::setreturnvalue


SYNOPSIS

    TInteger TCorbaServer::setreturnvalue(TString argName, TString argValue)
    


DESCRIPTION

    如果request消息调用的方法不是one-way类型，我们需要返回一个reply消息到
    对端，该函数是设置参数的值。


ARGUMENTS

    argName: 参数的名称，如果是返回值，那么argName应该为return,否则，应该
    与调用函数的参数名一致

    argValue: 要设置的值。注意,返回reply,只有out或in-out类型的参数才有效
    ，in类型的只在请求消息时起作用


RETURN

    返回值0代表成功，其余代表失败


NAME

    TCorbaServer::setreturnarraysize


SYNOPSIS

    TInteger TCorbaServer::setreturnarraysize(TString argName, TInteger 
    size)


DESCRIPTION

    当遇到sequence类型的参数时，该函数设置sequence的size.如果该size比原来
    的小，则删除多余的项目，如果大，则添加项目。


ARGUMENTS

    argName: 参数的名称

    size: 要设定的大小


RETURN

    返回值0代表成功，其余代表失败。


NAME

    TCorbaServer::reply


SYNOPSIS

    TInteger TCorbaServer::reply()


DESCRIPTION

    发送reply消息到对端。


ARGUMENTS

    无

RETURN

    返回值0代表成功，其余代表失败。


NAME

    TCorbaServer::selectuserexcep


SYNOPSIS

    TInteger TCorbaServer::selectuserexcep (TString name)


DESCRIPTION

    选择一个用户异常，发送到对端。


ARGUMENTS

    name: 操作定义的异常的名称。


RETURN

    返回值0代表成功，其余代表失败。


NAME

    TCorbaServer::getchoicevalue


SYNOPSIS

    TString TCorbaServer::getchoicevalue(TString argName)


DESCRIPTION

    获得union类型的当前的选择的条目


ARGUMENTS

    argName: 参数的路径


RETURN

    


NAME

    TCorbaServer::getoctetsvalue


SYNOPSIS

    TString TCorbaServer::getoctetsvalue(TString argName)


DESCRIPTION

    收到消息时，当argName的类型是sequence(char)或sequence(octet)时，getoctetsvalue用
    来获得整个array的值。注意，此时getarraysize继续有效。


ARGUMENTS

    argName: 参数的路径


RETURN

    


NAME

    TCorbaServer::argtoxml


SYNOPSIS

    TString TCorbaServer::argtoxml()


DESCRIPTION

    收到的参数转化为xml字串。


ARGUMENTS

    无

RETURN

    格式为<opname><arg1>…</arg1></opname>。


NAME

    TCorbaServer::setreturnchoicevalue


SYNOPSIS

    TInteger TCorbaServer::setreturnchoicevalue(TString argName,TString 
    value)


DESCRIPTION

    发送消息时，如果argName对应的参数为union,用来设置union的case值。


ARGUMENTS

    argName: 参数的路径

    value: 设置的值


RETURN

    


NAME

    TCorbaServer::setreturnoctetsvalue


SYNOPSIS

    TInteger TCorbaServer::setreturnoctetsvalue(TString argName,TString 
    value)


DESCRIPTION

    发送消息时，当argName对应的参数类型为sequence时，且每个单元为char,或
    octet,此函数用于设置整个buffer。


ARGUMENTS

    argName: 参数的路径

    value: 设置的值


RETURN

    


NAME

    corbaiormatch


SYNOPSIS

    TInteger corbaiormatch (TString ior,TString key)


DESCRIPTION

    如果参数是interface类型，当收到一个ior时，要知道该ior是哪个interface生
    成的，要调用此函数


ARGUMENTS

    Ior: 收到的具体消息

    key: 比较的关键字，一般应该是一个interface的名称或一个interface对应的
    typeid


RETURN

    返回值0代表匹配，其余不匹配。


NAME

    corbacreatior


SYNOPSIS

    TString corbacreatior(TString idlpath, TInteger port)


DESCRIPTION

    创建临时IOR,即corba server创建一个临时对象的引用。当业务结束时，生成
    的ior自动失效。


ARGUMENTS

    idlpath: interface的路径

    port: corba server打开的socket的端口号


RETURN

    


NAME

    TCorbaClient::setior


SYNOPSIS

    TInteger TCorbaClient::setior(TString iorContent)


DESCRIPTION

    当向corba server发送消息时，必须先得到对端的object key, corba version,
     IP, port等信息，而这些信息都是保存在corba server提供的ior文件里，因此
    要想往corbaserver发送请求消息，系统必须先得到这些值，也就是先要执行serior这
    个函数。


ARGUMENTS

    iorContent: 可以是一个ior文件，也可以是ior的内容，当iorContent的值前
    四个字符为"IOR:"时，认为是ior的内容，否则认为是文件。Ior的文件必须放在
    cin/corba目录里边。


RETURN

    返回值0代表成功，其余代表失败。


NAME

    TCorbaClient::selectoperation


SYNOPSIS

    TInteger TCorbaClient::selectoperation(TString idlPath)


DESCRIPTION

    选择一个操作


ARGUMENTS

    idlPath: 必须是合法的idl路径


RETURN

    


NAME

    TCorbaClient::setargvalue


SYNOPSIS

    TInteger TCorbaClient::setargvalue(TString argName,TString argValue)
    


DESCRIPTION

    设置参数的值


ARGUMENTS

    argName: 参数的名称

    argValue: 要设置的值。注意,发送请求消息,只有in或inout类型的参数才有效
    ，out类型的只在响应消息时起作用


RETURN

    返回值0代表成功，其余代表失败。


NAME

    TCorbaClient::setarraysize


SYNOPSIS

    TInteger TCorbaClient::setarraysize(TString argName, TInteger size)

    

DESCRIPTION

    当遇到sequence类型的参数时，该函数设置sequence的size.如果该size比原来
    的小，则删除多余的项目，如果大，则添加项目


ARGUMENTS

    argName: 参数的名称

    size: 是要设定的大小


RETURN

    返回值0代表成功，其余代表失败


NAME

    TCorbaClient::request


SYNOPSIS

    TInteger TCorbaClient::request()


DESCRIPTION

    发送请求消息


ARGUMENTS

    无

RETURN

    返回值0代表成功，其余代表失败


NAME

    TCorbaClient::getreturnstatus


SYNOPSIS

    TString TCorbaClient::getreturnstatus()


DESCRIPTION

    获得相应消息的状态描述


ARGUMENTS

    无

RETURN

    有以下几种:
    NO_EXCEPTION ：操作成功
    USER_EXCEPTION：用户异常
    SYSTEM_EXCEPTION：系统异常
    


NAME

    TCorbaClient::getreturnvalue


SYNOPSIS

    TString TCorbaClient::getreturnvalue(TString argName)


DESCRIPTION

    获得返回的消息的out,inout类型即返回值


ARGUMENTS

    argName: 参数的名称，如果是返回值，则argName的值是return


RETURN

    


NAME

    TCorbaClient::getreturnarraysize


SYNOPSIS

    TInteger TCorbaClient::getreturnarraysize (TString argName)


DESCRIPTION

    当返回的参数遇到sequence类型的参数时，该函数获得sequence的size


ARGUMENTS

    argName: 参数的名称


RETURN

    


NAME

    TCorbaClient::getexception


SYNOPSIS

    TString TCorbaClient::getexception()


DESCRIPTION

    获得系统异常，用户异常的信息。


ARGUMENTS

    无

RETURN

    


NAME

    TCorbaClient::getreturnchoicevalue


SYNOPSIS

    TString TCorbaClient::getreturnchoicevalue (TString argName)


DESCRIPTION

    获得union类型的当前的选择的条目


ARGUMENTS

    argName: 参数的路径


RETURN

    


NAME

    TCorbaClient::getreturnoctetsvalue


SYNOPSIS

    TString TCorbaClient::getreturnoctetsvalue(TString argName)


DESCRIPTION

    收到消息时，当argName对应的参数类型为sequence时，且每个单元为char,或
    octet,此函数用于获得整个buffer。


ARGUMENTS

    argName: 参数的路径


RETURN

    


NAME

    TCorbaClient::argtoxml


SYNOPSIS

    TString TCorbaClient::argtoxml()


DESCRIPTION

    收到的参数转化为xml字串


ARGUMENTS

    无

RETURN

    格式为<opname><arg1>…</arg1></opname>


NAME

    TCorbaClient::setchoicevalue


SYNOPSIS

    TInteger TCorbaClient::setchoicevalue(TString argName,TString value)
    


DESCRIPTION

    发送消息时，如果argName对应的参数为union,用来设置union的case值。


ARGUMENTS

    argName: 参数的名称

    value: 要设置的值


RETURN

    


NAME

    TCorbaClient::setoctetsvalue


SYNOPSIS

    TInteger TCorbaClient::setoctetsvalue(TString argName,TString value)
    


DESCRIPTION

    发送消息时，当argName对应的参数类型为sequence时，且每个单元为char,或
    octet,此函数用于设置整个buffer。


ARGUMENTS

    argName: 参数的名称

    value: 要设置的值


RETURN

    


NAME

    TSipMsg::printtree


SYNOPSIS

    TInteger TSipMsg::printtree()


DESCRIPTION

    打印消息转换为XML格式的树的内容


ARGUMENTS

    无

RETURN

    0成功，－1失败


NAME

    TSipMsg::send


SYNOPSIS

    TInteger TSipMsg::send(TString protocol='[response]')


DESCRIPTION

    发送SIP消息


ARGUMENTS

    protocol: 如果是发送请求消息，需要这个参数。如果是发送响应消息，则不
    需要这个参数


RETURN

    0成功，－1失败


NAME

    TSipMsg::getres


SYNOPSIS

    TSipMsg TSipMsg::getres(TInteger resCode)


DESCRIPTION

    从请求对象中构造响应消息对象。一般来说，在收到一个reqMsg请求后，业务
    逻辑需要调用这个函数根据请求消息构造一个响应消息发送给请求方。
    注：在得到响应消息后，对于UA用户（MS，sipphone），对于180，200的响应
    中的Contact必须自己设置。


ARGUMENTS

    resCode: 要构造的响应消息的响应码


RETURN

    得到的响应消息


EXAMPLES

    void main(TSipMsg req)
    {
       var TSipMsg res;
       res = req.getres(100);
       ...
    }

NAME

    TSipMsg::createcallleg


SYNOPSIS

    TSipCallLeg TSip::createcallleg()


DESCRIPTION

    在SIP业务逻辑开始或收到SIP消息后，调用该函数可以构造一个相应的TSipCallLeg对
    象处理来自该SIP消息发送方的其它相关消息。


ARGUMENTS

    无

RETURN

    返回的TSipCallLeg对象的handle


EXAMPLES

    void main(TSipMsg req)
    {
       var TSipCallLeg oleg;
       oleg = req.createcallleg(req);
       ...
    }

NAME

    TSipMsg::createcallsegment


SYNOPSIS

    TSipCallSegment TSipMsg::createcallsegment()


DESCRIPTION

    在SIP业务逻辑开始或收到SIP消息后，调用该函数可以构造一个相应的TSipCallSegment对
    象来处理请求。


ARGUMENTS

    无

RETURN

    返回的TSipCallSegment对象的handle


EXAMPLES

    void main(TSipMsg req)
    {
       var TSipCallSegment cs;
       cs = req.createcallsegment();
       ...
    }

NAME

    TSipMsg::getlocalport


SYNOPSIS

    TString TSipMsg::getlocalport()


DESCRIPTION

    取得接收请求消息的本地SIP SERVER服务端口号


ARGUMENTS

    无

RETURN

    端口号的字符串


NAME

    TSipMsg::getmethod


SYNOPSIS

    TString TSipMsg::getmethod()


DESCRIPTION

    获得SIP消息的方法, 取得的类型都为大写的字符串。如INVITE、BYE、ACK等

    

ARGUMENTS

    无

RETURN

    字符串类型的方法名称


EXAMPLES

    /* For example:
    INVITE sip:7434@10.20.200.227:5060 SIP/2.0
    Call-ID: 7764053628133e4b65b609e7160e555e@10.20.200.227
    From: <sip:07312910430@10.20.200.227:5060>;tag=00143-0b1006b1010684d6
    ...
    */
    void main(TSipMsg req)
    {
       assert(req.getmethod() == 'INVITE');
    }

NAME

    TSipMsg::getcontent, TSipMsg::setcontent


SYNOPSIS

    TString TSipMsg::getcontent()
    TInteger TSipMsg::setcontent(TString content)


DESCRIPTION

    获得/设置SIP消息的消息体的内容


ARGUMENTS

    content: 要设置的SIP消息体的内容


RETURN

    setcontent返回0成功，-1失败。getcontent返回字符串类型的消息体内容


EXAMPLES

    /* For example:
    INVITE sip:7434@10.20.200.227:5060 SIP/2.0
    Call-ID: 7764053628133e4b65b609e7160e555e@10.20.200.227
    From: <sip:07312910430@10.20.200.227:5060>;tag=00143-0b1006b1010684d6
    ...
    P-Asserted-Identity: <sip:07312910430@10.20.201.5>
    Supported: 100rel,timer,diversion
    
    v=0
    o=- 1 1 IN IP4 10.20.200.227
    s=-
    c=IN IP4 10.20.201.168
    t=0 0
    m=audio 30000 RTP/AVP 8
    a=rtpmap:8 PCMA/8000
    a=ptime:20
    */
    void main(TSipMsg req)
    {
       assert(req.getcontent() == 'v=0
    o=- 1 1 IN IP4 10.20.200.227
    s=-
    c=IN IP4 10.20.201.168
    t=0 0
    m=audio 30000 RTP/AVP 8
    a=rtpmap:8 PCMA/8000
    a=ptime:20
    ');
    }

NAME

    TSipMsg::getheader, TSipMsg::setheader


SYNOPSIS

    TString TSipMsg::getheader(TString path)
    TInteger TSipMsg::setheader(TString path, TString value)


DESCRIPTION

    获得/设置SIP消息头的某个字段的内容


ARGUMENTS

    path: 字段的路径

    value: 要设置的字段的值


RETURN

    对于getheader返回字符串类型的消息头字段的内容。对于setheader返回0表示
    成功，-1表示失败


EXAMPLES

    /* For example:
    INVITE sip:7434@10.20.200.227:5060 SIP/2.0
    Call-ID: 7764053628133e4b65b609e7160e555e@10.20.200.227
    From: <sip:07312910430@10.20.200.227:5060>;tag=00143-0b1006b1010684d6
    To: <sip:7434@10.20.200.227:5060>
    CSeq: 1 INVITE
    Via: SIP/2.0/UDP 10.20.200.227:9060;branch=z9hG4bK13884222
    Max-Forwards: 30
    Contact: <sip:10.20.200.227:9060>
    Content-Type: application/sdp
    Content-Length: 130
    Route: <sip:10.20.200.227:5090;call=orig;lr>
    P-Asserted-Identity: <sip:07312910430@10.20.201.5>
    Supported: 100rel,timer,diversion
    ...
    */
    void main(TSipMsg req)
    {
       assert(req.getheader('Supported') == '100rel,timer,diversion');
       assert(req.getheader('From/tag') == '00143-0b1006b1010684d6');
       req.setheader('Contact','<sip:192.168.2.235:14550>');
       assert(req.getheader('Contact') == '<sip:192.168.2.235:14550>');
    }

NAME

    TSipMsg::getrequesturl, TSipMsg::geturladdr, TSipMsg::geturlnum


SYNOPSIS

    TString TSipMsg::getrequesturl()
    TString TSipMsg::geturladdr()
    TString TSipMsg::geturlnum()


DESCRIPTION

    getrequesturl获得请求对象的请求URL，geturladdr则仅获得这个URL的地址部
    分，geturlnumber则仅获得这个URL的地址部分中的用户名部分


ARGUMENTS

    无

RETURN

    字符串，URL或者URL地址或者URL地址中的用户名


EXAMPLES

    /* For example:
    INVITE sip:7434@10.20.200.227:5060;play=222.wav;user=phone SIP/2.0
    ...
    */
    void main(TSipMsg req)
    {
       assert(req.getrquesturl() == 'sip:7434@10.20.200.227:5060;play=222.
    wav;user=phone');
       assert(req.geturladdr() == 'sip:7434@10.20.200.227:5060');
       assert(req.geturlnum() == '7434');
    }

NAME

    TSipMsg::getviabranch


SYNOPSIS

    TString TSipMsg::getviabranch()


DESCRIPTION

    得到第一个Via头的branch字段


ARGUMENTS

    无

RETURN

    branch值


EXAMPLES

    /* For example:
    INVITE sip:7434@10.20.200.227:5060 SIP/2.0
    Call-ID: 7764053628133e4b65b609e7160e555e@10.20.200.227
    From: <sip:07312910430@10.20.200.227:5060>;tag=00143-0b1006b1010684d6
    To: <sip:7434@10.20.200.227:5060>
    CSeq: 1 INVITE
    Via: SIP/2.0/UDP 10.20.200.227:9060;branch=z9hG4bK13884222
    Max-Forwards: 30
    ...
    */
    void main(TSipMsg req)
    {
       assert(req.getviabranch() == 'z9hG4bK13884222');
    }

NAME

    TSipMsg::getfromtag, TSipMsg::setfromtag, TSipMsg::gettotag, TSipMsg:
    :settotag


SYNOPSIS

    TString TSipMsg::getfromtag()
    TInteger TSipMsg::setfromtag(TString tagValue)
    TString TSipMsg::gettotag()
    TInteger TSipMsg::settotag(TString tagValue)


DESCRIPTION

    取得/设置消息头中From或者To参数的tag值，tag值之的是From或者To参数行的
    "tag="之后的内容


ARGUMENTS

    tagValue: 要设置的tag的值


RETURN

    对于getfromtag和gettotag返回From中的tag的值，对于setfromtag和settotag，
    返回0表示成功，-1表示失败


EXAMPLES

    /* For example:
    INVITE sip:7434@10.20.200.227:5060 SIP/2.0
    Call-ID: 7764053628133e4b65b609e7160e555e@10.20.200.227
    From: <sip:07312910430@10.20.200.227:5060>;tag=00143-0b1006b1010684d6
    To: <sip:7434@10.20.200.227:5060>;tag=972x833x
    ...
    */
    void main(TSipMsg req)
    {
       assert(req.getfromtag() == '00143-0b1006b1010684d6');
       assert(req.gettotag() == '972x833x');
    }

NAME

    TSipMsg::getfromnum, TSipMsg::gettonum


SYNOPSIS

    TString TSipMsg::getfromnum()
    TString TSipMsg::gettonum()


DESCRIPTION

    取得消息头中From或者To参数的用户名部分，即sip:之后，@之前的内容


ARGUMENTS

    无

RETURN

    取到的用户名


EXAMPLES

    /* For example:
    INVITE sip:7434@10.20.200.227:5060 SIP/2.0
    Call-ID: 7764053628133e4b65b609e7160e555e@10.20.200.227
    From: <sip:07312910430@10.20.200.227:5060>;tag=00143-0b1006b1010684d6
    To: <sip:7434@10.20.200.227:5060>
    ...
    */
    void main(TSipMsg req)
    {
       assert(req.getfromnum() == '07312910430');
       assert(req.gettonum() == '7434');
    }

NAME

    TSipMsg::getcseqnum, TSipMsg::getcseqmethod


SYNOPSIS

    TString TSipMsg::getcseqnum()
    TString TSipMsg::getcseqmethod()


DESCRIPTION

    取得消息头中CSeq参数中的number值和方法名


ARGUMENTS

    无

RETURN

    CSeq的number值或方法名


EXAMPLES

    /* For example:
    INVITE sip:7434@10.20.200.227:5060 SIP/2.0
    Call-ID: 7764053628133e4b65b609e7160e555e@10.20.200.227
    From: <sip:07312910430@10.20.200.227:5060>;tag=00143-0b1006b1010684d6
    To: <sip:7434@10.20.200.227:5060>
    CSeq: 1 INVITE
    ...
    */
    void main(TSipMsg req)
    {
       assert(req.getcseqnum() == '1');
       assert(req.getcseqmethod() == 'INVITE');
    }

NAME

    TSipMsg::getfromaddr, TSipMsg::gettoaddr, TSipMsg::getcontactaddr


SYNOPSIS

    TString TSipMsg::getfromaddr()
    TString TSipMsg::gettoaddr()
    TString TSipMsg::getcontactaddr( )


DESCRIPTION

    取得消息头中From, To, Contact参数中的地址信息


ARGUMENTS

    无

RETURN

    字符串，地址信息


EXAMPLES

    /* For example INVITE message
    INVITE sip:7434@10.20.200.227:5060 SIP/2.0
    Call-ID: 7764053628133e4b65b609e7160e555e@10.20.200.227
    From: <sip:07312910430@10.20.200.227:5060>;tag=00143-0b1006b1010684d6
    To: <sip:7434@10.20.200.227:5060>
    CSeq: 1 INVITE
    Via: SIP/2.0/UDP 10.20.200.227:9060;branch=z9hG4bK13884222
    Max-Forwards: 30
    Contact: <sip:10.20.200.227:9060>
    ...
    */
    void main(TSipMsg req)
    {
       assert(req.getfromaddr() == 'sip:07312910430@10.20.200.227:5060')
    ;
       assert(req.gettoaddr() == 'sip:7434@10.20.200.227:5060');
       assert(req.getcontactaddr() == 'sip:10.20.200.227:9060');
    }

NAME

    TSipCallSegment::getid, TSipCallSegment::setid


SYNOPSIS

    TString TSipCallSegment::getid()
    TInteger TSipCallSegment::setid(TString csID)


DESCRIPTION

    取得/设置TCallSegment对象的ID


ARGUMENTS

    csID: 要设置的ID值


RETURN

    对于serid，返回1成功，0失败。对于getid返回callsegment的ID


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    var TString idValue;
    ...
    cs = req.createcallsegment();
    cs.setid(idValue);
    idValue = cs.getid();

NAME

    TSipCallSegment::state


SYNOPSIS

    TInteger TSipCallSegment::state( )


DESCRIPTION

    输出cs的状态


ARGUMENTS

    无

RETURN

    cs的状态码


NAME

    TSipCallSegment::getlegnum


SYNOPSIS

    TInteger TSipCallSegment::getlegnum()


DESCRIPTION

    获得callSegment中leg的个数


ARGUMENTS

    无

RETURN

    返回leg的个数


NAME

    TSipCallSegment::initial


SYNOPSIS

    TInteger TSipCallSegment::initial(TSipCallSegment cs2)


DESCRIPTION

    用另一个cs来初始化自身


ARGUMENTS

    cs2: 源cs


RETURN

    


NAME

    TSipCallSegment::relate


SYNOPSIS

    TInteger TSipCallSegment::relate(TSipCallSegment cs2)


DESCRIPTION

    将两个cs做一下关联


ARGUMENTS

    cs2: 被关联的目标cs


RETURN

    


NAME

    TSipCallSegment::merge


SYNOPSIS

    TInteger TSipCallSegment::merge(TSipCallSegment cs2)


DESCRIPTION

    合并两个CS


ARGUMENTS

    cs2: 要合并的呼叫段


RETURN

    


NAME

    TSipCallSegment::onfail, onbusy, onnoanswer, ondisconnect, onanswer,
     onringing, ontransfer, onreplaces, onpassivehold


SYNOPSIS

    TInteger TSipCallSegment::onfail([eventProcessLabel])
    TInteger TSipCallSegment::onbusy([eventProcessLabel])
    TInteger TSipCallSegment::onnoanswer([eventProcessLabel], TInteger time=
    30 )
    TInteger TSipCallSegment::ondisconnect([eventProcessLabel])
    TInteger TSipCallSegment::onanswer([eventProcessLabel])
    TInteger TSipCallSegment::onringing([eventProcessLabel])
    TInteger TSipCallSegment::ontransfer([eventProcessLabel])
    TInteger TSipCallSegment::onreplaces([eventProcessLabel])
    TInteger TSipCallSegment::onpassivehold([eventProcessLabel])


DESCRIPTION

    onfail: 设置路由失败入口。
    onbusy: 设置被叫忙入口。
    onnoanswer: 设置被叫无应答入口。
    ondisconnect: 设置挂机入口（通话后主被叫挂机）。
    onanswer: 设置被叫应答入口（包括ica的主叫应答）。
    onringing: 设置被叫振铃入口（包括ica的主叫振铃）。
    ontransfer: 设置呼叫转移监视入口
    onreplace: 监视代答(replaces)事件入口
    onpassivehold: 设置捕获终端进行HOLD操作的事件入口


ARGUMENTS

    eventProcessLabel: 接收处理该事件的入口名称

    time: 无应答时长，默认30秒


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.onfail([routingfailed]);
    cs.onfail([calledbusy]);
    
    on([routingfailed], TSipCallSegment cs)
    {
       ...
    }
    on([calledbusy], TSipCallSegment cs)
    {
       ...
    }

NAME

    TSipCallSegment::connect


SYNOPSIS

    TInteger TSipCallSegment::connect(TString calledNumber, TInteger legID,
     TString callingNumber)


DESCRIPTION

    连接一个被叫。


ARGUMENTS

    calledNumber: 被叫号码

    legID: 被叫的legID（目前只能填2。默认主叫legID为1， 被叫legID为2）

    callingNumber: 主叫号码


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.connect ('9999',1,' ');

NAME

    TSipCallSegment::connectwithcs, TSipCallSegment::connectwitharg


SYNOPSIS

    TInteger TSipCallSegment::connectwithcs(TSipCallSegment cs2, TString 
    urlNumber,TString fromNumber, TString toNumber)
    TInteger TSipCallSegment::connectwitharg(TSipCallSegment cs2, TInteger 
    type, TString urlNumber,TString fromNumber, TString toNumber, TString 
    other='')


DESCRIPTION

    连接被叫CS，不带参数或者带参数


ARGUMENTS

    cs2: 被叫CS的对象

    urlNumber: 

    fromNumber: 

    toNumber: 

    type: 连接类型

    other: 其他参数，目前为空


RETURN

    


NAME

    TSipCallSegment::ica, TSipCallSegment::icawitharg


SYNOPSIS

    TInteger TSipCallSegment::ica(TString called, TString calling)
    TInteger TSipCallSegment::icawitharg(TString connectType, TString urlCalled,
     TString calling, TString toCalled, TString other='')


DESCRIPTION

    试呼


ARGUMENTS

    called: 被叫号码

    calling: 显示的主叫号码

    connectType: 连接类型，直接连接媒体为1
    2请求媒体类型为audio
    3请求媒体类型为video
    4请求媒体类型为audio，ms不重发invite
    5请求媒体类型为video，ms不重发invite
    6 携带nosdp的invite

    urlCalled: url中的被叫号码

    toCalled: 在to头字段中的被叫号码，默认和url中的一致

    other: 其它参数，暂时保留


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.ica('6666','7777');

NAME

    TSipCallSegment::releasecall


SYNOPSIS

    TInteger TSipCallSegment::releasecall()


DESCRIPTION

    释放呼叫段。


ARGUMENTS

    无

RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.releasecall()；

NAME

    TSipCallSegment::etc, ctr


SYNOPSIS

    TInteger TSipCallSegment::etc()
    TInteger TSipCallSegment::ctr(TInteger resCode=183)


DESCRIPTION

    同步连接媒体操作，ctr和etc的区别是，ctr没有应答因此不会导致计费


ARGUMENTS

    resCode: 


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.etc();

NAME

    TSipCallSegment::onpa, onpc, onpr


SYNOPSIS

    TInteger TSipCallSegment::onpa([eventProcessLabel])
    TInteger TSipCallSegment::onpc([eventProcessLabel])
    TInteger TSipCallSegment::onpr([eventProcessLabel])


DESCRIPTION

    onpa: 设置pa播放完成事件入口，仅仅用于异步的PA操作
    onpc: 设置pc收号完成事件入口，仅仅用于异步的PC操作
    onpr: 设置pr录音完成事件入口，仅仅用于异步的PR操作


ARGUMENTS

    eventProcessLabel: 接收处理该事件的入口名称


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.onpa ([padone]);
    cs.asynpa('0','10001',0,' ',1,0);
    on([padone], TSipCallSegment cs)
    {
       ...
    }

NAME

    TSipCallSegment::pa, asynpa, pc, asynpc, pr, asynpr


SYNOPSIS

    TInteger TSipCallSegment::pa(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat ,TInteger interval, TInteger timer=
    60)
    
    TInteger TSipCallSegment::asynpa(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat ,TInteger interval)
    
    TString TSipCallSegment::pc(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat, TInteger interval, TInteger interrupted,
     TInteger min, TInteger max,TString endDigit, TString cancelDigit, TInteger 
    firstTimeout, TInteger interTimeOut, TInteger timer=60)
    
    TInteger TSipCallSegment::asynpc(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat, TInteger interval, TInteger interrupted,
     TInteger min, TInteger max,TString endDigit, TString cancelDigit, TInteger 
    firstTimeout, TInteger interTimeOut)
    
    TInteger TSipCallSegment::pr(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat, TInteger interval, TString endDigit,
     TInteger duration, TString fileName, TString fileFormat, TInteger dupTreat,
     TInteger timer=60 )
    
    TInteger TSipCallSegment::asynpr(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat, TInteger interval, TString endDigit,
     TInteger duration, TString fileName, TString fileFormat, TInteger dupTreat)
    


DESCRIPTION

    同步/异步放音，收号，录音


ARGUMENTS

    msgIDBase: 语音基数

    msgID: 语音号，字符串，可以是一个数字串，也可以是一个文件名。如果是TTS等
    方式，这里可以是空串

    type: 语音类型：
    0: 固定语音
    1: 整数
    2: 数字
    3: HHMM格式的时间
    4: YYYYMMDD格式的日期
    5: 价格，是一个特定货币最小单位为单位的整数
    6: 时长，以秒为单位的整数
    7: TTS合成的语音
    8: dtmf数字
    9: fsk数字
    10: 发送传真

    varPart: 可变音内容:
    - 如果是TTS，这里是文本的内容
    - 如果是固定语音或者传真，这里为空
    - 其它默认为中文，如果有其他语言或子类型，使用如下格式"lang-value-subtype"
    , 例如 "eng-12833-gen", "chi-1234-ord"

    repeat: 重复次数

    interval: 时间间隔

    timer: 超时时长, 默认60秒

    interrupted: 打断标志1可打断

    min: 最小号长

    max: 最大号长

    endDigit: 收号，录音结束符

    cancelDigit: 取消符

    firstTimeout: 首码超时

    interTimeout: 码间超时

    duration: 录音最大时长

    fileName: 录音文件名

    fileFormat: 录音文件格式，可以是：
    - audio/wav
    - audio/x-wav
    - audio/vnd.wave;codec=x, x=1:PCM, 6:G711a, 7:G711u, 83:G729, 8C:Convedia 
    G729c
    - video/quicktime;Codecs="h263,ulaw"

    dupTreat: 重名处理(0覆盖已存在的文件;1追加到已存在文件的尾部)


RETURN

    pa返回200成功，其它失败
    pc返回收到的号码
    pr返回1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.pa('0','10001',0,' ',1,0);
    ...
    cs.pc('0','10001',0, ' ', 1, 0, 1, 1, 18,'#', '0', 20, 20);
    ...
    cs.pr('0','100001','0',' ',1,0,'#',60,'record1',' audio/wav',0,10);
    ...

NAME

    TSipCallSegment::getparescode, getpcrescode, getpcdtmf, getprrescode

    

SYNOPSIS

    TInteger TSipCallSegment::getparescode()
    TInteger TSipCallSegment::getpcrescode()
    TString TSipCallSegment::getpcdtmf()
    TInteger TSipCallSegment::getprrescode()


DESCRIPTION

    在onpa, onpc, onpr所设置的事件处理程序中可以调用这些函数获得相应码或
    者收号的内容


ARGUMENTS

    无

RETURN

    响应码或者收号的内容


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.onpa ([padone]);
    cs.asynpa('0','10001',0,' ',1,0);
    on([padone], TSipCallSegment cs1)
    {
       var TInteger code = cs1.getparescode();
    }

NAME

    TSipCallSegment::cancel


SYNOPSIS

    TInteger TSipCallSegment::cancel(TInteger legID)


DESCRIPTION

    取消当前的pa,pc,pr操作


ARGUMENTS

    legID: legId。若是为0表示取消会议的pa操作。


RETURN

    1成功，0失败


NAME

    TSipCallSegment::dfc


SYNOPSIS

    TInteger TSipCallSegment::dfc()


DESCRIPTION

    将主叫从媒体上断开，用于切换媒体服务器的情况


ARGUMENTS

    无

RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.dfc();

NAME

    TSipCallSegment::disconnectleg


SYNOPSIS

    TInteger TSipCallSegment::disconnectleg(TInteger legID)


DESCRIPTION

    断开呼叫腿。


ARGUMENTS

    legID: 被叫的legID（目前只能填2。默认主叫legID为1， 被叫legID为2）


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.disconnectleg (2);

NAME

    TSipCallSegment::splitleg


SYNOPSIS

    TInteger TSipCallSegment::splitleg(TInteger legID)


DESCRIPTION

    将一个CS中的某个leg分到另一个leg中。


ARGUMENTS

    legID: legId


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.splitleg (2);

NAME

    TSipCallSegment::moveleg


SYNOPSIS

    TInteger TSipCallSegment::moveleg(TInteger newLegID,TSipCallSegment 
    srcCS, TInteger srcLeg)


DESCRIPTION

    将另一个CS的某个Leg迁移到自身


ARGUMENTS

    newLegID: 指定的新legID

    srcCS: 被迁移的Leg所在的TSipCallSegment对象

    srcLeg: 被迁移的LegID


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipCallSegment cs2;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.moveleg(2,cs2,1);

NAME

    TSipCallSegment::geteventlegid


SYNOPSIS

    TInteger TSipCallSegment::geteventlegid()


DESCRIPTION

    取得事件的legID


ARGUMENTS

    无

RETURN

    1主叫，2被叫


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.geteventlegid();

NAME

    TSipCallSegment::geterrorcase


SYNOPSIS

    TInteger TSipCallSegment::geterrorcase()


DESCRIPTION

    取得错误的响应码，如果在同步etc，pa，pc操作时，sib走错误出口，可以使
    用该函数。


ARGUMENTS

    无

RETURN

    0 正常
    1 默认错误
    2 ETC失败
    3 超时
    4 收号失败
    5 放音失败
    6 录音失败


EXAMPLES

    var TSipCallSegment cs;
    var TSipMsg req;
    ...
    cs = req.createcallsegment();
    cs.geterrorcase ();

NAME

    TSipCallSegment::asynvxml


SYNOPSIS

    TInteger TSipCallSegment::asynvxml(TString url)


DESCRIPTION

    异步执行vxml脚本


ARGUMENTS

    url: vxml脚本的url


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    vxmlUrl TString
    
    cs.asynvxml (vxmlUrl);

NAME

    TSipCallSegment::onvxml


SYNOPSIS

    TInteger TSipCallSegment::onvxml([eventProcessLabel])


DESCRIPTION

    设置vxml执行完毕的入口


ARGUMENTS

    eventProcessLabel: 接收处理该事件的sib标签名


RETURN

    1成功，0失败


NAME

    TSipCallSegment::getvxmlrescode


SYNOPSIS

    TInteger TSipCallSegment::getvxmlrescode( )


DESCRIPTION

    取得vxml操作的响应码


ARGUMENTS

    无

RETURN

    


NAME

    TSipCallSegment::hold


SYNOPSIS

    TInteger TSipCallSegment::hold(TInteger legID=1)


DESCRIPTION

    将呼叫hold住


ARGUMENTS

    legID: 呼叫的legId，默认填1


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    ...
    cs.hold (1);

NAME

    TSipCallSegment::gettransfernum


SYNOPSIS

    TString TSipCallSegment::gettransfernum()


DESCRIPTION

    得到呼叫转移号码（转移类型为1有效）


ARGUMENTS

    无

RETURN

    呼叫转移号码


EXAMPLES

    var TSipCallSegment cs;
    var TString s;
    s = cs.gettransfernum();

NAME

    TSipCallSegment::gettransferurl


SYNOPSIS

    TString TSipCallSegment::gettransferurl()


DESCRIPTION

    得到呼叫转移的url（转移类型为2有效）


ARGUMENTS

    无

RETURN

    呼叫转移的url


EXAMPLES

    var TSipCallSegment cs;
    var TString s;
    s = cs.gettransferurl();

NAME

    TSipCallSegment::gettransfertype


SYNOPSIS

    TInteger TSipCallSegment::gettransfertype()


DESCRIPTION

    得到呼叫转移的类型


ARGUMENTS

    无

RETURN

    呼叫转移的类型(1为intendment 2 为attendant)


EXAMPLES

    var TSipCallSegment cs;
    var TInteger i;
    i = cs.gettransfertype();

NAME

    TSipCallSegment::gettransferreplaces


SYNOPSIS

    TString TSipCallSegment::gettransferreplaces()


DESCRIPTION

    取得呼叫转移的replaces头字段


ARGUMENTS

    无

RETURN

    呼叫转移的replaces头字段


EXAMPLES

    var TSipCallSegment cs;
    var TString s;
    s = cs.gettransferreplaces();

NAME

    TSipCallSegment::transfernotify


SYNOPSIS

    TInteger TSipCallSegment::transfernotify(TInteger legID, TInteger resCode)
    


DESCRIPTION

    呼叫转移报告


ARGUMENTS

    legID: legID

    resCode: 响应码


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallSegment cs;
    cs.onvtransfernotify (1,200);

NAME

    TSipCallSegment::replaces


SYNOPSIS

    TInteger TSipCallSegment::replaces(TString url, TString calling, TString 
    called, TString a)


DESCRIPTION

    replaces操作


ARGUMENTS

    url: replaces的url

    calling: 主叫号码

    called: 被叫号码

    a: replaces头自动


RETURN

    1成功，0失败


NAME

    TSipCallSegment::getcalllegidentify


SYNOPSIS

    TString TSipCallSegment::getcalllegidentify(TInteger legID)


DESCRIPTION

    取得某条腿的呼叫标识


ARGUMENTS

    legID: legId


RETURN

    呼叫标识字符串


NAME

    TSipCallSegment::process


SYNOPSIS

    TInteger TSipCallSegment::process(TInteger resCode, TInteger relFlag)
    


DESCRIPTION

    给主叫leg发送临时响应


ARGUMENTS

    resCode: 发送的响应码

    relFlag: 


RETURN

    


EXAMPLES

    void main(TSipMsg req)
    {
       var TsipCallSegment cs;
       cs = req.createcallsegment();
       cs.process (183,0); // send a 183 response to calling party
       ...
    }

NAME

    TSipCallSegment::jc, TSipCallSegment::unjc


SYNOPSIS

    TInteger TSipCallSegment::jc(TString conf, TInteger mode, TString type=
    '')
    TInteger TSipCallSegment::unjc()


DESCRIPTION

    将callSegment加入会议/从会议中退出


ARGUMENTS

    conf: 会议标识

    mode: 0双工，1单工

    type: 会议类型，目前可不用填


RETURN

    


NAME

    TSipCallSegment::getonfailrescode


SYNOPSIS

    TInteger TSipCallSegment::getonfailrescode()


DESCRIPTION

    得到onfail，onnoanswer，onbusy等事件具体的响应码


ARGUMENTS

    无

RETURN

    


NAME

    TSipCallSegment::setprivateheader, TSipCallSegment::getprivateheader

    

SYNOPSIS

    TInteger TSipCallSegment::setprivateheader(TString name, TString value)
    
    TString TSipCallSegment::getprivateheader(TString name)


DESCRIPTION

    设置/取得SIP消息中的一些特殊的私有头字段


ARGUMENTS

    name: 字段名

    value: 字段值


RETURN

    


NAME

    TSipCallSegment::getrelatedid


SYNOPSIS

    TString TSipCallSegment::getrelatedid()


DESCRIPTION

    得到关联的callSegment的id


ARGUMENTS

    无

RETURN

    


NAME

    TSipCallSegment::redirect


SYNOPSIS

    TInteger TSipCallSegment::redirect(TString url)


DESCRIPTION

    将呼叫做重定向，将向leg1发送302响应


ARGUMENTS

    url: 重定向的url


RETURN

    


NAME

    TSipCallSegment::onsessionrefresh


SYNOPSIS

    TInteger TSipCallSegment::onsessionrefresh([eventProcessLabel])


DESCRIPTION

    设置sessionrefresh事件的事件入口


ARGUMENTS

    eventProcessLabel: 处理该事件的sib标签名


RETURN

    


NAME

    TSipCallSegment::getsessionrefreshholdflag, getsessionrefreshmethod

    

SYNOPSIS

    TInteger TSipCallSegment::getsessionrefreshholdflag()
    TString TSipCallSegment::getsessionrefreshmethod()


DESCRIPTION

    获得sessionrefresh事件的hold标志或方法名称


ARGUMENTS

    无

RETURN

    


NAME

    TSipCallSegment::resetfsm


SYNOPSIS

    TInteger TSipCallSegment::resetfsm()


DESCRIPTION

    将当前自动机设置为cs对象归属的自动机


ARGUMENTS

    无

RETURN

    


NAME

    TSipCallSegment::addheader


SYNOPSIS

    TInteger TSipCallSegment::addheader(TString name, TString value)


DESCRIPTION

    追加设置发送的INVITE消息中的头


ARGUMENTS

    name: 消息头的名称

    value: 消息头的值


RETURN

    1成功，0失败


NAME

    TSipCallSegment::waitoverlap


SYNOPSIS

    TString TSipCallSegment::waitoverlap(TInteger timer)


DESCRIPTION

    等待overlap的后续参数


ARGUMENTS

    timer: 等待的时长，如果超时，函数走error出口


RETURN

    取到的overlap的值


NAME

    TSdpMsg::sdpparse


SYNOPSIS

    TInteger TSdpMsg::sdpparse(TString s)


DESCRIPTION

    对SDP消息进行解析


ARGUMENTS

    s: 从SIP消息的Content中取到的SDP串


RETURN

    0成功，－1失败


NAME

    TSdpMsg::sdpencode


SYNOPSIS

    TString TSdpMsg::sdpencode()


DESCRIPTION

    把一个SDP对象进行编码


ARGUMENTS

    无

RETURN

    SDP编码后的结果


NAME

    TSdpMsg::printtree


SYNOPSIS

    TInteger TSdpMsg::printtree( )


DESCRIPTION

    打印SDP对象的消息树的内容


ARGUMENTS

    无

RETURN

    0成功，－1失败


NAME

    TSdpMsg::getvalue, TSdpMsg::changevalue


SYNOPSIS

    TInteger TSdpMsg::getvalue(TString path)
    TInteger TSdpMsg::changevalue(TString path,TString value)


DESCRIPTION

    getvalue()从SDP对象中得到某个字段的值。changevalue修改SDP对象中某个字
    段的值


ARGUMENTS

    path: 要操作的字段在SDP对象树中的位置

    value: 要修改的值


RETURN

    getvalue返回取得的值，changevalue返回0成功，－1失败


NAME

    TSdpMsg::getmediacount, getmediacodec, getmediacodecbytype, getmediatype,
     getmediaport, getmediaportbytype, getmediadirection, getmediadirectionbytype,
     addmedia, setmediaport, setmediaportbytype


SYNOPSIS

    TInteger TSdpMsg::getmediacount()
    TString TSdpMsg::getmediacodec(TInteger index)
    TString TSdpMsg::getmediacodecbytype(TString mediaType)
    TString TSdpMsg::getmediatype(TInteger index)
    TString TSdpMsg::getmediaport(TInteger index)
    TString TSdpMsg::getmediaportbytype(TString mediaType)
    TString TSdpMsg::getmediadirection(TInteger pos)
    TString TSdpMsg::getmediadirectionbytype(TString mediaType)
    TInteger TSdpMsg::addmedia(TString mediaType,TString trans,TString addr,
    TString port,TString codec)
    TInteger TSdpMsg::setmediaport(TString port)
    TInteger TSdpMsg::setmediaportbytype(TString mediaType, TString port)
    


DESCRIPTION

    这组函数操作SDP对象中的媒体:
    getmediacount得到SDP对象中媒体的个数
    getmediacodec得到SDP对象中某个媒体的codec
    getmediatype得到SDP对象中某个媒体的媒体类型
    addmedia向SDP对象中增加一种媒体类型
    setmediaport设置SDP对象中mediaport值


ARGUMENTS

    index: 该媒体在sdp中的位置，从0开始

    mediaType: 

    trans: 

    addr: 

    port: 

    codec: 


RETURN

    getmediacount返回媒体的个数
    getmediacodec返回该媒体codec的值，多个codec的话中间用'|'分隔
    getmediatype返回该媒体的类型，目前有audio、video等
    其它函数返回0表示成功，1表示失败


NAME

    TSdpMsg::setusername


SYNOPSIS

    TInteger TSdpMsg::setusername(TString userName)


DESCRIPTION

    设置o行中的username


ARGUMENTS

    userName: 要设置的user name值


RETURN

    0成功，－1失败


NAME

    TSdpMsg::setsessionid


SYNOPSIS

    TInteger TSdpMsg::setsessionid(TString sessionid)


DESCRIPTION

    设置o行中的sessionid


ARGUMENTS

    sessionid: 要设置的sessionid值


RETURN

    0成功，－1失败


NAME

    TSdpMsg::setversion


SYNOPSIS

    TInteger TSdpMsg::setversion(TString version)


DESCRIPTION

    设置o行中的version


ARGUMENTS

    version: 要设置的version值


RETURN

    0成功，－1失败


NAME

    TSdpMsg::setoriginaddress


SYNOPSIS

    TInteger TSdpMsg::setoriginaddress(TString oAddr)


DESCRIPTION

    设置o行中的originaddress


ARGUMENTS

    oAddr: 要设置的originaddress值


RETURN

    0成功，－1失败


NAME

    TSdpMsg::addattribute, getattribute, rmattribute


SYNOPSIS

    TInteger TSdpMsg:: addattribute(TString mediaType, TString attr)
    TString TSdpMsg::getattribute(TString mediaType, TInteger pos)
    TInteger TSdpMsg::rmattribute(TString mediaType, TString value)


DESCRIPTION

    addattribute为第一个m行增加一个属性值，getattribute获取特定媒体类型的
    值


ARGUMENTS

    mediaType: 要操作的媒体类型

    attr: 要增加的属性值

    pos: 

    value: 


RETURN

    addattribute返回0成功，－1失败。getattribute返回值


NAME

    TSdpMsg::setconnectionaddress, setconnectionaddressbytype, getconnectionaddress,
     getconnectionaddressbytype


SYNOPSIS

    TInteger TSdpMsg::setconnectionaddress(TString addr)
    TInteger TSdpMsg::setconnectionaddressbytype(TString mediaType, TString 
    addr)
    TString TSdpMsg::getconnectionaddress(TInteger pos)
    TString TSdpMsg::getconnectionaddressbytype(TString mediaType)


DESCRIPTION

    设置/获取SDP对象中connectionaddress值


ARGUMENTS

    addr: 要设置的connectionaddress值

    pos: 

    mediaType: 


RETURN

    0成功，－1失败


NAME

    TSdpMsg::rmfmtlist, TSdpMsg::addfmtlist


SYNOPSIS

    TInteger TSdpMsg::rmfmtlist()
    TInteger TSdpMsg::addfmtlist(TString type, TString attr)


DESCRIPTION

    rmfmtlist删除SDP对象中所有的fmtlist，addfmtlist向SDP对象中添加fmtlist

    

ARGUMENTS

    type: 添加的类型

    attr: 添加的属性


RETURN

    0成功，－1失败


NAME

    TSdpMsg::negotiation


SYNOPSIS

    TString TSdpMsg::negotiation(TString arg1,TString arg2)


DESCRIPTION

    sdp协商函数


ARGUMENTS

    arg1: 对端支持的静态载荷类型（中间用"|"隔开）

    arg2: 本地支持的静态载荷类型（中间用"|"隔开）


RETURN

    协商后的载荷类型


NAME

    TSdpMsg::setvideobandwidth


SYNOPSIS

    TInteger TSdpMsg::setvideobandwidth(TString value)


DESCRIPTION

    


ARGUMENTS

    value: 


RETURN

    


NAME

    TSdpMsg::getteleeventcodec


SYNOPSIS

    TInteger TSdpMsg::getteleeventcodec()


DESCRIPTION

    


ARGUMENTS

    无

RETURN

    


NAME

    TSipCallLeg::onevent


SYNOPSIS

    TInteger TSipCallLeg::onevent([eventProcessLabel])


DESCRIPTION

    在生成某呼叫方相应的TSipCallLeg对象后，调用该函数可以监听来自该呼叫方
    的所有消息事件。


ARGUMENTS

    eventProcessLabel: 收处理该事件的标签名


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallLeg oleg;
    ...
    oleg.onevent([oleg]);
    on([olen], TSipCallLeg leg)
    {
       ...
    }

NAME

    TSipCallLeg::sendreq, TSipCallLeg::sendres


SYNOPSIS

    TInteger TSipCallLeg::sendreq(TInteger method, TString type, TString 
    content)
    TInteger TSipCallLeg::sendres(TString method, TInteger resCode, TString 
    type, TString content)


DESCRIPTION

    构造并发送某一请求/响应消息


ARGUMENTS

    method: 方法名

    type: 消息体类型

    content: 消息体内容

    resCode: 响应码


RETURN

    1成功，0失败


EXAMPLES

    

NAME

    TSipCallLeg::geteventtype


SYNOPSIS

    TString TSipCallLeg::geteventtype()


DESCRIPTION

    获取消息事件的类型


ARGUMENTS

    无

RETURN

    如果是请求消息，则返回REQUEST；如果是响应消息，则返回RESPONSE


NAME

    TSipCallLeg::geteventmethod


SYNOPSIS

    TString TSipCallLeg::geteventmethod()


DESCRIPTION

    获取消息事件的方法


ARGUMENTS

    无

RETURN

    如果是请求消息，则返回响应的方法名；如果是响应消息，则返回该响应对应
    的请求消息的方法名。如：INVITE、ACK、CANCEL、OPTION、BYE、REGISTER等

    

NAME

    TSipCallLeg::geteventrescode


SYNOPSIS

    TInteger TSipCallLeg::geteventrescode()


DESCRIPTION

    获得响应消息的响应代码，如200，180等等


ARGUMENTS

    无

RETURN

    


NAME

    TSipCallLeg::setfrom


SYNOPSIS

    TInteger TSipCallLeg::setfrom(TString from)


DESCRIPTION

    设置消息中From头字段的值


ARGUMENTS

    from: 设置的FROM头字段的信息


RETURN

    1成功，0失败


NAME

    TSipCallLeg::setto


SYNOPSIS

    TInteger TSipCallLeg::setto(TString to)


DESCRIPTION

    设置消息中To头字段的值


ARGUMENTS

    to: 设置的TO头字段的信息


RETURN

    1成功，0失败


NAME

    TSipCallLeg::seturl


SYNOPSIS

    TInteger TSipCallLeg::seturl(TString url)


DESCRIPTION

    设置消息中URL的值


ARGUMENTS

    url: 设置的URL的信息


RETURN

    1成功，0失败


EXAMPLES

    TSipCallLeg oleg;
    ...
    oleg.seturl('sip:66661002@192.168.2.217');

NAME

    TSipCallLeg::getuasreq


SYNOPSIS

    TSipMsg TSipCallLeg::getuasreq( )


DESCRIPTION

    获取UAS的请求消息对象，业务可根据此对象句柄获得该请求消息的相应信息

    

ARGUMENTS

    无

RETURN

    TSipMsg对象句柄


NAME

    TSipCallLeg::getuacres


SYNOPSIS

    TSipMsg TSipCallLeg::getuacres( )


DESCRIPTION

    获取UAC的响应消息对象，业务可根据此对象句柄获得该响应消息的相应信息

    

ARGUMENTS

    无

RETURN

    TSipMsg对象句柄


NAME

    TSipCallLeg::setheadertoreq, TSipCallLeg::addheadertoreq


SYNOPSIS

    TInteger TSipCallLeg::setheadertoreq(TString name, TString value)
    TInteger TSipCallLeg::addheadertoreq(TString name, TString value)


DESCRIPTION

    setheadertoreq为设置请求消息的某种头字段的第一个值，如果已经有值，则
    修改该值。addheadertoreq为增加请求消息的某种头字段的值，后增加的头字段
    值在消息中位于先增加的值的前列（该类头字段的第一个值推荐用setheadertoreq）
    。注意：主要用于设置除常用头字段以外的头字段值，如Accept、Supported、
    Require等等。不推荐用此函数增加Record-Route, Route头，除非业务明确需要
    增加。


ARGUMENTS

    name: 字段名

    value: 应头字段的值


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallLeg pleg;
    ...
    oleg.addheadertoreq('Accept', 'application/sdp');
    oleg.setheadertoreq('Accept', 'application/sdp');

NAME

    TSipCallLeg::setheadertores, TSipCallLeg::addheadertores


SYNOPSIS

    TInteger TSipCallLeg::setheadertores(TString name, TString value)
    TInteger TSipCallLeg::addheadertores(TString name, TString value)


DESCRIPTION

    setheadertores为设置响应消息的某种头字段的第一个值，如果已经有值，则
    修改该值。addheadertores为增加响应消息的某种头字段的值，后增加的头字段
    值在消息中位于先增加的值的前列（该类头字段的第一个值推荐用setheadertores）
    。注意：主要用于设置除常用头字段以外的头字段值，如Accept、Supported、
    Require等等。不推荐用此函数增加Record-Route, Route头，除非业务明确需要
    增加。


ARGUMENTS

    name: 字段名

    value: 应头字段的值


RETURN

    1成功，0失败


EXAMPLES

    var TSipCallLeg oleg;
    ...
    oleg.addheadertores('Accept', 'application/sdp');
    oleg.setheadertores('Accept', 'application/sdp');

NAME

    TSipCallLeg::rmreqheader, TSipCallLeg::rmresheader


SYNOPSIS

    TInteger TSipCallLeg::rmreqheader()
    TInteger TSipCallLeg::rmresheader()


DESCRIPTION

    删除请求/响应消息的所有头字段，当业务需要重新设置消息时，可先用此函数
    清空头字段，再进行设置。


ARGUMENTS

    无

RETURN

    1成功，0失败


NAME

    TSipCallLeg::getuasreqcontent


SYNOPSIS

    TString TSipCallLeg::getuasreqcontent()


DESCRIPTION

    得到uasreq的content内容


ARGUMENTS

    无

RETURN

    uasreq的content内容


NAME

    TSipCallLeg::getuasreqcontenttype


SYNOPSIS

    TString TSipCallLeg::getuasreqcontenttype()


DESCRIPTION

    得到uasreq的contentType


ARGUMENTS

    无

RETURN

    uasreq的contentType内容


NAME

    TSipCallLeg::getuasreqcontentlength


SYNOPSIS

    TInteger TSipCallLeg::getuasreqcontentlength()


DESCRIPTION

    得到uasreq的contentLength


ARGUMENTS

    无

RETURN

    uasreq的contentLength内容


NAME

    TSipCallLeg::getuacrescontent


SYNOPSIS

    TString TSipCallLeg::getuacrescontent( )


DESCRIPTION

    得到uacres的content内容


ARGUMENTS

    无

RETURN

    uacres的content内容


NAME

    TSipCallLeg::getuacrescontenttype


SYNOPSIS

    TString TSipCallLeg::getuacrescontenttype( )


DESCRIPTION

    得到uacres的contentType内容


ARGUMENTS

    无

RETURN

    uacres的contentType内容


NAME

    TSipCallLeg::getuacrescontentlength


SYNOPSIS

    TInteger TSipCallLeg::getuacrescontentlength( )


DESCRIPTION

    得到uacres的contentLength


ARGUMENTS

    无

RETURN

    uacres的contentLength内容


NAME

    TSipCallLeg::getid, TSipCallLeg::setid


SYNOPSIS

    TString TSipCallLeg::getid()
    TInteger TSipCallLeg::setid(TString legid)


DESCRIPTION

    获得/设置callLeg的Id


ARGUMENTS

    legid: 要设置的legID


RETURN

    对于setid，返回1表示成功，0表示失败。对于getid返回字符串形式的ID


EXAMPLES

    var TSipCallLeg oleg;
    var TString s;
    oleg.setid('1');
    s = oleg.getid();

NAME

    TSipCallLeg::getremotesdp


SYNOPSIS

    TString TSipCallLeg::getremotesdp( )


DESCRIPTION

    得到callLeg对端的SDP


ARGUMENTS

    无

RETURN

    SDP内容


NAME

    TSipCallLeg::getheaderfromreq, TSipCallLeg::getheaderfromres


SYNOPSIS

    TString TSipCallLeg::getheaderfromreq(TString name)
    TString TSipCallLeg::getheaderfromres(TString name)


DESCRIPTION

    从请求/响应消息中取某个头字段的内容


ARGUMENTS

    name: 头字段名


RETURN

    头字段的内容


EXAMPLES

    var TSipCallLeg oleg;
    var TString s;
    s = oleg.getheaderfromreq('Server');
    s = oleg.getheaderfromres('Comtact');

NAME

    TSipCallLeg::sendreqmime, TSipCallLeg::sendresmime


SYNOPSIS

    TInteger TSipCallLeg::sendreqmime(TString method, THttpContent h)
    TInteger TSipCallLeg::sendresmime(TString method, THttpContent h)


DESCRIPTION

    发送MIME格式的请求/响应消息


ARGUMENTS

    method: 送请求消息的方法

    h: MIME所在的HTTPContent对象


RETURN

    1成功，0失败


NAME

    TSipCallLeg::redirect


SYNOPSIS

    TInteger TSipCallLeg::redirect(TString url)


DESCRIPTION

    发送302重定向响应


ARGUMENTS

    url: 定向的url


RETURN

    1成功，0失败


NAME

    TSipCallLeg::serialize, deserialize


SYNOPSIS

    TString TSipCallLeg::serialize()
    TSipCallLeg deserialize(TString serializeStr)


DESCRIPTION

    序列化和反序列化leg对象


ARGUMENTS

    serializeStr: 序列化字符串


RETURN

    serialize返回序列化后的字符串，deserialize返回反序列化生成的TSipCallLeg对
    象


NAME

    TSipCallLeg::setprivateheader, TSipCallLeg::getprivateheader


SYNOPSIS

    TInteger TSipCallLeg::setprivateheader(TString name,TString value)
    TString TSipCallLeg::getprivateheader(TString name)


DESCRIPTION

    设置/获取TSipCallLeg对象的私有头的值


ARGUMENTS

    name: 私有头的名称

    value: 私有头的值


RETURN

    对于setprivateheader，返回1成功，0失败。对于getprivateheader返回私有
    头的值


NAME

    TSipCallLeg::setcontact


SYNOPSIS

    TInteger TSipCallLeg::setcontact(TString value)


DESCRIPTION

    为leg对象设置contact头


ARGUMENTS

    value: contact头的值


RETURN

    1成功，0失败


NAME

    TSipCallLeg::sendsyncreq


SYNOPSIS

    TInteger TSipCallLeg::sendsyncreq(TString method, TString contentType,
     TString content, TInteger timer)


DESCRIPTION

    发送同步请求消息，callleg对象将阻塞到，直到收到响应消息或者超时


ARGUMENTS

    method: 求消息方法名

    contentType: 求消息的contenttype

    content: 求消息的消息体

    timer: 超时时长


RETURN

    


NAME

    TSipCallLeg::sendsyncreqmime


SYNOPSIS

    TInteger TSipCallLeg::sendsyncreqmime(TString method, THttpContent h,
     TInteger timer)


DESCRIPTION

    发送同步请求MIME消息，callleg对象将阻塞到，直到收到响应消息或者超时

    

ARGUMENTS

    method: 求消息方法名

    h: 求消息所在的THTTPContent对象

    timer: 超时时长


RETURN

    


NAME

    TSipConference::create


SYNOPSIS

    TInteger TSipConference::create(TInteger arg0, TInteger arg1)


DESCRIPTION

    在媒体服务器上创建一个会议室


ARGUMENTS

    arg0: 会议类型，目前填1

    arg1: 删除条件，目前填1


RETURN

    


NAME

    TSipConference::destroy


SYNOPSIS

    TInteger TSipConference::destroy()


DESCRIPTION

    销毁该会议表示的会议室


ARGUMENTS

    无

RETURN

    


NAME

    TSipConference::getconferenceid


SYNOPSIS

    TString TSipConference::getconferenceid()


DESCRIPTION

    获得会议室的标识


ARGUMENTS

    无

RETURN

    


NAME

    TSipConference::pa, asynpa, pr, asynpr


SYNOPSIS

    TInteger TSipConference::pa(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat, TInteger interval, TInteger timer=
    60)
    TInteger TSipConference::asynpa(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat, TInteger interval)
    TInteger TSipConference::pr(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat, TInteger interval, TString endDigit,
     TInteger duration, TString fileName, TString fileFormat, TInteger dupTreat,
     TInteger timer=60)
    TInteger TSipConference::asynpr(TString msgIDBase, TString msgID, TInteger 
    type, TString varPart, TInteger repeat, TInteger interval, TString endDigit,
     TInteger duration, TString fileName, TString fileFormat, TInteger dupTreat)
    


DESCRIPTION

    对会议进行同步/异步放音/录音操作


ARGUMENTS

    msgIDBase: 语音基数

    msgID: 语音号，字符串，可以是一个数字串，也可以是一个文件名。如果是TTS等
    方式，这里可以是空串

    type: 语音类型：
    0: 固定语音
    1: 整数
    2: 数字
    3: HHMM格式的时间
    4: YYYYMMDD格式的日期
    5: 价格，是一个特定货币最小单位为单位的整数
    6: 时长，以秒为单位的整数
    7: TTS合成的语音
    8: dtmf数字
    9: fsk数字
    10: 发送传真

    varPart: 可变音内容:
    - 如果是TTS，这里是文本的内容
    - 如果是固定语音或者传真，这里为空
    - 其它默认为中文，如果有其他语言或子类型，使用如下格式"lang-value-subtype"
    , 例如 "eng-12833-gen", "chi-1234-ord"

    repeat: 重复次数

    interval: 时间间隔

    timer: 超时时长, 默认60秒

    endDigit: 录音结束符

    duration: 录音最大时长

    fileName: 录音文件名

    fileFormat: 录音文件格式，可以是：
    - audio/wav
    - audio/x-wav
    - audio/vnd.wave;codec=x, x=1:PCM, 6:G711a, 7:G711u, 83:G729, 8C:Convedia 
    G729c
    - video/quicktime;Codecs="h263,ulaw"

    dupTreat: 重名处理(0覆盖已存在的文件;1追加到已存在文件的尾部)


RETURN

    


NAME

    TSipConference::cancel


SYNOPSIS

    TInteger TSipConference::cancel()


DESCRIPTION

    取消正在进行的pa或pr操作


ARGUMENTS

    无

RETURN

    


NAME

    TSipConference::onpa, onpr


SYNOPSIS

    TInteger TSipConference::onpa([eventProcessLabel])


DESCRIPTION

    设置异步pa和pc的事件入口


ARGUMENTS

    eventProcessLabel: 事件入口标识


RETURN

    


NAME

    TSipConference::setmsname


SYNOPSIS

    TInteger TSipConference::setmsname(TString msname)


DESCRIPTION

    设置创建会议的媒体服务器的name


ARGUMENTS

    msname: 体服务器的name，其值必须是msconfig文件中配置过的ms


RETURN

    


NAME

    TTCAPDialogue::getdlgid


SYNOPSIS

    TInteger TTCAPDialogue::getdlgid()


DESCRIPTION

    获得一个对话的对话ID


ARGUMENTS

    无

RETURN

    整数形式的对话ID


NAME

    TTCAPDialogue::getacname, TTCAPDialogue::setacname


SYNOPSIS

    TString TTCAPDialogue::getacname()
    TInteger TTCAPDialogue::setacname(TString ascACName)


DESCRIPTION

    获得一个对话的ac对应的ASC码字符串，设置一个对话的ACName。一般来说应该
    使用getac和setac来获取或者设置AC，但是对于一些AC非常繁杂无法在config.
    ac中一一设置的情况，可以直接使用这个函数来设置AC以便发送TC-Begin或者TC-
    Uni


ARGUMENTS

    ascACName: ASC格式的AC名字串，格式与getacname返回的是一致的


RETURN

    getacname返回ac对应的ASC码字符串，setacname返回整数0


EXAMPLES

    // for received the InitiDP operation of INAP
    void main(TTCAPDialogue d)
    {
       assert(d.getacname() == '03A37D0101010000');
    }

NAME

    TTCAPDialogue::getlpc, TTCAPDialogue::getrpc


SYNOPSIS

    TInteger TTCAPDialogue::getlpc()
    TInteger TTCAPDialogue::getrpc()


DESCRIPTION

    获得本次对话本地或者远端的PC，这个PC也许来自远端的消息，也许来自自身
    的设置


ARGUMENTS

    无

RETURN

    整数形式的PC


NAME

    TTCAPDialogue::getlssn, TTCAPDialogue::getrssn


SYNOPSIS

    TInteger TTCAPDialogue::getlssn()
    TInteger TTCAPDialogue::getrssn()


DESCRIPTION

    获得本次对话本地或者远端的SSN，这个SSN也许来自远端的消息，也许来自自
    身的设置


ARGUMENTS

    无

RETURN

    整数形式的SSN


NAME

    TTCAPDialogue::getlgtnumber, TTCAPDialogue::getrgtnumber


SYNOPSIS

    TString TTCAPDialogue::getlgtnumber()
    TString TTCAPDialogue::getrgtnumber()


DESCRIPTION

    获得本地或者是远端的gt码。对于接受TC-Begin，本地对应目的，远端对应源
    ；对于发送TC-Begin，本地对应源，远端对应目的


ARGUMENTS

    无

RETURN

    ASC形式的GT码，不包括地址头部，只是纯GT码


NAME

    TTCAPDialogue::getlgthead, TTCAPDialogue::getrgthead


SYNOPSIS

    TInteger TTCAPDialogue::getlgthead(TInteger& tt, TInteger& np, TInteger&
     nai)
    TInteger TTCAPDialogue::getrgthead(TInteger& tt, TInteger& np, TInteger&
     nai)


DESCRIPTION

    获得本地或者是远端的gt的头部信息。（对于接受TC-Begin，本地对应目的，
    远端对应源；对于发送TC-Begin，本地对应源，远端对应目的）


ARGUMENTS

    tt: 整数引用，返回Translation type，如果不存在则返回-1

    np: 整数引用，返回Number plan，如果不存在则返回-1

    nai: 整数引用，返回Nature of Address Indicator，如果不存在则返回-1


RETURN

    GT头部的类型：0表示没有GT，1表示只有NAI，2表示只有TT，3表示有TT和NP，
    4表示有TT,NP和NAI


NAME

    TTCAPDialogue::getcurprimitiveid


SYNOPSIS

    TInteger TTCAPDialogue::getcurprimitiveid()


DESCRIPTION

    获得最近收到的对话原语的ID


ARGUMENTS

    无

RETURN

    整数形式的原语ID:
    0: tc-uni
    1: tc-begin
    2: tc-continue1
    3: tc-continue2
    4: tc-end
    5: tc-u-abort
    6: tc-p-abort
    9: tc-notice
    16: tc-invoke
    17: tc-result-nl
    18: tc-result-l
    19: tc-u-error
    20: tc-u-reject
    21: tc-l-cancel
    22: tc-u-cancel
    23: tc-l-reject
    24: tc-r-reject


NAME

    TTCAPDialogue::getcuropid


SYNOPSIS

    TInteger TTCAPDialogue::getcuropid()


DESCRIPTION

    获得最近收到的操作的操作码


ARGUMENTS

    无

RETURN

    整数形式的操作码


NAME

    TTCAPDialogue::getcurinvokeid


SYNOPSIS

    TInteger TTCAPDialogue::getcurinvokeid()


DESCRIPTION

    获得最近收到的操作的InvokeID，此后发送Error或者Result的时候可能会用到
    


ARGUMENTS

    无

RETURN

    整数形式的InvokeID


NAME

    TTCAPDialogue::getasnobj


SYNOPSIS

    TASNObject TTCAPDialogue::getasnobj()


DESCRIPTION

    获得最近收到的操作的参数对应的ASNObject对象，此后可以对这个对象进行取
    值等操作


ARGUMENTS

    无

RETURN

    对象的handle


NAME

    TTCAPDialogue::appdlgid


SYNOPSIS

    TInteger TTCAPDialogue::appdlgid(TString destName='*')
    TInteger TTCAPDialogue::appdlgid(TInteger groupID)


DESCRIPTION

    向TCAP申请对话ID，可以根据参数选择向哪个TCAP申请对话ID


ARGUMENTS

    destName: 字符串，缺省为'*'，否则是一个scf程序的configssp命令所能看到
    的DPC的名字

    groupID: 如果没有配置DPC和名字的对应关系，可以直接使用整数参数指定申
    请dialogueID的groupID，这个groupID是tcap程序向scf程序注册时给定的


RETURN

    整数，申请到的dialogueID


NAME

    TTCAPDialogue::setac, TTCAPDialogue::getac


SYNOPSIS

    TInteger TTCAPDialogue::setac(TInteger acID)
    TInteger TTCAPDialogue::getac()


DESCRIPTION

    获取/设置一个对话所使用的AC


ARGUMENTS

    acID: 整数，-2表示不使用AC，否则必须是scf程序的ac命令所能看到的acID

    

RETURN

    对于getac，返回-2表示AC不存在，否则是ac命令中所能看到的acID


NAME

    TTCAPDialogue::setladdr, TTCAPDialogue::setraddr


SYNOPSIS

    TInteger TTCAPDialogue::setladdr(TInteger ri, TInteger pc, TInteger 
    ssn, TInteger tt, TInteger np, TInteger nai, TString gt)
    TInteger TTCAPDialogue::setraddr(TInteger ri, TInteger pc, TInteger 
    ssn, TInteger tt, TInteger np, TInteger nai, TString gt)


DESCRIPTION

    设置本地或者远端的地址，根据这些参数的组合，系统会根据编码标准构地址
    


ARGUMENTS

    ri: Routing indicator, 路由指示，整数，0表示根据GT寻址，1表示根据PC寻
    址

    pc: 点码，整数，-1表示不选这项，其它正数将根据点码长度要求被编为14位
    或者24位点码，如果是14位，编码为2字节整数高位在第二字节的地5位，如果是
    24位，编码为3字节，整数高位为第三字节的第7位

    ssn: 子系统号，整数，-1表示不选这项，其它根据网络要求制定

    tt: Translation type, 整数，-1表示不选这项，1-63表示国际业务，128-254国
    内网络指定

    np: Numbering plan, 整数
    -1表示不选这项，
    1: ISDN/telephony numbering plan (ITU-T E.163 and E.164), 
    2: generic numbering plan, 3: data numbering plan (ITU-T X.121), 
    4: telex numbering plan (ITU-T F.69), 
    5: maritime mobile numbering plan (ITU-T E.210, E.211), 
    6: land mobile numbering plan (ITU-T E.212), 
    7: ISDN/mobile numbering plan (ITU-T E.214), 
    14: private network or network-specific numbering plan

    nai: Nature of address indicator, 整数，-1表示不选这项，1: subscriber 
    number, 3: national significant number 4: international number

    gt: GT码，字符串，''表示不选这项，其它为ASC格式的GT码


RETURN

    0


EXAMPLES

    var TTCAPDialogue d;
    ...
    d.setraddr(1,258,12,-1,-1,-1,'');
    // For no GT
    // encode result: 43 02 01 00 0C
    
    d.setraddr(0,258,12,-1,-1,3,'12345');
    // Only NAI parameter in GT head
    // encode result: 07 02 01 00 0C 83 21 43 F5
    
    d.setraddr(0,258,12,1,1,-1,'12345');
    // TT and NP parameter in GT head
    // encode result: 0F 02 01 00 0C 01 11 21 43 F5
    
    d.setraddr(0,258,12,1,1,3,'12345');
    // TT, NP and NAI parameters in GT head
    // encode result: 13 02 01 00 0C 01 11 03 21 43 F5
    
    d.setraddr(0,-1,-1,1,1,3,'12345');
    // For no PC and SSN
    // encode result: 10 01 11 03 21 43 F5
    
    d.setraddr(0,258,12,1,1,3,'12345');
    // For 14 bit PC
    // encode result: 13 02 01 0C 01 11 03 21 43 F5

NAME

    TTCAPDialogue::unireq


SYNOPSIS

    TInteger TTCAPDialogue::unireq(TString userInfo='')


DESCRIPTION

    请求UNIDIRECTIONAL原语


ARGUMENTS

    userInfo: 字符串，缺省为空串，用户信息


RETURN

    0


NAME

    TTCAPDialogue::beginreq


SYNOPSIS

    TInteger TTCAPDialogue::beginreq(TString userInfo='', TInteger type=
    0)


DESCRIPTION

    请求BEGIN原语


ARGUMENTS

    userInfo: 字符串，缺省为空串，用户信息

    type: 整数，缺省0表示普通Begin, 1表示QueryWithPermition，2表示QueryWithoutPermition

    

RETURN

    0


NAME

    TTCAPDialogue::continuereq


SYNOPSIS

    TInteger TTCAPDialogue::continuereq(TString userInfo='', TInteger type=
    0)


DESCRIPTION

    请求CONTINUE原语


ARGUMENTS

    userInfo: 字符串，缺省为空串，用户信息

    type: 整数，缺省0表示普通Continue, 1表示ConversationWithPermition，2表
    示ConversationWithoutPermition


RETURN

    0


NAME

    TTCAPDialogue::endreq


SYNOPSIS

    TInteger TTCAPDialogue::endreq(TString userInfo='', TInteger type=0)
    


DESCRIPTION

    请求END原语


ARGUMENTS

    userInfo: 字符串，缺省为空串，用户信息

    type: 整数，缺省0表示Basic end, 1表示Prearrange End


RETURN

    0


NAME

    TTCAPDialogue::abortreq


SYNOPSIS

    TInteger TTCAPDialogue::abortreq(TString userInfo='', TInteger reason=
    0)


DESCRIPTION

    请求U-ABORT原语


ARGUMENTS

    userInfo: 字符串，缺省为空串，用户信息

    reason: 整数，ABORT的原因，缺省0，
    0: 无法识别的消息类型,
    1: 无法识别的事务处理ID,
    2: 事务处理部分格式错误,
    3: 不正确的事物处理部分,
    4: 事务处理资源限制


RETURN

    0


NAME

    TTCAPDialogue::invokereq


SYNOPSIS

    TInteger TTCAPDialogue::invokereq(TInteger opID, TInteger opType, TInteger 
    timeout, TString para, TInteger linkedid=-1)


DESCRIPTION

    请求INVOKE原语


ARGUMENTS

    opID: 整数，要发送的操作的操作码

    opType: 整数，要发送操作的操作类型:
    1: 是正确有结果返回，错误有错误返回，
    2: 是无结果返回，如果错误有错误返回，
    3: 是正确有结果返回，错误无返回，
    4: 正确错误都无返回

    timeout: 整数，要发送操作的超时设置值，以秒为单位

    papa: 字符串，要发送操作的参数的ASC码形式的字符串，长度必须为偶数。例
    如要发送30 03 80 01 01，那么这个字符串是'0330081010'

    linkedID: 整数，如果这个操作时前面某个对方发过来的操作的链接操作，那
    么这里需要填写彼操作的InvokeID，例如INAP协议中，如果请求SRR的时候，这
    里需要填写前面收到的PA操作的InvokeID。缺省-1，不填写


RETURN

    0


NAME

    TTCAPDialogue::resultreq


SYNOPSIS

    TInteger TTCAPDialogue::resultreq(TInteger invokeID, TInteger opID, 
    TString para='')


DESCRIPTION

    请求RESULT-L原语


ARGUMENTS

    invokeID: 整数，前面收到的操作的InvokeID

    opID: 整数，要发送的结果对应的操作的操作码

    papa: 字符串，要发送结果的参数的ASC码形式的字符串，长度必须为偶数。例
    如要发送30 03 80 01 01，那么这个字符串是'0330081010'，缺省为没有参数

    

RETURN

    0


NAME

    TTCAPDialogue::errorreq


SYNOPSIS

    TInteger TTCAPDialogue::errorreq(TInteger invokeID, TInteger errorID,
     TString para='')


DESCRIPTION

    请求U-ERROR原语


ARGUMENTS

    invokeID: 整数，前面收到的操作的InvokeID

    errorID: 整数，要发送的错误的错误ID

    papa: 字符串，要发送错误的参数的ASC码形式的字符串，长度必须为偶数。例
    如要发送30 03 80 01 01，那么这个字符串是'0330081010'，缺省为没有参数

    

RETURN

    0


NAME

    TTCAPDialogue::rejectreq


SYNOPSIS

    TInteger TTCAPDialogue::rejectreq(TInteger invokeID, TInteger problemType,
     TInteger problemID)


DESCRIPTION

    请求U-REJECT原语


ARGUMENTS

    invokeID: 整数，前面收到的操作的InvokeID

    problemType: 整数，要发送的问题码类型：
    问题码类型0x80表示一般问题（general problem）
    问题码类型0x81表示调用问题（invoke problem）
    问题码类型0x82表示返回结果问题（return result problem）
    问题码类型0x83表示返回错误问题（return error problem）

    problemID: 整数，问题码：
    问题码类型0x80对应的问题码取值如下：
    	0x00  未被识别的成分（unrecognized component）
    	0x01  成分类型错误（mistype component）
     	0x02  成分结构不良（badly structured component）
    问题码类型0x81对应的问题码取值如下：
     	0x00 重复的调用ID（duplicated invoke ID）
     	0x01 未被识别的操作（unrecongnized operation）
     	0x02 参数类型错误 (mistyped parameter)
     	0x03 资源限制 (resource limitation)
     	0x04 启动释放 (initiating release)
     	0x05 未被识别的链接ID (unrongnized linked ID)
     	0x06 非预期的链接相应 (linked response unexpected)
     	0x07 非预期的链接操作( unexpected linked operation)
    问题码类型0x82对应的问题码取值如下：
     	0x00 未被识别的调用ID(unrecognized invoke ID)
     	0x01 返回非预期的结果（return result unexpected）
     	0x02 按时类型错误（mistyped parameter）
    问题码类型0x83对应的问题码取值如下：
     	0x00 未被识别的调用ID(unrecognized invoke ID)
     	0x01 非预期的返回差错（return error unexpected）
     	0x02 未被识别的差错（unrecongnized error）
     	0x03 非预期差错（unexpected error）
     	0x04 参数类型错误（mistyped parameter）


RETURN

    0


NAME

    TTCAPDialogue::waitresult, TTCAPDialogue::waitlinked


SYNOPSIS

    TInteger TTCAPDialogue::waitresult(TInteger timeOut=5, TInteger disableInt=
    1)
    TInteger TTCAPDialogue::waitlinked(TInteger timeOut=5, TInteger disableInt=
    1)


DESCRIPTION

    waitresult用于同步等待RESULT，一般在invokereq发送了类型为1或者3的操作
    之后调用，例如INAP协议中，发了PC操作之后可以调用这个函数等待RESULT。
    
    waitlinked用于同步等待Linked的INVOKE，一般在invokereq发送了需要Linked操
    作的操作之后调用，例如INAP协议中，发了PA操作之后可以调用这个函数等待SRR

    

ARGUMENTS

    timeOut: 整数，等待的时长，秒为单位，缺省为5秒

    disableInt: 整数，是否屏蔽其他事件的打断，缺省为屏蔽


RETURN

    返回18表示收到了RESULT，返回0表示收到了INVOKE，返回2表示收到了ERROR

    

NAME

    TDiameter::getversion, TDiameter::setversion


SYNOPSIS

    TInteger TDiameter::getversion()
    TInteger TDiameter::setversion(TInteger ver)


DESCRIPTION

    获取/设置协议版本号


ARGUMENTS

    ver: 整型，版本号，当前固定为1


RETURN

    


NAME

    TDiameter::getcommandcode, TDiameter::setcommandcode


SYNOPSIS

    TInteger TDiameter::getcommandcode()
    TInteger TDiameter::setcommandcode(TInteger code)


DESCRIPTION

    获取/设置命令码


ARGUMENTS

    code: 命令码，可以是如下取值：
    TDiameter::CapabilitiesExchange (257)
    TDiameter::ReAuth (258)
    TDiameter::Accounting (271)
    TDiameter::CreditControl (272)
    TDiameter::AbortSession (274)
    TDiameter::SessionTermination (275)
    TDiameter::DeviceWatchdog (280)
    TDiameter::DisconnectPeer (282)


RETURN

    


NAME

    TDiameter::getappid, TDiameter::setappid


SYNOPSIS

    TInteger TDiameter::getappid()
    TInteger TDiameter::setappid(TInteger id)


DESCRIPTION

    获取/设置应用码


ARGUMENTS

    id: 整型，应用ID


RETURN

    


NAME

    TDiameter::getrflag, getpflag, geteflag, gettflag, setrflag, seteflag,
     setpflag, settflag


SYNOPSIS

    TInteger TDiameter::getrflag()
    TInteger TDiameter::getpflag()
    TInteger TDiameter::geteflag()
    TInteger TDiameter::gettflag()
    TInteger TDiameter::setrflag(TInteger flag)
    TInteger TDiameter::seteflag(TInteger flag)
    TInteger TDiameter::setpflag(TInteger flag)
    TInteger TDiameter::settflag(TInteger flag)


DESCRIPTION

    获取/设置命令标志:
    getrflag()和setrflag()操作R(equest)标志
    getpflag()和setpflag()操作P(roxiable)标志
    geteflag()和geteflag()操作E(rror)标志
    gettflag()和gettflag()操作T(Potentially re-transmitted message)标志

    

ARGUMENTS

    flag: 整型，0或1，设置或取消该标志


RETURN

    


NAME

    TDiameter::request


SYNOPSIS

    TInteger TDiameter::request()


DESCRIPTION

    发送请求，同步等待结果


ARGUMENTS

    无

RETURN

    错误码


NAME

    TDiameter::response


SYNOPSIS

    TInteger TDiameter::response()


DESCRIPTION

    发送响应消息。请求对象设置相关参数后可以调用该方法发出响应消息。


ARGUMENTS

    无

RETURN

    错误码


NAME

    TDiameter::encode


SYNOPSIS

    TString TDiameter::encode(TInteger type=0 )


DESCRIPTION

    对Diameter消息进行编码，通常是测试目的使用


ARGUMENTS

    type: encode的类型，0为request, 1为response，缺省为0


RETURN

    


NAME

    TDiameter::decode


SYNOPSIS

    TInteger TDiameter::decode(TString s)


DESCRIPTION

    对原始Diameter消息进行解码，并重构当前调用解码的Diameter对象，通常测
    试目的使用


ARGUMENTS

    s: 字符串，bin格式的diameter消息，


RETURN

    


NAME

    TDiameter::setcontent


SYNOPSIS

    TInteger TDiameter::setcontent(TString s, TInteger length=0 )


DESCRIPTION

    设置对象要编码的内容


ARGUMENTS

    s: 要设置的内容字符串

    length: 有效长度，如果为0，则是参数s的字符串总长度


RETURN

    


NAME

    TDiameter::getcontent


SYNOPSIS

    TString TDiameter::getcontent( )


DESCRIPTION

    获取Diameter原始消息


ARGUMENTS

    无

RETURN

    


NAME

    TDiameter::getvalue


SYNOPSIS

    TString TDiameter::getvalue(tagpath, TString defaultValue)
    TInteger TDiameter::getvalue(tagpath, TInteger defaultValue)


DESCRIPTION

    获取Diameter消息具体AVP的值


ARGUMENTS

    tagpath: 需要取值avp的TagPath

    defaultValue: 如果取值不成功，返回的默认值


RETURN

    


NAME

    TDiameter::settimer


SYNOPSIS

    TInteger TDiameter::settimer(TInteger timer)


DESCRIPTION

    设置请求超时时间


ARGUMENTS

    timer: 整型，单位为秒


RETURN

    


NAME

    TDiameter::geterrno


SYNOPSIS

    TInteger TDiameter::geterrno( )


DESCRIPTION

    获取当前错误号


ARGUMENTS

    无

RETURN

    


NAME

    TDiameter::clearerrno


SYNOPSIS

    TInteger TDiameter::clearerrno( )


DESCRIPTION

    清除当前错误号


ARGUMENTS

    无

RETURN

    


NAME

    TDiameter::getresultcode


SYNOPSIS

    TInteger TDiameter::getresultcode( )


DESCRIPTION

    获取当前返回码


ARGUMENTS

    无

RETURN

    返回码


NAME

    TDiameter::onrequest


SYNOPSIS

    TInteger TDiameter::onrequest([eventProcessLabel])


DESCRIPTION

    设置对象的请求事件入口，一个请求对象也可能收到对端发送的请求消息(比如
    RAR)，此时激活该对象请求事件。事件激活时压栈。


ARGUMENTS

    arg1: 事件入口


RETURN

    


NAME

    getdiamsession


SYNOPSIS

    TString getdiamsession(TString host)


DESCRIPTION

    客户端开发时必须调用这个函数来构造SessionID。


ARGUMENTS

    host: 填写Origin-Host


RETURN

    SessionID


NAME

    TRadius::getcommandcode


SYNOPSIS

    TInteger TRadius::getcommandcode()


DESCRIPTION

    获取命令码


ARGUMENTS

    无

RETURN

    


NAME

    TRadius::setcommandcode


SYNOPSIS

    TInteger TRadius::setcommandcode(TInteger )


DESCRIPTION

    设置命令码，通常在发送请求前设置


ARGUMENTS

    arg1: 命令码


RETURN

    


NAME

    TRadius::getreqid, TRadius::setreqid


SYNOPSIS

    TInteger TRadius::getreqid() 
    TInteger TRadius::setreqid(TInteger reqID)


DESCRIPTION

    getreqid: 获取调用ID, setreqid: 设置调用ID


ARGUMENTS

    reqID: 调用ID


RETURN

    


NAME

    TRadius::getauth, setauth


SYNOPSIS

    TString TRadius::getauth()
    TInteger TRadius::setauth(TString auth)


DESCRIPTION

    获取/设置鉴权信息


ARGUMENTS

    auth: 固定16个字节的鉴权信息，一般是一个md5的加密结果


RETURN

    固定16个字节的鉴权信息，一般是一个md5的加密结果


NAME

    TRadius::getcontent, setcontent


SYNOPSIS

    TString TRadius::getcontent()
    TInteger TRadius::setcontent(TString s, TInteger length=0)


DESCRIPTION

    setcontent()设置对象要编码的内容
    getcontent()获取Radius原始消息


ARGUMENTS

    s: 要设置的内容字符串

    length: 有效长度，如果为0，则是参数s的字符串总长度


RETURN

    


NAME

    TRadius::encode


SYNOPSIS

    TString TRadius::encode()


DESCRIPTION

    对Radius消息进行编码


ARGUMENTS

    无

RETURN

    返回编码之后的完整的Radius消息可以直接发送


EXAMPLES

    var TRadius r;
    var TString s, sr;
    r = new TRadius;
    r.setcommandcode(2);
    r.setid(10);
    r.setauth('1234567890123456'); // a string after md5 encryption
    r.setcontent(s); // s is constructed by xmlsib
    sr=r.encode();
    udpsend(argv0,atoi(argv1),sr); // send the messagae

NAME

    TRadius::decode


SYNOPSIS

    TInteger TRadius::decode(TString s)


DESCRIPTION

    对原始Radius消息进行解码，并重构当前调用解码的Radius对象


ARGUMENTS

    s: 字符串，bin格式的Radius消息


RETURN

    


NAME

    TRadius::getvalue


SYNOPSIS

    TString TRadius::getvalue(tagpath, TString defaultValue)
    TInteger TRadius::getvalue(tagpath, TInteger defaultValue)


DESCRIPTION

    获取Radius消息具体参数的值


ARGUMENTS

    tagpath: 需要取值参数的TagPath

    defaultValue: 如果取值不成功，返回的默认值


RETURN

    取值的结果


EXAMPLES

    var TRadius r = new TRadius();
    r.decode(s); // s a complete radius message from UDP
    
    // get the string parameter
    var TString s1=r.getvalue(<<radius.invoke.access-request.user-name>>
    ,'null');
    var TString s2=r.getvalue(<<radius.invoke.access-request.user-password>
    >,'null');
    var TString s3=r.getvalue(<<radius.invoke.access-request.nas-ip-address>
    >,'null');
    
    // get the integer parameter
    var TInteger i1=r.getvalue(<<radius.invoke.access-request.nas-port>>
    ,-1);
    
    // get one parameter array element
    var TString s5=r.getvalue(<<radius.invoke.access-request.framed-compression[
    1]>>,'null');
    var TString s6=r.getvalue(<<radius.invoke.access-request.framed-compression[
    2]>>,'null');
    
    // get parameter array elements number
    i2=r.getvalue(<<radius.invoke.access-request.framed-compression>>,0)
    ;

NAME

    TSCPTable::TSCPTable


SYNOPSIS

    TSCPTable::TSCPTable(TInteger row, TInteger col)


DESCRIPTION

    构造函数，两个参数决定字符串表的大小


ARGUMENTS

    row: 行数

    col: 列数


RETURN

    


EXAMPLES

    var TSCPTable t;
    t = new TSCPTable(2,3);

NAME

    TSCPTable[][]


SYNOPSIS

    TSCPTable[][]=TString
    TString=TSCPTable[][]


DESCRIPTION

    设置或者获取字符串表中某个元素的值，方括弧内是下标，下标必须是从1开始
    


ARGUMENTS

    无

RETURN

    


EXAMPLES

    var TString s;
    var TSCPTable t;
    t = new TSCPTable(2,2);
    t[1][2] = 'aaaaa';
    s = t[1][2];

NAME

    TSCPTable::resize


SYNOPSIS

    TInteger TSCPTable::resize(TInteger row, TInteger col)


DESCRIPTION

    改变字符串表的大小。通常，对字符串表的元素进行赋值的时候，字符串表会
    根据下标自动调整表格的大小，但是，为了提高效率，可以首先调用resize将其
    改变为预期的大小


ARGUMENTS

    row: 行数

    col: 列数


RETURN

    0


EXAMPLES

    var TString s;
    var TSCPTable t;
    t = new TSCPTable(2,2);
    t.resize(10,10);

NAME

    TSCPTable::coltostr, TSCPTable::rowtostr


SYNOPSIS

    TString TSCPTable::coltostr(TInteger index,TString sep='|')
    TString TSCPTable::coltostr(TString colTitle,TString sep='|')
    TString TSCPTable::rowtostr(TInteger index,TString sep='|')


DESCRIPTION

    将字符串表的某一列或者某一行转换为一个字符串返回


ARGUMENTS

    index: 列号或者行号，从1开始

    colTital: 列的名字

    sep: 分割符，缺省为竖线


RETURN

    返回构造好的字符串


EXAMPLES

    var TSCPTable t;
    t=new TSCPTable(3,4);
    t[1][1]='11';
    t[2][1]='21';
    t[3][1]='31';
    t[1][4]='14';
    // 11  -   -   14
    // 21  -   -   -
    // 31  -   -   -
    assert(t.coltostr(1,'|') == '11|21|31');
    assert(t.rowtostr(1,'|') == '11|||14');

NAME

    TSCPTable::tostr


SYNOPSIS

    TString TSCPTable::tostr(TString rowsep=回车,TString colsep='|',TString 
    colFilter='')


DESCRIPTION

    将字符串表整体转换为一个字符串返回


ARGUMENTS

    rowsep: 每一行的分割符，缺省为单个回车

    colsep: 每一列的分割符，缺省为竖线

    colFilter: 列过滤器，是一个字符串，由数字0或者1组成，如果列号小于等于
    字符串的长度，那么colFilter相应位置为0的列将不被构造到返回字符串中。

    

RETURN

    构造好的字符串


EXAMPLES

    var TSCPTable t;
    t=new TSCPTable(3,4);
    t[1][1]='11';
    t[2][1]='21';
    t[3][1]='31';
    t[1][4]='14';
    print(t.tostr());
    将显示：
    11|||14|
    21||||
    31||||
    print(t.tostr('\n','|','1000');
    将只显示第一列：
    11|
    21|
    31|

NAME

    TSCPTable::toxml, TSCPTable::toxml2


SYNOPSIS

    TString TSCPTable::toxml()
    TString TSCPTable::toxml2()


DESCRIPTION

    将字符串表中的所有内容转换为xml格式，toxml返回的是带回车缩进的xml串，
    toxml2返回的是紧缩格式的xml串


ARGUMENTS

    无

RETURN

    转换之后的xml格式的字符串


EXAMPLES

    var TSCPTable t;
    t=new TSCPTable(3,4);
    t[1][1]='11';
    t[2][1]='21';
    t[3][1]='31';
    t[1][4]='14';
    assert(t.toxml() ==
    '<table>
       <row>
          <col>11</col>
          <col></col>
          <col></col>
          <col>14</col>
       </row>
       <row>
          <col>21</col>
          <col></col>
          <col></col>
          <col></col>
       </row>
       <row>
          <col>31</col>
          <col></col>
          <col></col>
          <col></col>
       </row>
    </table>');
    
    assert(t.toxml2() ==
    '<table> <row><col>11</col><col></col><col></col><col>14</col></row>
     <row><col>21
    </col><col></col><col></col><col></col></row> <row><col>31</col><col>
    </col><col>
    </col><col></col></row></table>');

NAME

    TSCPTable::settitle, TSCPTable::cleartitle


SYNOPSIS

    TInteger TSCPTable::settitle(TInteger col,TString title)
    TInteger TSCPTable::cleartitle()


DESCRIPTION

    设置，清除列的名字。设置了列名之后的字符串表转换为xml格式的时候，元素
    的tag将使用这些名字


ARGUMENTS

    col: 列号，从1开始

    title: 列的名字


RETURN

    0


EXAMPLES

    var TSCPTable t;
    t=new TSCPTable(3,4);
    t[1][1]='11';
    t[2][1]='21';
    t[3][1]='31';
    t[1][4]='14';
    t.settitle(1,'A');
    t.settitle(2,'B');
    t.settitle(3,'C');
    t.settitle(4,'D');
    assert(t.toxml2() ==
    '<table><record><A>11</A><B></B><C></C><D>14</D></record><record><A>
    21</A><B></B>
    <C></C><D></D></record><record><A>31</A><B></B><C></C><D></D></record>
    </table>');

NAME

    TSCPTable::rowcount, TSCPTable::colcount


SYNOPSIS

    TInteger TSCPTable::rowcount()
    TInteger TSCPTable::colcount()


DESCRIPTION

    返回字符串表当前的行数和列数


ARGUMENTS

    无

RETURN

    行数或者列数


EXAMPLES

    var TSCPTable t;
    t=new TSCPTable(3,4);
    assert(t.rowcount() == 3);
    assert(t.colcount() == 4);

NAME

    TSCPTable::colname, TSCPTable::colid


SYNOPSIS

    TString TSCPTable::colname(TInteger colid)
    TInteger TSCPTable::colid(TString colname)


DESCRIPTION

    根据列号获得列名，根据列名获得列号


ARGUMENTS

    colid: 列号

    colname: 列名，即title


RETURN

    返回的列号或者列名


EXAMPLES

    var TSCPTable t;
    t=new TSCPTable(3,4);
    t[1][1]='11';
    t[2][1]='21';
    t[3][1]='31';
    t[1][4]='14';
    t.settitle(1,'A');
    t.settitle(2,'B');
    t.settitle(3,'C');
    t.settitle(4,'D');
    assert(t.colid('A') == 1);
    assert(t.colname(3) == 'C');

NAME

    TSCPTable::filter


SYNOPSIS

    TInteger TSCPTable::filter(TInteger col, TString pattern, TInteger mode=
    1)


DESCRIPTION

    按照指定列过滤/筛选，筛选后原表保留，只是此时再操作就是在筛选的记录集
    进行了。当pattern='*'时，可以取消筛选，恢复原始记录集。注意：筛选可以
    加强，就是在筛选的记录上再进行筛选，取消的时候直接恢复原始记录集合


ARGUMENTS

    col: 参与筛选的列号

    pattern: 筛选的匹配规则，支持通配符'*'  '?'等，能力同函数dosmatchpattern(
    )。当mode为1时，'*'取消筛选操作

    mode: 1表示匹配pattern的被选中，0表示不匹配pattern的被选中


RETURN

    整数0


EXAMPLES

    var TSCPTable t;
    t=new TSCPTable(3,4);
    t[1][1]='11';
    t[2][1]='21';
    t[3][1]='31';
    t[1][4]='14';
    t.settitle(1,'A');
    t.settitle(2,'B');
    t.settitle(3,'C');
    t.settitle(4,'D');
    
    // select the rows that first column is begin with '1'
    t.filter(1,'1*');
    assert(t.toxml2() ==
    '<table><record><A>11</A><B></B><C></C><D>14</D></record></table>');
    
    
    // undo the filter action
    t.filter(1,'*');
    assert(t.toxml2() ==
    '<table><record><A>11</A><B></B><C></C><D>14</D></record><record><A>
    21</A><B></B>
    <C></C><D></D></record><record><A>31</A><B></B><C></C><D></D></record>
    </table>');
    
    // select the rows that first column is not begin with '1'
    t.filter(1, '1*', 0);
    assert(t.toxml2() ==
    '<table><record><A>21</A><B></B><C></C><D></D></record><record><A>31<
    /A><B></B>
    <C></C><D></D></record></table>');

NAME

    TSCPTable::orderby


SYNOPSIS

    TInteger TSCPTable::orderby(TInteger col, TInteger mode=0)


DESCRIPTION

    按照指定列排序


ARGUMENTS

    col: 参与排序的列号

    mode: 排序方式，缺省0为字符串方式比较，1为整数方式比较


RETURN

    0


NAME

    TSCPTable::diffbycol


SYNOPSIS

    TSCPTable TSCPTable::diffbycol(TSCPTable table2, TInteger col1, TInteger 
    col2)


DESCRIPTION

    自身某一列和另外一个字符串表某一列比较，返回比较的结果


ARGUMENTS

    table2: 另一个字符串表

    col1: 自身参与比较的列号

    col2: 另一个字符串表参与比较的列号


RETURN

    返回比较的结果，比较的结果将存放在一个只有一列的新字符串表中


EXAMPLES

    var TSCPTable t, t2, t3;
    t=new TSCPTable(3,4);
    t[1][1]='11';
    t[2][1]='21';
    t[3][1]='31';
    t[1][4]='14';
    t2=new TSCPTable(2,2);
    t2[2][1]='21';
    t3=t.diffbycol(t2,1,1);
    assert(t3.tostr('|') == '11|31');

NAME

    TCommandLine::argc


SYNOPSIS

    TInteger TCommandLine::argc()


DESCRIPTION

    返回TCommandLine对象的参数个数


ARGUMENTS

    无

RETURN

    整数，参数个数


EXAMPLES

    void main(TCommandLine cmd)
    {
       print(itoa(cmd.argc()));  // display the argument number
    }

NAME

    TCommandLine::argv


SYNOPSIS

    TString TCommandLine::argv(TInteger index=-1)


DESCRIPTION

    返回TCommandLine对象的某个参数的值


ARGUMENTS

    index: 参数的索引，-1表示所有参数，其它0-29表示具体的某个参数


RETURN

    字符串，具体的参数


EXAMPLES

    void main(TCommandLine cmd)
    {
       var TInteger i;
       print(cmd.argv()); // display the whole message
       for(i=0; i<cmd.argc(); i=i+1)
          print(cmd.argv(i));  // display each argument
    }

NAME

    TCommandLine::getarg


SYNOPSIS

    TString[] TCommandLine::getarg()


DESCRIPTION

    返回TCommandLine对象参数


ARGUMENTS

    无

RETURN

    TCommandLine对象参数,TString[]


EXAMPLES

    void main(TCommandLine cmd)
    {
       var TString args[];
       args=cmd.getarg();
       print(args[1]);
    }

NAME

    TCommandLine::getxmltree


SYNOPSIS

    TXMLTree TCommandLine::getxmltree()


DESCRIPTION

    serviceEvent事件导致的TCommandLine对象，有可能其中保存有消息解析结果
    中的xml树，这个函数用来获得这个xml树
    这个xml对象不能使用delete函数删除


ARGUMENTS

    无

RETURN

    xml树的句柄


EXAMPLES

    var TXMLTree x;
    on(serviceEvent, TCommandLine cmd)
    {
       x=cmd.getxmltree();
       print(x.tostr());
    }

NAME

    TCommandLine::getinesobj


SYNOPSIS

    TINESObj TCommandLine::getinesobj()


DESCRIPTION

    对于INES或者别的自动机调用子业务逻辑导致的TCommandLine对象，子业务逻
    辑可以调用这个函数来获得相关的TINESObj对象，然后利用这个对象来回送消息
    。
    这个TINESObj对象不能使用delete函数删除


ARGUMENTS

    无

RETURN

    TINESObj对象的句柄


EXAMPLES

    void main(TCommandLine cmd)
    {
       var TINESObj i;
       i=cmd.getinesobj();
       i.synctofsm('serviceevent a b');
       ...
    }

NAME

    the-end
